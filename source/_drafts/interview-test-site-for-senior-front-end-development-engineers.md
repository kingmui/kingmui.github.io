---
title: 前端开发工程师面试必知必会
date: 2017-05-01 20:24:29
tags:
  - 面试
comments: true
---

## 技术面

### 输入 URL 后发生了什么

从耗时过程来看，可以分为：

1. [DNS 解析](#DNS-解析)
2. [TCP 连接](#TCP-连接)
3. [HTTP 请求与响应](#HTTP-请求与响应)
4. 客户端浏览器解析渲染
   - [HTML 词法、语法解析](#HTML-词法、语法分析)
   - CSS 解析
   - DOM 树生成
   - 渲染树建立
   - [屏幕绘制](#屏幕绘制)

#### DNS 解析

当我们在浏览器中输入如 `www.taobao.com` 的时候，DNS 解析充当了一个翻译的角色，把网址“翻译”成了 **IP 地址**。DNS 解析的过程就是域名到 IP 地址的转换过程，即将好记的域名解析成 IP，这一服务由 DNS 服务器完成，把域名解析到一个 IP 地址，然后在此 IP 地址的主机上**将一个子目录与域名绑定**。

<!-- more -->

![DNS域名解析流程图](http://cdn.kingmui.cn/DNS-domain-name-resolution-process.png)

#### TCP 连接

TCP 连接的重要目的，是为了保证消息的**有序**和**不丢包**。为了建立可靠的数据传输，TCP 通信双方**相互告知初始化序列号**，并确定对方已经收到 SN，整个连接的过程就是我们俗称的**三次握手**。

![TCP连接的建立（三次握手）](http://cdn.kingmui.cn/TCP-connection-establishment.jpg)

最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。

1. TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态
2. TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文，这时报文首部中的同部位 SYN=1，同时选择一个初始序列号 `seq=x` ，此时，TCP 客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP 规定，SYN 报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号
3. TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 `seq=y`，此时，TCP 服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号
4. TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1，此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号
5. 当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了

#### HTTP 请求与响应

HTTP 请求主要发生在客户端，发送 HTTP 请求的过程就是构建 HTTP 请求报文并通过 TCP 协议发送到服务器指定端口的过程。

当在地址栏输入后，浏览器会分析这个 URL，并设置好请求报文发出。请求报文中包括：

1. **请求行**（请求方法、路径和协议版本）
2. **请求头**（附加的请求信息，一般是以键值对的形式成对存在）
3. **空行**（协议中规定请求头和请求体间必须用一个空行隔开）
4. **请求体**（对于 POST 请求，参数不会放在 URL 中，这时就需要一个载体了，即请求体）

服务端收到这个请求后，会根据 URL 匹配到的路径做相应的处理，最后返回浏览器页面需要的资源。处理后，浏览器会收到一个响应报文，而所需要的资源就在报文主体上。与请求报文相同，响应报文也有与之对应的：

1. **起始行**（响应报文的起始行同样包含了协议版本，与请求的起始行不同的是其还包含状态码和状态码的原因短语）
2. **响应头**（对应请求报文中的请求头，格式一致，但是各自有不同的首部）
3. **空行**
4. **报文主体**（请求需要的资源）

#### HTML 词法、语法分析

对我们来说，HTML 其实是一坨字符串，而实际上我们要面对的是“字符流”。为了把字符流解析成正确的可被浏览器识别的结构，我们需要做的事情分为两步：

1. 词法分析：把字符流初步解析成我们可理解的“词”，学名叫 token
2. 语法分析：把开始结束标签配对，属性赋值好，父子关系连接好，构成 DOM 树

#### 屏幕绘制

![webkit渲染树建立](http://cdn.kingmui.cn/webkit-render-tree.webp)

DOM 树的生成和渲染树建立比较好理解，这里就不做展开。完成了这“两棵树”的构建后，就进入屏幕绘制阶段。

在绘制的过程中，会**遍历渲染树**，调用由浏览器的 UI 组件提供的 `paint()` 方法在屏幕上显示对应的内容，并根据渲染树布局，计算 CSS 样式（即每个节点在页面中的大小和位置等几何信息）。

HTML 默认是从上到下流式布局的，CSS 和 JS 的加入会打破这种布局，改变了 DOM 的外观样式以及大小和位置。这就引出了两个非常重要的概念：

**Repaint（重绘）**：屏幕的一部分重新绘制，<u>不影响整体布局</u>，比如某个 CSS 的背景色变了，但元素的几何尺寸和位置不变。

**Reflow（重排）**：意味着<u>元素的几何尺寸改变了</u>，需要重新验证并<u>计算渲染树</u>。是渲染树的一部分或全部发生了变化。

无论是重绘还是重排，对浏览器而言都是一种消耗，所以我们应该尽量避免这两种状态的触发。

### 一个 TCP 连接能发几个 HTTP 请求

如果是 HTTP1.0 版本协议，一般情况下，**不支持长连接**，因此在每次请求发送完毕之后，TCP 连接即会**断开**，因此一个 TCP 只能发送一个 HTTP 请求。但是有一种情况可以将一条 TCP 连接保持在活跃状态，那就是通过 Connection 首部，在请求头带上 `Connection: Keep-Alive`，并且可以通过 Keep-Alive 通用首部中指定的，用逗号分隔的选项调节 Keep-Alive 的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过此方式也有局限，可以关注《HTTP 权威指南》4.5.5 节对于 Keep-Alive 连接的限制和规则。

如果是 HTTP1.1 版本协议，支持了**长连接**，因此只要 TCP 连接不断开，便可以一直发送 HTTP 请求，持续不断，没有上限。

如果是 HTTP2.0 版本协议，支持**多路复用**，一个 TCP 连接是可以**并发**多个 HTTP 请求的，同样支持长连接，因此只要不断开 TCP 的连接，HTTP 请求数也是可以没有上限地持续发送。

### Virtual Dom 的优势在哪里

在浏览器中，**DOM 引擎**和 **JS 引擎**相互独立，但又工作在同一线程（主线程）。JS 代码调用 DOM API 必须挂起 JS 引擎，转换传入参数数据，激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行。若有频繁的 DOM API 调用，且浏览器厂商不做“批量处理”优化，**引擎间切换的单位代价将迅速累积**，若其中有强制重绘的 DOM API 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。

虚拟 Dom 和真实 DOM 的区别：

1. 虚拟 DOM **不会立马进行排版和重绘操作**
2. 虚拟 DOM 进行频繁修改，然后**一次性比较并修改真实 DOM 中需要变更的部分**，最后在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗
3. 虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部

### 怎么与服务端保持连接

和服务端保持连接，最简单粗暴的方法就是通过**请求轮询**保持跟服务端的通信，客户端不光要花成本维护定时轮询器，还会使得服务器压力变大，所以不推荐。

还有一种可以**借助请求超时**的设置，将超时时间设置为一个足够大的值，客户端发起连接后，只要服务端不返回消息，整个连接阶段都会受到阻塞，所以这种方式也不推荐。

最后一种是 WebSocket，当服务器完成从 HTTP 到 WebSocket 的协议升级后，**服务端可以主动推送信息给客户端**，解决了轮询造成的同步延迟问题。由于 WebSocket 只需要一次 HTTP 握手，服务端就能一直与客户端保持通信，直到连接关闭，这样就解决了服务器需要反复解析 HTTP 协议，减少了资源的开销。

![websockets](http://cdn.kingmui.cn/websockets.jpg)
![websockets](http://cdn.kingmui.cn/ajax%26websockets.jpg)

### 性能优化，如何加快首屏渲染速度

减少页面初载时，所需加载资源的**数量**和**体积**。

1. **分屏加载**：当页面需要渲染的数据较多时，先渲染首屏，下滑时再加载第二屏的数据
2. **降低请求量**：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP
3. **加快请求速度**：预解析 DNS，减少域名数，并行加载，CDN 分发
4. **增加缓存**：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage、PWA
5. **渲染优化**：首屏内容最小化，JS/CSS 优化，加载顺序，服务端渲染，pipeline
6. **图片大小优化**：在不影响视觉效果的前提下，把图片尺寸降到最小
7. **图片懒加载**：当页面图片资源较多时，仅加载可视区域的图片
8. **Code Spliting**：应用下的某些组件不需要立刻 `import`，可以采用动态 `import()` 的方式，打包时也可以将他们打到不同的 bundle 里，给 index bundle 瘦身
9. **Tree Shaking**
10. [合理利用浏览器缓存](#浏览器缓存机制)

### 浏览器缓存机制

![WEB缓存体系](http://cdn.kingmui.cn/web-cache-system.png)

浏览器中缓存可分为**强缓存**和**协商缓存**：

1. 浏览器在加载资源时，先根据这个资源的一些 `http header` 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如：某个 css 文件，如果浏览器在加载它所在的网页时，这个 css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在服务器；
2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 `http header` 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；
3. 强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：**强缓存不发请求到服务器，协商缓存会发请求到服务器**。
4. 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

#### 强缓存：Expires & Cache-Control

> 强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示**资源在客户端缓存的有效期**。

Expires 是 HTTP 1.0 提出的一个表示资源过期时间的 header，它描述的是一个**绝对时间**，由服务器返回，用 GMT 格式的字符串表示，如：`Expires: Thu, 31 Dec 2037 23:55:55 GMT`。

Expires 是较老的强缓存管理 header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如：**随意修改下客户端时间，就能影响缓存命中的结果**。所以在 HTTP 1.1 的时候，提出了一个新的 header，就是 Cache-Control，这是一个**相对时间**，在配置缓存的时候，以秒为单位，用数值表示，如：`Cache-Control: max-age=315360000`。

Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 Expires，Cache-Control 的缓存管理更有效，安全一些。这两个 header 可以只启用一个，也可以同时启用，当 response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于 Expires。

| 缓存方式      | 优先级 | 描述                                                         | HTTP 版本 |
| ------------- | ------ | ------------------------------------------------------------ | --------- |
| Expires       | 低     | 表示资源的过期时间，是一个**绝对时间**。缺点：依赖客户端时间，如果手动更新了客户端时间，就能影响缓存命中的结果。 | HTTP 1.0  |
| Cache-Control | 高     | 表示资源有效的**一段时间**，是一个**相对时间**。优点：不依赖客户端时间。 | HTTP 1.1  |

#### 协商缓存：Last-Modified & Etag

当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 HTTP 状态码为 304 并且会显示一个 Not Modified 的字符串。

> 协商缓存是利用【Last-Modified，If-Modified-Since】和【ETag，If-None-Match】这两对 Header 来管理的。

【Last-Modified，If-Modified-Since】都是根据服务器时间返回的 header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个 header 配合起来管理协商缓存是非常可靠的，但有时候也会出现服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对 header 来管理协商缓存，这对 header 就是【ETag、If-None-Match】。

| 缓存方式                                                     | 优先级 | 描述                                                         | HTTP 版本 |
| ------------------------------------------------------------ | ------ | ------------------------------------------------------------ | --------- |
| [Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified) | 低     | 表示资源上次更新的时间。缺点：服务器不会实时监听文件的变更，如果我们保存文件过于频繁，Last-Modified 可能不会更新到最后保存的时间。 | HTTP 1.1  |
| [Etag](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag) | 高     | 根据资源内容生成，只要资源内容发生变化，就会更新。           | HTTP 1.1  |

#### 缓存判断流程

![缓存判断流程](http://cdn.kingmui.cn/cache-judgment-process.webp)

参考[前端优化：浏览器缓存技术介绍](https://juejin.im/post/6844903672556552205)

### Cookie 的设置

1. 客户端发送 HTTP 请求到服务器
2. 当服务器收到 HTTP 请求时，在响应头里添加一个 `set-cookie` 字段
3. 浏览器收到响应后保存下 Cookie
4. 之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器

| 字段                        | 描述                                                         |                                                              |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Expires                     | 设置过期时间，只与客户端相关                                 |                                                              |
| Max-Age                     | 优先级高。设置Cookie  失效前需要经过的秒数。                 |                                                              |
|                             | 正数                                                         | 将其持久化，写入对应的 Cookie 文件中                         |
|                             | 负数                                                         | 一个会话性 Cookie                                            |
|                             | 0                                                            | 立即删除这个 Cookie                                          |
| Secure                      | 只应通过被 HTTPS 协议加密过的请求发送给服务端。保证传输过程中不被窃取和篡改 |                                                              |
| HTTPOnly                    | 防止客户端脚本通过 `document.cookie` 等方式访问 Cookie，有助于避免 XSS 攻击 |                                                              |
| SameSite（HTTP 协议不支持） | 让 Cookie **在跨站请求时不会被发送**，从而可以阻止跨站请求伪造攻击（CSRF） |                                                              |
|                             | strict                                                       | 仅允许一方请求携带 Cookie，浏览器只发送相同站点请求的 Cookie，即**当前网页 URL 与请求目标 URL 完全一致** |
|                             | Lax                                                          | 允许部分第三方请求携带 Cookie。从 **Chrome 80**开始，默认屏蔽了第三方的 Cookie |
|                             | None                                                         | 无论是否跨站都会发送 Cookie                                  |

#### 作用

1. 会话状态管理（登录状态，购物车，游戏分数等信息）
2. 个性化设置（自定义设置、主题）
3. 浏览器行为跟踪（分析用户行为）

#### 缺点

大小受限，不够安全，增加了请求大小

### 你知道哪些 HTTP 状态码

| 状态码 | 描述                   |
| ------ | ---------------------- |
| 200    | 请求成功               |
| 301    | 资源永久移动           |
| 302    | 资源临时移动           |
| 304    | 资源未修改             |
| 400    | 客户端请求语法错误     |
| 403    | Forbidden              |
| 404    | Not Found              |
| 405    | 请求方法被禁止         |
| 500    | 服务器内部错误         |
| 503    | 系统维护，暂时无法处理 |

### 如何遍历对象？

1. 利用 [for...in](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 语句以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性。注意：该方案会遍历到对象原型链上的属性，需要使用 `Object.prototype.hasOwnProperty` 过滤原型链上的属性
2. 通过 [Object.keys](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) 得到对象**自身可枚举属性**组成的数组，再通过 `forEach` 等方式遍历
3. 通过 [Object.entries](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) 得到对象**自身可枚举属性的键值对**数组
4. 通过 [Reflect.ownKeys](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys) 得到对象**自身的属性**组成的数组
5. 通过 [Object.getOwnPropertyNames](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames) 得到对象的**所有自身属性**（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组
6. 通过 [Object.getOwnPropertySymbols](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) 得到对象自身的所有 Symbol 属性组成的数组

### this 指向判断步骤

1. 查看函数在哪被调用
2. `.` 点左侧有没有对象？如果有，它就是 `this` 的引用。如果没有，继续第 3 步
3. 该函数是不是用 `call`、`apply` 或者 `bind` 调用的？如果是，它会显式地指明 `this` 的引用。如果不是，继续第 4 步
4. 该函数是不是用 `new` 调用的？如果是，`this` 指向的就是 JS 解释器新创建的对象。如果不是，继续第 5 步
5. 代码是否运行在“严格模式”下？如果是，`this` 就是 `undefined`。如果不是，`this` 会指向 `window` 对象

参考[Understanding the "this" keyword, call, apply, and bind in JavaScript](https://ui.dev/this-keyword-call-apply-bind-javascript/)

### new 命令的原理

使用 `new` 命令时，它后面的函数依次执行下面的步骤。

1. 创建一个空对象，作为将要返回的对象实例
2. 将这个空对象的原型，指向构造函数的 `prototype` 属性
3. 将这个空对象赋值给函数内部的 `this` 关键字
4. 开始执行构造函数内部的代码

也就是说，构造函数内部，`this` 指的是一个新生成的空对象，所有针对 `this` 的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即 `this` 对象），将其“构造”为需要的样子。

如果构造函数内部有 `return` 语句，而且 `return` 后面跟着一个对象，`new` 命令会返回 `return` 语句指定的对象；否则，就会不管 `return` 语句，返回 `this` 对象。

另一方面，如果对普通函数（内部没有 `this` 关键字的函数）使用 `new` 命令，则会返回一个空对象。因为 `new` 命令总是返回一个对象，要么是实例对象，要么是 `return` 语句指定的对象。

参考[实例对象与 new 命令](https://wangdoc.com/javascript/oop/new.html)

### 为什么 HTTPS 比 HTTP 更安全

#### 什么是 HTTPS

> HTTP + 加密 + 认证 + 完整性保护 = HTTPS

![HTTPS](http://cdn.kingmui.cn/http-https.webp)

HTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。

HTTPS 主要作用：

1. 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
2. 对网站服务器进行真实身份认证

#### 为什么需要 HTTPS

> 在 HTTP 协议中有可能存在**信息窃取**或**身份伪装**等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。

HTTP 协议存在的问题：

1. 通信使用明文（不加密），内容可能被窃听
2. 无法证明报文的完整性，报文传输过程中可能遭篡改
3. 不验证通信方的身份，因此有可能遭遇伪装

HTTPS 协议的优势:

1. 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥
2. 数据完整性：内容传输经过完整性校验
3. 身份认证：第三方无法伪造服务端（客户端）身份

#### 解决内容可能被窃听的问题 —— 加密

1. 对称加密：加密和解密用**同一个密钥**。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。
2. 非对称加密：公开密钥加密使用**一对非对称的密钥**。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。
3. 对称加密 + 非对称加密(HTTPS 采用这种方式)：使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。充分利用两者各自的优势，**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。

具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是在安全的前提下，使用对称加密方式进行通信。所以，HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。

#### 解决报文可能遭篡改问题 —— 数字签名

> 网络传输过程中**需要经过很多中间节点**，虽然数据无法被解密，但可能被篡改，需要使用数字签名来校验数据的完整性。

数字签名有两种功效：

1. 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名
2. 数字签名能确定消息的完整性，证明数据是否未被篡改过

```shell
# 生成数字签名

+---------------+
|               |
|               |                     +----------+                     +----------+
|    CONTENT    | ----（哈希函数）----> |  消息摘要  | ----（私钥加密）---->|  数字签名  |
|               |                     +----------+                     +----------+
|               |
+---------------+
```

将一段文本先用 Hash 函数生成**消息摘要**，然后用发送者的**私钥加密**生成数字签名，与原文一起传送给接收者。接下来就是接收者校验数字签名的流程了。

```shell
# 校验数字签名流程

+---------------+
|               |
|               |                     +----------+
|    CONTENT    | ----（哈希函数）----> |  消息摘要  |
|               |                     +----------+
|               |                          |
+---------------+                          |
                                           对
                                           比
                                           |
                                           |
    +----------+                      +----------+
    |  数字签名  | ----（公钥解密）----> |  消息摘要  |
    +----------+                      +----------+
```

接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个**摘要信息**，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。

#### 解决通信方身份可能被伪装的问题 —— 数字证书

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

![数字证书认证机构](http://cdn.kingmui.cn/digital-certificate-certification-authority.png)

数字证书认证机构的业务流程：

1. 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息（域名）等信息并申请认证
2. CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等
3. 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名
4. 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件
5. 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的
6. 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息（包含公钥），如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法

#### HTTPS 工作流程

![HTTPS工作流程](http://cdn.kingmui.cn/HTTPS-workflow.webp)

1. Client 发起一个 HTTPS 请求，根据 RFC2818 的规定，Client 知道需要连接 Server 的 **443 端口**
2. Server 把事先配置好的公钥证书返回给客户端
3. Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示警告信息
4. Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server
5. Server 使用自己的私钥解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥
6. Server 使用对称密钥加密“明文内容A”，发送给 Client
7. Client 使用对称密钥解密响应的密文，得到“明文内容A”
8. Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的“明文内容B”，然后 Server 使用对称密钥解密密文，得到“明文内容B”

参考[深入理解HTTPS工作原理](https://juejin.im/post/6844903830916694030)

## HR 面

- 离职原因
- 职业规划
- 之前的公司分别给了你什么成长
- 工作中有哪些主动推动过的点
- 你觉得自己的优缺点是什么
- 你对我们公司了解吗？用过我们什么产品？对我们的产品有什么建议吗
- 你面了哪些公司，选择一家公司最看重什么
