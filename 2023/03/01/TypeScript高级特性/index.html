<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content=#222><meta name=generator content="Hexo 5.4.0"><link rel=apple-touch-icon sizes=180x180 href=https://cdn.kingmui.cn/avatar.jpg><link rel=icon type=image/png sizes=32x32 href=https://cdn.kingmui.cn/avatar.jpg><link rel=icon type=image/png sizes=16x16 href=https://cdn.kingmui.cn/avatar.jpg><link rel=mask-icon href=https://cdn.kingmui.cn/avatar.jpg color=#222><meta name=google-site-verification content=sNI58_0qBlj048P3M9VIK0edTYQ9zf2quRwRS7aNr2w><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin=anonymous><script class=next-config data-name=main type=application/json>{"hostname":"www.kingmui.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta name=description content="前言TypeScript 是由安德斯·海尔斯伯格（Anders Hejlsberg）在微软开发的严格超集语言，是 JavaScript 的一个强类型版本。任何 JavaScript 中的特性都可以在 TypeScript 中使用，这也就意味着我们可以运用已熟知的 JavaScript 技能，以及以前不支持的编码功能去开发复杂的大型应用，从而提高代码的可读性和可维护性。此外，TypeScript 还"><meta property=og:type content=article><meta property=og:title content="TypeScript 高级特性"><meta property=og:url content=http://www.kingmui.cn/2023/03/01/TypeScript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/index.html><meta property=og:site_name content="King Mui"><meta property=og:description content="前言TypeScript 是由安德斯·海尔斯伯格（Anders Hejlsberg）在微软开发的严格超集语言，是 JavaScript 的一个强类型版本。任何 JavaScript 中的特性都可以在 TypeScript 中使用，这也就意味着我们可以运用已熟知的 JavaScript 技能，以及以前不支持的编码功能去开发复杂的大型应用，从而提高代码的可读性和可维护性。此外，TypeScript 还"><meta property=og:locale content=zh_CN><meta property=article:published_time content=2023-03-01T15:06:49.000Z><meta property=article:modified_time content=2023-04-22T15:40:31.446Z><meta property=article:author content="King Mui"><meta property=article:tag content=TypeScript><meta name=twitter:card content=summary><link rel=canonical href=http://www.kingmui.cn/2023/03/01/TypeScript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/ ><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.kingmui.cn/2023/03/01/TypeScript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/","path":"2023/03/01/TypeScript高级特性/","title":"TypeScript 高级特性"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>TypeScript 高级特性 | King Mui</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-116303188-1"></script><script class=next-config data-name=google_analytics type=application/json>{"tracking_id":"UA-116303188-1","only_pageview":false}</script><script src=/js/third-party/analytics/google-analytics.js></script><script src=/js/third-party/analytics/baidu-analytics.js></script><script async src=https://hm.baidu.com/hm.js?65b6c252e87243b9ea8427abb6b8cf3e></script><noscript><link rel=stylesheet href=/css/noscript.css></noscript><link rel=alternate href=/atom.xml title="King Mui" type=application/atom+xml></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><p class=site-title>King Mui</p><i class=logo-line></i></a><p class=site-subtitle itemprop=description>用艺术的眼光发现技术的美</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-rss"><a href=/atom.xml rel=section><i class="fa fa-rss fa-fw"></i>RSS</a></li><li class="menu-item menu-item-search"><a role=button class=popup-trigger><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%89%8D%E8%A8%80><span class=nav-number>1.</span> <span class=nav-text>前言</span></a></li><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TypeScript><span class=nav-number>2.</span> <span class=nav-text>为什么需要 TypeScript</span></a></li><li class="nav-item nav-level-1"><a class=nav-link href=#TypeScript-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7><span class=nav-number>3.</span> <span class=nav-text>TypeScript 的高级特性</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%93%8D%E4%BD%9C%E7%AC%A6><span class=nav-number>3.1.</span> <span class=nav-text>操作符</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E6%8A%A4><span class=nav-number>3.1.1.</span> <span class=nav-text>类型保护</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#typeof><span class=nav-number>3.1.2.</span> <span class=nav-text>typeof</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#instanceof><span class=nav-number>3.1.3.</span> <span class=nav-text>instanceof</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#keyof-%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2><span class=nav-number>3.1.4.</span> <span class=nav-text>keyof 索引类型查询</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#T-K-%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE><span class=nav-number>3.1.5.</span> <span class=nav-text>T[K] 索引访问</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#in><span class=nav-number>3.1.6.</span> <span class=nav-text>in</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#extends-%E7%BB%A7%E6%89%BF><span class=nav-number>3.1.7.</span> <span class=nav-text>extends 继承</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#as-%E6%96%AD%E8%A8%80><span class=nav-number>3.1.8.</span> <span class=nav-text>as 断言</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#infer-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD><span class=nav-number>3.1.9.</span> <span class=nav-text>infer 类型推断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B><span class=nav-number>3.2.</span> <span class=nav-text>高级类型</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%88Index-types%EF%BC%89><span class=nav-number>3.2.1.</span> <span class=nav-text>索引类型（Index types）</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B%EF%BC%88Mapped-Types%EF%BC%89><span class=nav-number>3.2.2.</span> <span class=nav-text>映射类型（Mapped Types）</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%88Conditional-Types%EF%BC%89><span class=nav-number>3.2.3.</span> <span class=nav-text>条件类型（Conditional Types）</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%88Template-Literal-Types%EF%BC%89><span class=nav-number>3.2.4.</span> <span class=nav-text>模板字面量类型（Template Literal Types）</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%EF%BC%88Immutable-Types%EF%BC%89><span class=nav-number>3.2.5.</span> <span class=nav-text>不可变类型（Immutable Types）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%EF%BC%88Utility-Types%EF%BC%89><span class=nav-number>3.3.</span> <span class=nav-text>工具类型（Utility Types）</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Required><span class=nav-number>3.3.1.</span> <span class=nav-text>Required</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#Readonly><span class=nav-number>3.3.2.</span> <span class=nav-text>Readonly</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#Record><span class=nav-number>3.3.3.</span> <span class=nav-text>Record</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#Exclude><span class=nav-number>3.3.4.</span> <span class=nav-text>Exclude</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#Extract><span class=nav-number>3.3.5.</span> <span class=nav-text>Extract</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#Pick><span class=nav-number>3.3.6.</span> <span class=nav-text>Pick</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#Omit><span class=nav-number>3.3.7.</span> <span class=nav-text>Omit</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#Partial><span class=nav-number>3.3.8.</span> <span class=nav-text>Partial</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#ReturnType><span class=nav-number>3.3.9.</span> <span class=nav-text>ReturnType</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%9C%A8-React-%E4%B8%AD%E4%BD%BF%E7%94%A8-TypeScript><span class=nav-number>4.</span> <span class=nav-text>在 React 中使用 TypeScript</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6-Props-%E7%B1%BB%E5%9E%8B><span class=nav-number>4.1.</span> <span class=nav-text>定义组件 Props 类型</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%A7%BB%E9%99%A4-children-%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89><span class=nav-number>4.2.</span> <span class=nav-text>移除 children 类型定义</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B8%B8%E8%A7%81%E7%9A%84-Hooks-%E7%B1%BB%E5%9E%8B><span class=nav-number>4.3.</span> <span class=nav-text>常见的 Hooks 类型</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#useState><span class=nav-number>4.3.1.</span> <span class=nav-text>useState</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#useMemo><span class=nav-number>4.3.2.</span> <span class=nav-text>useMemo</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#useCallback><span class=nav-number>4.3.3.</span> <span class=nav-text>useCallback</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#useRef><span class=nav-number>4.3.4.</span> <span class=nav-text>useRef</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%80%BB%E7%BB%93><span class=nav-number>5.</span> <span class=nav-text>总结</span></a></li><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5><span class=nav-number>6.</span> <span class=nav-text>参考链接</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt="King Mui" src=https://cdn.kingmui.cn/avatar.jpg><p class=site-author-name itemprop=name>King Mui</p><div class=site-description itemprop=description>生命不息，学习不止</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/ ><span class=site-state-item-count>27</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/ ><span class=site-state-item-count>18</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpbmdtdWk=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kingmui"><i class="fab fa-github-alt fa-fw"></i></span></span><span class=links-of-author-item><span class=exturl data-url=bWFpbHRvOmtpbmdtdWkuZGV2QG91dGxvb2suY29t title="E-Mail → mailto:kingmui.dev@outlook.com"><i class="fa fa-envelope fa-fw"></i></span></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cHM6Ly9vdmVycmVhY3RlZC5pby8=" title=https:&#x2F;&#x2F;overreacted.io&#x2F;>Dan Abramov</span></li><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cHM6Ly9qYWtlYXJjaGliYWxkLmNvbS8=" title=https:&#x2F;&#x2F;jakearchibald.com&#x2F;>Jake Archibald</span></li><li class=links-of-blogroll-item><span class=exturl data-url=aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20v title=https:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;>阮一峰</span></li><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cHM6Ly9naXRodWIuY29tL21xeXFpbmdmZW5nL0Jsb2c=" title=https:&#x2F;&#x2F;github.com&#x2F;mqyqingfeng&#x2F;Blog>冴羽</span></li></ul></div></div></div><div class="back-to-top animated" role=button aria-label=返回顶部><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class=sidebar-dimmer></div></header><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang=zh-CN><link itemprop=mainEntityOfPage href=http://www.kingmui.cn/2023/03/01/TypeScript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=https://cdn.kingmui.cn/avatar.jpg><meta itemprop=name content="King Mui"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="King Mui"><meta itemprop=description content=生命不息，学习不止></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="TypeScript 高级特性 | King Mui"><meta itemprop=description content></span><header class=post-header><h1 class=post-title itemprop="name headline">TypeScript 高级特性</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span> <span class=post-meta-item-text>发表于</span> <time title="创建时间：2023-03-01 23:06:49" itemprop="dateCreated datePublished" datetime=2023-03-01T23:06:49+08:00>2023-03-01</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i></span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-04-22 23:40:31" itemprop=dateModified datetime=2023-04-22T23:40:31+08:00>2023-04-22</time></span><span class=post-meta-item title=阅读次数 id=busuanzi_container_page_pv><span class=post-meta-item-icon><i class="far fa-eye"></i></span> <span class=post-meta-item-text>阅读次数：</span><span id=busuanzi_value_page_pv></span></span><span class=post-meta-break></span><span class=post-meta-item title=本文字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span> <span class=post-meta-item-text>本文字数：</span> <span>20k</span></span><span class=post-meta-item title=阅读时长><span class=post-meta-item-icon><i class="far fa-clock"></i></span> <span class=post-meta-item-text>阅读时长 &asymp;</span> <span>18 分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=前言><a href=#前言 class=headerlink title=前言></a>前言</h1><p>TypeScript 是由<span class=exturl data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQW5kZXJzX0hlamxzYmVyZw==">安德斯·海尔斯伯格<i class="fa fa-external-link-alt"></i></span>（Anders Hejlsberg）在微软开发的严格超集语言，是 JavaScript 的一个强类型版本。任何 JavaScript 中的特性都可以在 TypeScript 中使用，这也就意味着我们可以运用已熟知的 JavaScript 技能，以及以前不支持的编码功能去开发复杂的大型应用，从而提高代码的可读性和可维护性。此外，TypeScript 还提供了诸如类型推断、联合类型、类型保护和泛型等高级特性，以便我们可以更好地处理日趋复杂的代码库。</p><h1 id=为什么需要-TypeScript><a href=#为什么需要-TypeScript class=headerlink title="为什么需要 TypeScript"></a>为什么需要 TypeScript</h1><p>TypeScript 为 JavaScript 添加了类型系统的支持。使用 TypeScript 的好处有很多，例如：</p><ul><li>代码即文档</li><li>编译器自动提示</li><li>一定程度上能够避免低级 bug</li><li>代码的可维护性更强</li></ul><p>TypeScript 可以让我们在编写 JavaScript 代码时拥有更好的代码质量和更强的编译时错误检查。在开发阶段能够帮助我们更快速、更精准地定位问题，以降低代码在运行时才能引发错误的风险。并且在开发大型项目时，TypeScript 的类型系统可以帮助我们更好地组织代码，使团队成员能够更快地了解项目。</p><h1 id=TypeScript-的高级特性><a href=#TypeScript-的高级特性 class=headerlink title="TypeScript 的高级特性"></a>TypeScript 的高级特性</h1><h2 id=操作符><a href=#操作符 class=headerlink title=操作符></a>操作符</h2><p>TypeScript 支持 JavaScript 中的大多数操作符，包括算数、关系、逻辑、位、赋值、条件、类型转换和其他操作符。此外，TypeScript 还提供了一些额外的特殊操作符，如<strong>类型保护</strong>和<strong>断言</strong>操作符。</p><span id=more></span><h3 id=类型保护><a href=#类型保护 class=headerlink title=类型保护></a>类型保护</h3><p>类型保护是一种缩小类型的机制。TypeScript 通过编译时进行类型保护，使得在编写代码时就能发现和修复类型错误。</p><p>类型保护的形式有多种，例如：</p><ol><li>类型断言：使用 <code>as</code> 语法手动指定变量的类型</li><li><code>instanceof</code> 运算符：检查一个变量是否是某个类的实例</li><li><code>typeof</code> 运算符：检查一个变量的类型是否是某个类型</li><li><code>in</code> 运算符：检查一个变量是否是某个对象的属性</li><li>用户自定义的类型保护函数：使用特定的逻辑，检查一个变量是否符合特定的类型</li></ol><h3 id=typeof><a href=#typeof class=headerlink title=typeof></a>typeof</h3><p>TypeScript 和 JavaScript 里面都有 <code>typeof</code> 关键字，二者的作用都差不多。</p><ul><li>在 TypeScript 中，<code>typeof</code> <strong>返回的是一个 TypeScript 类型定义</strong>，即将 JS data 转换成 TS type。它只能对数据进行转换，不能转换 <code>type</code> 和 <code>interface</code>。</li><li>在 JavaScript 中，<code>typeof</code> <strong>返回的是一个字符串</strong>，指示操作数的 JavaScript 类型，即将 JS data 转换成 JS data。</li></ul><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>const</span> organization = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>,</span><br><span class=line>  <span class=attr>age</span>: <span class=number>6</span>,</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> TOrganization = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>interface</span> IOrganization &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>// 以下方式会被认为是 JS 的 typeof</span></span><br><span class=line><span class=keyword>const</span> JsData1 = <span class=keyword>typeof</span> organization; <span class=comment>// const JsData1 = &quot;object&quot;</span></span><br><span class=line><span class=keyword>const</span> JsData2 = <span class=keyword>typeof</span> TOrganization; <span class=comment>// &#x27;TOrganization&#x27; only refers to a type, but is being used as a value here.</span></span><br><span class=line><span class=keyword>const</span> JsData3 = <span class=keyword>typeof</span> IOrganization; <span class=comment>// &#x27;IOrganization&#x27; only refers to a type, but is being used as a value here.</span></span><br><span class=line></span><br><span class=line><span class=comment>// 以下方式会被认为是 TS 的 typeof</span></span><br><span class=line><span class=keyword>type</span> TsType1 = <span class=keyword>typeof</span> organization; <span class=comment>// type TsType1 = &#123;name: string; age: number&#125;</span></span><br><span class=line><span class=keyword>type</span> TsType2 = <span class=keyword>typeof</span> TOrganization; <span class=comment>// &#x27;TOrganization&#x27; only refers to a type, but is being used as a value here.</span></span><br><span class=line><span class=keyword>type</span> TsType3 = <span class=keyword>typeof</span> IOrganization; <span class=comment>// &#x27;IOrganization&#x27; only refers to a type, but is being used as a value here.</span></span><br></pre></td></tr></table></figure><h3 id=instanceof><a href=#instanceof class=headerlink title=instanceof></a>instanceof</h3><p><code>instanceof</code> 可以用于检查对象是否属于特定类。它仅适用于 <code>class</code> 类，不适用于其他 TypeScript 结构，如 <code>interface</code>。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 语法</span></span><br><span class=line>objectVariable <span class=keyword>instanceof</span> ClassName;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Contact</span> </span>&#123;</span><br><span class=line>  <span class=function><span class=title>constructor</span>(<span class=params><span class=keyword>public</span> emailAddress: <span class=built_in>string</span></span>)</span> &#123;&#125;</span><br><span class=line>&#125;</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Person</span> <span class=keyword>extends</span> <span class=title>Contact</span> </span>&#123;</span><br><span class=line>  <span class=function><span class=title>constructor</span>(<span class=params></span></span></span><br><span class=line><span class=params><span class=function>    <span class=keyword>public</span> firstName: <span class=built_in>string</span>,</span></span></span><br><span class=line><span class=params><span class=function>    <span class=keyword>public</span> surname: <span class=built_in>string</span>,</span></span></span><br><span class=line><span class=params><span class=function>    emailAddress: <span class=built_in>string</span></span></span></span><br><span class=line><span class=params><span class=function>  </span>)</span> &#123;</span><br><span class=line>    <span class=built_in>super</span>(emailAddress);</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>sayHello</span>(<span class=params>contact: Contact</span>) </span>&#123;</span><br><span class=line>  <span class=keyword>if</span> (contact <span class=keyword>instanceof</span> Person) &#123;</span><br><span class=line>    <span class=built_in>console</span>.log(<span class=string>&quot;Hello &quot;</span> + contact.firstName);</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=keyof-索引类型查询><a href=#keyof-索引类型查询 class=headerlink title="keyof 索引类型查询"></a>keyof 索引类型查询</h3><p><code>keyof</code> 有时被称为索引查询运算符，因为它查询在它之后指定的类型的所有键的联合类型。换句话说，它将对象类型的所有键作为字符串类型的联合类型返回。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 语法</span></span><br><span class=line>keyof T</span><br></pre></td></tr></table></figure><p>结果为泛型 <code>T</code> 上已知的公共属性名的联合类型。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> User &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> UserKeys = keyof User;</span><br><span class=line><span class=comment>// 等价于</span></span><br><span class=line><span class=comment>// type UserKeys = &quot;name&quot; | &quot;age&quot;</span></span><br></pre></td></tr></table></figure><h3 id=T-K-索引访问><a href=#T-K-索引访问 class=headerlink title="T[K] 索引访问"></a>T[K] 索引访问</h3><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 语法</span></span><br><span class=line>T[K]</span><br></pre></td></tr></table></figure><p>结果为泛型 <code>T</code> 上 <code>K</code> 属性的值类型。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>function</span> <span class=title>getProperty</span>&lt;<span class=title>T</span>, <span class=title>K</span> <span class=title>extends</span> <span class=title>keyof</span> <span class=title>T</span>&gt;(<span class=params>obj: T, key: K</span>): <span class=title>T</span>[<span class=title>K</span>] </span>&#123;</span><br><span class=line>  <span class=keyword>return</span> obj[key]; <span class=comment>// obj[key] 的类型是 T[K]</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，我们使用泛型定义了入参 <code>obj: T</code> 和 <code>key: K</code>，此时有 <code>obj[key]: T[K]</code>。当我们返回 <code>obj[key]</code>，编译器会实例化 <code>obj[key]</code> 的真实类型，因此返回值类型可以随着属性值类型的改变而改变。</p><h3 id=in><a href=#in class=headerlink title=in></a>in</h3><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 语法</span></span><br><span class=line>propertyName <span class=keyword>in</span> objectVariable;</span><br></pre></td></tr></table></figure><p><code>in</code> 关键字在 TypeScript 中有两层含义，第一层含义与 JavaScript 一致，用于检查属性是否属于特定对象。TypeScript 编译器使用 <code>in</code> 表达式来收窄表达式中变量的类型。其返回值取决于 <code>propertyName</code> 属性是否属于 <code>objectVariable</code> 对象。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> A &#123;</span><br><span class=line>  <span class=attr>x</span>: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line><span class=keyword>interface</span> B &#123;</span><br><span class=line>  <span class=attr>y</span>: <span class=built_in>string</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>let</span> q: A | B = ...;</span><br><span class=line><span class=keyword>if</span> (<span class=string>&#x27;x&#x27;</span> <span class=keyword>in</span> q) &#123;</span><br><span class=line>  <span class=comment>// q: A</span></span><br><span class=line>&#125; <span class=keyword>else</span> &#123;</span><br><span class=line>  <span class=comment>// q: B</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>此外，<code>in</code> 在 TypeScript 中的另一层含义是在<strong>映射类型</strong>（Mapped Types）中，<code>in</code> 关键字用作语法的一部分，用于遍历枚举类型。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> Person &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> Partial&lt;T&gt; = &#123;</span><br><span class=line>  [P <span class=keyword>in</span> keyof T]?: T[P]; <span class=comment>// P 是泛型 T 中的任意属性</span></span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> PersonPartial = Partial&lt;Person&gt;;</span><br><span class=line><span class=comment>// 等价于</span></span><br><span class=line><span class=comment>// type PersonPartial = &#123; name?: string;  age?: number; &#125;</span></span><br></pre></td></tr></table></figure><h3 id=extends-继承><a href=#extends-继承 class=headerlink title="extends 继承"></a>extends 继承</h3><p><code>extends</code> 用于定义泛型类型或接口。它表示泛型类型或接口必须继承指定的类型，并受其约束。</p><p>在 TypeScript 中，<code>extends</code> 主要有三种使用场景：</p><ul><li>类型继承，类型 A 继承类型 B（<code>interface</code> 可用 <code>extends</code> 继承，<code>type</code> 不可以）</li><li>定义范型，约束范型必须与目标类型相匹配</li><li>条件匹配，判断类型 A 是否匹配类型 B</li></ul><p>当我们在定义接口类型时，可以为多个接口提取其可复用部分作为基础类型定义，然后通过<strong>类型继承</strong>来派生出其他子类型，例如：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> T1 &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>interface</span> T2 &#123;</span><br><span class=line>  <span class=attr>location</span>: <span class=built_in>string</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>// 多重继承用逗号隔开</span></span><br><span class=line><span class=keyword>interface</span> T3 <span class=keyword>extends</span> T1, T2 &#123;</span><br><span class=line>  <span class=attr>age</span>: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>// 合法</span></span><br><span class=line><span class=keyword>const</span> t3: T3 = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>,</span><br><span class=line>  <span class=attr>location</span>: <span class=string>&#x27;Hangzhou&#x27;</span>,</span><br><span class=line>  <span class=attr>age</span>: <span class=number>6</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>在定义接口泛型时，如果想要约束这个泛型的有效范围，则可以使用 <code>extends</code> 来定义<strong>范型约束</strong>，我们还可以为其指定默认值。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line><span class=built_in>enum</span> LANGUAGE &#123;</span><br><span class=line>  JAVA,</span><br><span class=line>  GO,</span><br><span class=line>  JAVASCRIPT,</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>// 约束范型 T 的类型并且指定默认值</span></span><br><span class=line><span class=keyword>interface</span> IProgrammer&lt;T <span class=keyword>extends</span> LANGUAGE = LANGUAGE.JAVASCRIPT&gt; &#123;</span><br><span class=line>  <span class=attr>language</span>: T;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>条件匹配是一种利用条件表达式进行类型的关系检测，我们将在下文详细讨论。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 判断范型 T 是否匹配 number</span></span><br><span class=line><span class=keyword>type</span> TNumber&lt;T&gt; = T <span class=keyword>extends</span> <span class=built_in>number</span> ? <span class=built_in>any</span> : <span class=built_in>never</span>;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> T1 = TNumber&lt;<span class=built_in>number</span>&gt;; <span class=comment>// type T1 = any</span></span><br><span class=line><span class=keyword>type</span> T2 = TNumber&lt;<span class=built_in>string</span>&gt;; <span class=comment>// type T2 = never</span></span><br></pre></td></tr></table></figure><h3 id=as-断言><a href=#as-断言 class=headerlink title="as 断言"></a>as 断言</h3><p><code>as</code> 关键字是一个类型断言运算符，用于将一个值的类型强制转换为另一种类型。这意味着，即使编译器检测到的变量类型与我们预期的类型不匹配，也可以使用类型断言将其转换为正确的类型。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>let</span> someValue: <span class=built_in>any</span> = <span class=string>&quot;Hello&quot;</span>;</span><br><span class=line><span class=keyword>let</span> strLength = (someValue <span class=keyword>as</span> <span class=built_in>string</span>).length;</span><br></pre></td></tr></table></figure><p>上述例子中，我们显式将 <code>someValue</code> 指定为 <code>any</code> 类型，此时 <code>strLength</code> 为 <code>any</code> 类型，因为无法从一个 <code>any</code> 类型的值中推断出 <code>length</code> 属性的类型。当我们通过类型断言将 <code>someValue</code> 转换为 <code>string</code> 类型后，<code>strLength</code> 将能得到正确的 <code>number</code> 类型。</p><p>TypeScript 还有一个<strong>非空断言运算符</strong>（<code>!</code>）用于断言一个变量非空，它位于我们想要告诉 TypeScript 不是 <code>null</code> 或 <code>undefined</code> 的变量或表达式之后。非空断言运算符是避免代码中不必要的 <code>null</code> 和 <code>undefined</code> 检查的简洁方法。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>function</span> <span class=title>duplicate</span>(<span class=params>text: <span class=built_in>string</span> | <span class=literal>null</span></span>) </span>&#123;</span><br><span class=line>  <span class=comment>// if (text === null || text === undefined) &#123;</span></span><br><span class=line>  <span class=comment>//   text = &quot;&quot;;</span></span><br><span class=line>  <span class=comment>// &#125;</span></span><br><span class=line>  <span class=comment>// return text.concat(text);</span></span><br><span class=line></span><br><span class=line>  <span class=comment>// 使用非空断言运算符简写代码</span></span><br><span class=line>  <span class=keyword>return</span> text!.concat(text!);</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=infer-类型推断><a href=#infer-类型推断 class=headerlink title="infer 类型推断"></a>infer 类型推断</h3><p><code>infer</code> 关键字是 TypeScript 中的一个特殊类型，表示在 <code>extends</code> 条件语句中待推断的类型变量。它允许我们在声明一个类型变量时，从其他类型中推断出这个变量的类型。使用 <code>infer</code> 关键字可以使 TypeScript 更加灵活，并改善类型推断的表现。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> T1&lt;T&gt; = T <span class=keyword>extends</span> (infer U)[] ? U : T;</span><br></pre></td></tr></table></figure><p>上述示例中，我们通过推断传入的类型是否是数组，如果是数组，则返回数组中推断的元素类型 <code>U</code>，否则返回 <code>T</code>。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> ParamType&lt;T&gt; = T <span class=keyword>extends</span> (...args: infer P) =&gt; <span class=built_in>any</span> ? P : T;</span><br></pre></td></tr></table></figure><p>上述代码表示：如果 <code>T</code> 能赋值给 <code>(...args: infer P) =&gt; any</code>，则结果是 <code>(...args: infer P) =&gt; any</code> 类型中的参数 <code>P</code>，否则返回 <code>T</code>。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> User &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> Func = <span class=function>(<span class=params>user: User</span>) =&gt;</span> <span class=built_in>void</span>;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> Type1 = ParamType&lt;Func&gt;;</span><br><span class=line><span class=comment>// 等同于</span></span><br><span class=line><span class=comment>// type Type1 = User</span></span><br><span class=line></span><br><span class=line><span class=keyword>type</span> Type2 = ParamType&lt;<span class=built_in>string</span>&gt;;</span><br><span class=line><span class=comment>// 等同于</span></span><br><span class=line><span class=comment>// type Type2 = string</span></span><br></pre></td></tr></table></figure><h2 id=高级类型><a href=#高级类型 class=headerlink title=高级类型></a>高级类型</h2><h3 id=索引类型（Index-types）><a href=#索引类型（Index-types） class=headerlink title="索引类型（Index types）"></a>索引类型（Index types）</h3><p>当我们从对象中获取一些属性的值时，索引类型能够帮助我们检查使用了动态属性名的代码。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>const</span> organization = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>,</span><br><span class=line>  <span class=attr>age</span>: <span class=number>6</span>,</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>getValues</span>(<span class=params>organization: <span class=built_in>any</span>, keys: <span class=built_in>string</span>[]</span>) </span>&#123;</span><br><span class=line>  <span class=keyword>return</span> keys.map(<span class=function><span class=params>key</span> =&gt;</span> organization[key]);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>getValues(organization, [<span class=string>&#x27;name&#x27;</span>, <span class=string>&#x27;age&#x27;</span>]); <span class=comment>// [&#x27;zcy&#x27;, 6]</span></span><br><span class=line>getValues(organization, [<span class=string>&#x27;location&#x27;</span>]); <span class=comment>// [undefined]</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>getValues(organization, [&#39;location&#39;])</code> 输出 <code>[undefined]</code>，TypeScript 编译器并没有给出错误提示。接下来我们运用前一章节操作符中学到的<strong>索引类型查询</strong>（<code>keyof</code>）和<strong>索引访问</strong>（<code>T[K]</code>）操作符来纠正类型约束。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> IOrganization &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> organization: IOrganization = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>,</span><br><span class=line>  <span class=attr>age</span>: <span class=number>6</span>,</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>getValues</span>&lt;<span class=title>T</span>, <span class=title>K</span> <span class=title>extends</span> <span class=title>keyof</span> <span class=title>T</span>&gt;(<span class=params>organization: T, keys: K[]</span>): <span class=title>T</span>[<span class=title>K</span>][] </span>&#123;</span><br><span class=line>  <span class=keyword>return</span> keys.map(<span class=function><span class=params>key</span> =&gt;</span> organization[key]);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>// [&#x27;zcy&#x27;, 6]</span></span><br><span class=line>getValues(organization, [<span class=string>&#x27;name&#x27;</span>, <span class=string>&#x27;age&#x27;</span>]);</span><br><span class=line></span><br><span class=line><span class=comment>// Type &#x27;&quot;location&quot;&#x27; is not assignable to type &#x27;keyof IOrganization&#x27;.</span></span><br><span class=line>getValues(organization, [<span class=string>&#x27;location&#x27;</span>]);</span><br></pre></td></tr></table></figure><h3 id=映射类型（Mapped-Types）><a href=#映射类型（Mapped-Types） class=headerlink title="映射类型（Mapped Types）"></a>映射类型（<strong>Mapped Types</strong>）</h3><p>有时候我们希望能从现有类型派生出新的类型。映射类型就是 TypeScript 为我们提供的基于现有类型创建新类型的一种方式，新类型会以相同的形式去转换旧类型中的每个属性。</p><p>在使用映射类型时，我们可以应用两个附加的修饰符 <code>readonly</code> 和 <code>?</code> 来分别影响属性的可变性和可选性。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Make all properties in T readonly</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Readonly&lt;T&gt; = &#123;</span><br><span class=line>  <span class=keyword>readonly</span> [P <span class=keyword>in</span> keyof T]: T[P];</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment>* Make all properties in T optional</span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line><span class=keyword>type</span> Partial&lt;T&gt; = &#123;</span><br><span class=line>  [P <span class=keyword>in</span> keyof T]?: T[P];</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br><span class=line><span class=keyword>type</span> PersonPartial = Partial&lt;Person&gt;;</span><br></pre></td></tr></table></figure><p>我们可以通过添加 <code>-</code> 或 <code>+</code> 前缀来<strong>删除</strong>或<strong>添加</strong>这些修饰符。若没有显式指定前缀，则默认为 <code>+</code>。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 为 TOrganization 类型移除 readonly 修饰符</span></span><br><span class=line><span class=keyword>type</span> Mutable&lt;T&gt; = &#123;</span><br><span class=line>  -<span class=keyword>readonly</span> [P <span class=keyword>in</span> keyof T]: T[P];</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> TOrganization = &#123;</span><br><span class=line>  <span class=keyword>readonly</span> name: <span class=built_in>string</span>;</span><br><span class=line>  <span class=keyword>readonly</span> age: <span class=built_in>number</span>;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> UnlockedOrganization = Mutable&lt;TOrganization&gt;;</span><br><span class=line><span class=comment>// 等价于</span></span><br><span class=line><span class=comment>// type UnlockedOrganization = &#123;</span></span><br><span class=line><span class=comment>//   name: string;</span></span><br><span class=line><span class=comment>//   age: number;</span></span><br><span class=line><span class=comment>// &#125;;</span></span><br><span class=line></span><br><span class=line><span class=comment>// 为 MaybeOrganization 类型移除 ? 修饰符</span></span><br><span class=line><span class=keyword>type</span> Concrete&lt;T&gt; = &#123;</span><br><span class=line>  [P <span class=keyword>in</span> keyof T]-?: T[P];</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> MaybeOrganization = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age?: <span class=built_in>number</span>;</span><br><span class=line>  location?: <span class=built_in>string</span>;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> Organization = Concrete&lt;MaybeOrganization&gt;;</span><br><span class=line><span class=comment>// 等价于</span></span><br><span class=line><span class=comment>// type Organization = &#123;</span></span><br><span class=line><span class=comment>//   name: string;</span></span><br><span class=line><span class=comment>//   age: string;</span></span><br><span class=line><span class=comment>//   location: number;</span></span><br><span class=line><span class=comment>// &#125;;</span></span><br></pre></td></tr></table></figure><p>此外，我们还可以利用 <code>as</code> 为生成的键名重新映射。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> Getters&lt;T&gt; = &#123;</span><br><span class=line>  <span class=comment>// 模板字面量类型后文会提及</span></span><br><span class=line>  [P <span class=keyword>in</span> keyof T <span class=keyword>as</span> <span class=string>`get<span class=subst>$&#123;Capitalize&lt;<span class=built_in>string</span> &amp; P&gt;&#125;</span>`</span>]: <span class=function>() =&gt;</span> T[P]</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>interface</span> IOrganization &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>  location: <span class=built_in>string</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> LazyOrganization = Getters&lt;IOrganization&gt;;</span><br><span class=line></span><br><span class=line><span class=comment>// type LazyOrganization = &#123;</span></span><br><span class=line><span class=comment>//   getName: () =&gt; string;</span></span><br><span class=line><span class=comment>//   getAge: () =&gt; number;</span></span><br><span class=line><span class=comment>//   getLocation: () =&gt; string;</span></span><br><span class=line><span class=comment>// &#125;</span></span><br></pre></td></tr></table></figure><h3 id=条件类型（Conditional-Types）><a href=#条件类型（Conditional-Types） class=headerlink title="条件类型（Conditional Types）"></a>条件类型（<strong>Conditional Types</strong>）</h3><p>条件类型是 TypeScript 中非常强大的工具，是一种在编译时执行的特殊类型，可以让我们在编写代码时根据特定条件来确定类型，以灵活地处理复杂的类型问题。</p><p>条件类型看起来有点类似于 JavaScript 中的条件表达式，语法如下：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>SomeType <span class=keyword>extends</span> OtherType ? TrueType : FalseType</span><br></pre></td></tr></table></figure><ul><li><code>SomeType</code> 和 <code>OtherType</code> 是比较的类型</li><li>如果 <code>SomeType</code> 可以赋值给 <code>OtherType</code>，则类型为 <code>TrueType</code></li><li>如果 <code>SomeType</code> 无法赋值给 <code>OtherType</code>，则类型为 <code>FalseType</code></li></ul><p>条件类型可以用于创建动态类型。例如：</p><p>1、创建具有多种可能类型的对象</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> Options = &#123;</span><br><span class=line>  <span class=attr>color</span>: <span class=string>&#x27;red&#x27;</span> | <span class=string>&#x27;green&#x27;</span> | <span class=string>&#x27;blue&#x27;</span>;</span><br><span class=line>  size: <span class=string>&#x27;small&#x27;</span> | <span class=string>&#x27;medium&#x27;</span> | <span class=string>&#x27;large&#x27;</span>;</span><br><span class=line>  colors: <span class=built_in>string</span>[];</span><br><span class=line>  price: <span class=built_in>number</span>;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> Item = &#123;</span><br><span class=line>  [K <span class=keyword>in</span> keyof Options]: Options[K] <span class=keyword>extends</span> <span class=built_in>string</span> ? K : <span class=built_in>never</span>;</span><br><span class=line>&#125;[keyof Options];</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> item: Item = <span class=string>&#x27;color&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在上述例子中，我们通过条件类型筛选出了 <code>Options</code> 中所有值类型为 <code>string</code> 的属性所组成的联合类型 <code>Item</code>。</p><p>2、创建只有满足特定条件的类型的类</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>DataStore</span>&lt;<span class=title>T</span>&gt; </span>&#123;</span><br><span class=line>  <span class=keyword>private</span> data: T;</span><br><span class=line></span><br><span class=line>  <span class=function><span class=title>constructor</span>(<span class=params>data: T</span>)</span> &#123;</span><br><span class=line>    <span class=built_in>this</span>.data = data;</span><br><span class=line>  &#125;</span><br><span class=line></span><br><span class=line>  getData&lt;K <span class=keyword>extends</span> keyof T&gt;(key: K): T[K] &#123;</span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>this</span>.data[key];</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> store = <span class=keyword>new</span> DataStore(&#123; <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>, <span class=attr>age</span>: <span class=number>6</span> &#125;);</span><br><span class=line><span class=keyword>const</span> name = store.getData(<span class=string>&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id=模板字面量类型（Template-Literal-Types）><a href=#模板字面量类型（Template-Literal-Types） class=headerlink title="模板字面量类型（Template Literal Types）"></a><strong><strong>模板字面量类型（Template Literal Types）</strong></strong></h3><p>模板字面量类型是一种特殊的类型，用于在运行时生成字符串值。它们使用反引号 ``` 括起来，并且允许在字符串中嵌入表达式，跟 JavaScript 的模板字符串是相同的语法，但是只能用在类型操作中。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> World = <span class=string>&quot;world&quot;</span>;</span><br><span class=line> </span><br><span class=line><span class=keyword>type</span> Greeting = <span class=string>`hello <span class=subst>$&#123;World&#125;</span>`</span>;</span><br><span class=line><span class=comment>// 等价于</span></span><br><span class=line><span class=comment>// type Greeting = &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>为了帮助进行字符串操作，TypeScript 内置了一组可用于操纵字符串的类型，这些类型出于性能的考虑被内置在编译器中，无法在 <code>.d.ts</code> 文件中找到。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Convert string literal type to uppercase</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Uppercase&lt;S <span class=keyword>extends</span> <span class=built_in>string</span>&gt; = intrinsic;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Convert string literal type to lowercase</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Lowercase&lt;S <span class=keyword>extends</span> <span class=built_in>string</span>&gt; = intrinsic;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Convert first character of string literal type to uppercase</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Capitalize&lt;S <span class=keyword>extends</span> <span class=built_in>string</span>&gt; = intrinsic;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Convert first character of string literal type to lowercase</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Uncapitalize&lt;S <span class=keyword>extends</span> <span class=built_in>string</span>&gt; = intrinsic;</span><br></pre></td></tr></table></figure><p>从 TypeScript 4.1 开始，存在 4 种内置类型：<code>Uppercase</code>、<code>Lowercase</code>、<code>Capitalize</code> 和 <code>Uncapitalize</code>，它们都是使用关键字 <code>intrinsic</code> 定义的。<code>intrinsic</code>（adj. 固有的; 内在的; 本身的;）是 TypeScript 引入的一个关键字，就如同它的含义一样，是 TypeScript 内置的。它们的共同特点是生成的类型涉及到了值的转换，而不是类型的转换，这在 TypeScript 中通过已有的类型书写方式是无法表达的，所以 TypeScript 只能通过内置关键字在编译期实现。这些内置函数会直接使用 JavaScript 字符串运行时函数，而不是本地化识别。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>const</span> <span class=built_in>enum</span> IntrinsicTypeKind &#123;</span><br><span class=line>  Uppercase,</span><br><span class=line>  Lowercase,</span><br><span class=line>  Capitalize,</span><br><span class=line>  Uncapitalize</span><br><span class=line>&#125;</span><br><span class=line><span class=keyword>const</span> intrinsicTypeKinds: ReadonlyMap&lt;<span class=built_in>string</span>, IntrinsicTypeKind&gt; = <span class=keyword>new</span> <span class=built_in>Map</span>(<span class=built_in>Object</span>.entries(&#123;</span><br><span class=line>  <span class=attr>Uppercase</span>: IntrinsicTypeKind.Uppercase,</span><br><span class=line>  <span class=attr>Lowercase</span>: IntrinsicTypeKind.Lowercase,</span><br><span class=line>  <span class=attr>Capitalize</span>: IntrinsicTypeKind.Capitalize,</span><br><span class=line>  <span class=attr>Uncapitalize</span>: IntrinsicTypeKind.Uncapitalize</span><br><span class=line>&#125;));</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>applyStringMapping</span>(<span class=params>symbol: <span class=built_in>Symbol</span>, str: <span class=built_in>string</span></span>) </span>&#123;</span><br><span class=line>  <span class=keyword>switch</span> (intrinsicTypeKinds.get(symbol.escapedName <span class=keyword>as</span> <span class=built_in>string</span>)) &#123;</span><br><span class=line>      <span class=keyword>case</span> IntrinsicTypeKind.Uppercase: <span class=keyword>return</span> str.toUpperCase();</span><br><span class=line>      <span class=keyword>case</span> IntrinsicTypeKind.Lowercase: <span class=keyword>return</span> str.toLowerCase();</span><br><span class=line>      <span class=keyword>case</span> IntrinsicTypeKind.Capitalize: <span class=keyword>return</span> str.charAt(<span class=number>0</span>).toUpperCase() + str.slice(<span class=number>1</span>);</span><br><span class=line>      <span class=keyword>case</span> IntrinsicTypeKind.Uncapitalize: <span class=keyword>return</span> str.charAt(<span class=number>0</span>).toLowerCase() + str.slice(<span class=number>1</span>);</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=keyword>return</span> str;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>你可以在<span class=exturl data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L21haW4vc3JjL2NvbXBpbGVyL2NoZWNrZXIudHM=">此处<i class="fa fa-external-link-alt"></i></span>找到上述编译器源码的定义。</p><h3 id=不可变类型（Immutable-Types）><a href=#不可变类型（Immutable-Types） class=headerlink title="不可变类型（Immutable Types）"></a>不可变类型（Immutable Types）</h3><p>不可变类型是指一旦创建了该类型的值，就不能对其进行修改，这有助于防止由于意外副作用导致的错误。可以通过使用 <code>const</code> 和 <code>readonly</code> 关键字来实现。</p><p><code>const</code> 断言是一种类型断言。使用 <code>const</code> 断言将导致 TypeScript 根据值结构为变量提供不可变类型。对于对象，<code>readonly</code> 修饰符以递归的方式应用于所有嵌套属性。<code>const</code> 断言是一种使对象或数组在编译时深度不可变的简便方法。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>let</span> variableName = someValue <span class=keyword>as</span> <span class=keyword>const</span>;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> bill = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=string>&quot;Bill&quot;</span>,</span><br><span class=line>  <span class=attr>profile</span>: &#123;</span><br><span class=line>    <span class=attr>level</span>: <span class=number>1</span>,</span><br><span class=line>  &#125;,</span><br><span class=line>  <span class=attr>scores</span>: [<span class=number>90</span>, <span class=number>65</span>, <span class=number>80</span>],</span><br><span class=line>&#125; <span class=keyword>as</span> <span class=keyword>const</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 等价于</span></span><br><span class=line><span class=comment>// const bill = &#123;</span></span><br><span class=line><span class=comment>//   readonly name: &quot;Bill&quot;;</span></span><br><span class=line><span class=comment>//   readonly profile: &#123;</span></span><br><span class=line><span class=comment>//     readonly level: 1;</span></span><br><span class=line><span class=comment>//   &#125;;</span></span><br><span class=line><span class=comment>//   readonly scores: readonly [90, 65, 80];</span></span><br><span class=line><span class=comment>// &#125;</span></span><br><span class=line></span><br><span class=line><span class=comment>// Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br><span class=line>bill.name = <span class=string>&quot;Bob&quot;</span>;</span><br><span class=line><span class=comment>// Cannot assign to &#x27;level&#x27; because it is a read-only property.</span></span><br><span class=line>bill.profile.level = <span class=number>2</span>;</span><br><span class=line><span class=comment>// Property &#x27;push&#x27; does not exist on type &#x27;readonly [90, 65, 80]&#x27;</span></span><br><span class=line>bill.scores.push(<span class=number>100</span>);</span><br></pre></td></tr></table></figure><p><code>readonly</code> 用于声明对象的属性是只读的。这意味着一旦声明了 <code>readonly</code> 修饰符，就不能再对此属性进行赋值。这对于防止意外地修改对象的状态很有用。可以应用于类型别名和接口以及类属性。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> TypeName = &#123;</span><br><span class=line>  <span class=keyword>readonly</span> propertyName: PropertyType;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>interface</span> InterfaceName &#123;</span><br><span class=line>  <span class=keyword>readonly</span> propertyName: PropertyType;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>ClassName</span> </span>&#123;</span><br><span class=line>  <span class=function><span class=title>constructor</span>(<span class=params><span class=keyword>public</span> <span class=keyword>readonly</span> propertyName: PropertyType</span>)</span> &#123;&#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=工具类型（Utility-Types）><a href=#工具类型（Utility-Types） class=headerlink title="工具类型（Utility Types）"></a>工具类型（<strong>Utility Types</strong>）</h2><p>TypeScript 提供了很多内置的工具类型，它们可以帮助我们在编写代码时更有效地处理类型，以减少重复代码。</p><h3 id=Required><a href=#Required class=headerlink title=Required></a>Required</h3><p><code>Required&lt;T&gt;</code> 能将所有类型 <code>T</code> 中的可选属性变成必需的属性。它只适用于可选的属性，如果属性已经是必需的，则不会产生任何影响。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Make all properties in T required</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Required&lt;T&gt; = &#123;</span><br><span class=line>  [P <span class=keyword>in</span> keyof T]-?: T[P];</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><p>上述源码中，我们发现一个很有意思的用法 <code>-?</code>，就是将可选项代表的 <code>?</code> 去掉，从而让这个类型变成必选项。与之对应的还有个 <code>+?</code>，用来把属性变成可选项，<code>+</code> 是默认的前缀。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> IOrganization &#123;</span><br><span class=line>  name?: <span class=built_in>string</span>;</span><br><span class=line>  age?: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> organization: Required&lt;IOrganization&gt; = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>,</span><br><span class=line>  <span class=attr>age</span>: <span class=number>6</span>,</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><p>上述例子中，我们定义了一个 <code>IOrganization</code> 接口，它有两个可选属性：<code>name</code> 和 <code>age</code>。通过使用 <code>Required&lt;IOrganization&gt;</code>，我们能够将它们变成必需的属性。</p><h3 id=Readonly><a href=#Readonly class=headerlink title=Readonly></a>Readonly</h3><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Make all properties in T readonly</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Readonly&lt;T&gt; = &#123;</span><br><span class=line>  <span class=keyword>readonly</span> [P <span class=keyword>in</span> keyof T]: T[P];</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><p><code>Readonly&lt;T&gt;</code> 能将所有类型 <code>T</code> 中的可变属性变成只读属性。它仅对可变的属性有效，如果属性已经是只读的，则不会产生任何影响。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> IOrganization &#123;</span><br><span class=line>  name?: <span class=built_in>string</span>;</span><br><span class=line>  age?: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> organization: Readonly&lt;IOrganization&gt; = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>,</span><br><span class=line>  <span class=attr>age</span>: <span class=number>6</span>,</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line>organization.name = <span class=string>&#x27;lcy&#x27;</span>; <span class=comment>// Error: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure><p>在上述例子中，我们定义了一个 <code>IOrganization</code> 接口，它有两个可变属性：<code>name</code> 和 <code>age</code>。通过使用 <code>Readonly&lt;IOrganization&gt;</code>，我们能够将它们变成只读属性。</p><h3 id=Record><a href=#Record class=headerlink title=Record></a>Record</h3><p><code>Record&lt;K, T&gt;</code> 能够用于创建一个以键为类型的映射表，其中键类型必须是字符串或数字，这是因为它们是唯一的。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Construct a type with a set of properties K of type T</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Record&lt;K <span class=keyword>extends</span> keyof <span class=built_in>any</span>, T&gt; = &#123;</span><br><span class=line>  [P <span class=keyword>in</span> K]: T;</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><p>它会将 <code>K</code> 中所有属性的值转化为 <code>T</code> 类型。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> IOrganization &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> organization: Record&lt;<span class=built_in>string</span>, IOrganization&gt; = &#123;</span><br><span class=line>  <span class=string>&#x27;zc&#x27;</span>: &#123; <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>, <span class=attr>age</span>: <span class=number>6</span> &#125;,</span><br><span class=line>  <span class=string>&#x27;lc&#x27;</span>: &#123; <span class=attr>name</span>: <span class=string>&#x27;lcy&#x27;</span>, <span class=attr>age</span>: <span class=number>1</span> &#125;</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><p>在上述例子中，我们定义了一个 <code>IOrganization</code> 接口，然后使用 <code>Record&lt;string, IOrganization&gt;</code> 创建了一个 <code>organization</code> 对象。它是一个字符串键和 <code>IOrganization</code> 值的映射，能够存储多个组织的信息。</p><h3 id=Exclude><a href=#Exclude class=headerlink title=Exclude></a>Exclude</h3><p>在 TypeScript 2.8 中引入了一个条件类型，示例如下：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line>T <span class=keyword>extends</span> U ? X : Y</span><br></pre></td></tr></table></figure><p>以上语句的意思是如果 <code>T</code> 是 <code>U</code> 的子类型的话，那么就会返回 <code>X</code>，否则返回 <code>Y</code>。</p><p>对于联合类型来说会自动分发条件，例如 <code>T extends U ? X : Y</code>，<code>T</code> 可能是 <code>A | B</code> 的联合类型，那实际情况就变成 <code>(A extends U ? X : Y) | (B extends U ? X : Y)</code> 。</p><p>有了以上的了解我们再来理解下面的工具泛型：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Exclude from T those types that are assignable to U</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Exclude&lt;T, U&gt; = T <span class=keyword>extends</span> U ? <span class=built_in>never</span> : T;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> NumberOrString = <span class=built_in>number</span> | <span class=built_in>string</span>;</span><br><span class=line><span class=keyword>type</span> OnlyNumbers = Exclude&lt;NumberOrString, <span class=built_in>string</span>&gt;;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> onlyNumbers: OnlyNumbers = <span class=number>42</span>;</span><br></pre></td></tr></table></figure><p>根据源码和示例我们可以推断出 <code>Exclude</code> 的作用是从 <code>T</code> 中找出 <code>U</code> 中没有的元素，换种更加贴近语义的说法其实就是从类型 <code>T</code> 中排除类型 <code>U</code> 。</p><h3 id=Extract><a href=#Extract class=headerlink title=Extract></a>Extract</h3><p>源码：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Extract from T those types that are assignable to U</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Extract&lt;T, U&gt; = T <span class=keyword>extends</span> U ? T : <span class=built_in>never</span>;</span><br></pre></td></tr></table></figure><p>如果类型 <code>U</code> 不是类型 <code>T</code> 的子类型，则将导致编译错误。</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> NumberOrString = <span class=built_in>number</span> | <span class=built_in>string</span>;</span><br><span class=line><span class=keyword>type</span> OnlyStrings = Extract&lt;NumberOrString, <span class=built_in>string</span>&gt;;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> onlyStrings: OnlyStrings = <span class=string>&#x27;Hello, world!&#x27;</span>;</span><br></pre></td></tr></table></figure><p>根据源码我们推断出 <code>Extract</code> 的作用是提取出 <code>T</code> 包含在 <code>U</code> 中的元素，换种更加贴近语义的说法就是从类型 <code>T</code> 中提取出类型 <code>U</code> 。</p><h3 id=Pick><a href=#Pick class=headerlink title=Pick></a>Pick</h3><p><code>Pick&lt;T, K&gt;</code> 能够从类型 <code>T</code> 中选择一组键，并创建一个新的类型。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * From T, pick a set of properties whose keys are in the union K</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Pick&lt;T, K <span class=keyword>extends</span> keyof T&gt; = &#123;</span><br><span class=line>  [P <span class=keyword>in</span> K]: T[P];</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><p>它从 <code>T</code> 中取出一系列 <code>K</code> 的属性。其中 <code>K</code> 的属性必须存在于 <code>T</code> 中。<code>K extends keyof T</code> 表示 <code>K</code> 受到 <code>keyof T</code> 的约束，即 <code>K</code> 的属性必须是 <code>keyof T</code> 的子集。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> IOrganization &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>  location: <span class=built_in>string</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> OrganizationInfo = Pick&lt;IOrganization, <span class=string>&#x27;name&#x27;</span> | <span class=string>&#x27;age&#x27;</span>&gt;;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> organization: OrganizationInfo = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>,</span><br><span class=line>  <span class=attr>age</span>: <span class=number>6</span>,</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><h3 id=Omit><a href=#Omit class=headerlink title=Omit></a>Omit</h3><p>用之前的 <code>Pick</code> 和 <code>Exclude</code> 进行组合，实现忽略对象某些属性的功能。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Construct a type with the properties of T except for those in type K.</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Omit&lt;T, K <span class=keyword>extends</span> keyof <span class=built_in>any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure><p>删除的键必须是类型 <code>T</code> 中的属性，否则将导致编译错误。</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> IOrganization &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>  location: <span class=built_in>string</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> OrganizationWithoutLocation = Omit&lt;IOrganization, <span class=string>&#x27;location&#x27;</span>&gt;;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> organizationWithoutLocation: OrganizationWithoutLocation = &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=string>&#x27;zcy&#x27;</span>,</span><br><span class=line>  <span class=attr>age</span>: <span class=number>6</span></span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><h3 id=Partial><a href=#Partial class=headerlink title=Partial></a>Partial</h3><p><code>Partial&lt;T&gt;</code> 能够将类型 <code>T</code> 中的所有属性都变为可选的，并创建一个新的类型。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Make all properties in T optional</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> Partial&lt;T&gt; = &#123;</span><br><span class=line>    [P <span class=keyword>in</span> keyof T]?: T[P];</span><br><span class=line>&#125;;</span><br></pre></td></tr></table></figure><p><code>keyof T</code> 拿到 <code>T</code> 所有属性名，然后 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后 <code>T[P]</code> 取得相应属性的值。</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>interface</span> IOrganization &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>  location: <span class=built_in>string</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> PartialOrganization = Partial&lt;IOrganization&gt;;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> partialOrganization: PartialOrganization = &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id=ReturnType><a href=#ReturnType class=headerlink title=ReturnType></a>ReturnType</h3><p><code>ReturnType&lt;T&gt;</code> 能够从函数类型 <code>T</code> 中提取返回类型，并创建一个新的类型。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Obtain the return type of a function type</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>type</span> ReturnType&lt;T <span class=keyword>extends</span> (...args: <span class=built_in>any</span>) =&gt; <span class=built_in>any</span>&gt; = T <span class=keyword>extends</span> (...args: <span class=built_in>any</span>) =&gt; infer R ? R : <span class=built_in>any</span>;</span><br></pre></td></tr></table></figure><p>试图推断返回值，并返回推断类型或 <code>any</code> 。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>function</span> <span class=title>getName</span>(<span class=params></span>): <span class=title>string</span> </span>&#123;</span><br><span class=line>  <span class=keyword>return</span> <span class=string>&#x27;zcy&#x27;</span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> Name = ReturnType&lt;<span class=keyword>typeof</span> getName&gt;;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> name: Name = <span class=string>&#x27;zcy&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id=在-React-中使用-TypeScript><a href=#在-React-中使用-TypeScript class=headerlink title="在 React 中使用 TypeScript"></a>在 React 中使用 TypeScript</h1><p>在这个部分，我们将探讨下如何在 React 项目中使用 TypeScript。</p><h2 id=定义组件-Props-类型><a href=#定义组件-Props-类型 class=headerlink title="定义组件 Props 类型"></a>定义组件 Props 类型</h2><p>在 React 项目中，最常用的场景是定义组件的 <code>props</code> 类型。通过声明组件的 <code>props</code> 类型，能够为我们带来：</p><ul><li>在消费组件时进行参数合法性校验。不需要查看源码查询支持的 <code>props</code> 参数以及类型</li><li>更好的组件自解释和 IDE 支持</li></ul><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> &#123; FC &#125; <span class=keyword>from</span> <span class=string>&#x27;react&#x27;</span>;</span><br><span class=line></span><br><span class=line><span class=keyword>interface</span> IFunctionComponentProps &#123;</span><br><span class=line>  <span class=attr>name</span>: <span class=built_in>string</span>;</span><br><span class=line>  age: <span class=built_in>number</span>;</span><br><span class=line>	location?: <span class=built_in>string</span>;</span><br><span class=line>&#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> FunctionComponent: FC&lt;IFunctionComponentProps&gt; = <span class=function>(<span class=params>props</span>) =&gt;</span> &#123;</span><br><span class=line>  <span class=keyword>const</span> &#123; name, age, location &#125; = props;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> FunctionComponent;</span><br></pre></td></tr></table></figure><h2 id=移除-children-类型定义><a href=#移除-children-类型定义 class=headerlink title="移除 children 类型定义"></a>移除 <code>children</code> 类型定义</h2><p>在 React 17.x 版本之前，<code>React.FC</code> 和 <code>React.FunctionComponent</code> 为我们隐式定义了 <code>children</code> 属性，即便我们可能并不需要消费 <code>children</code> 这个 prop。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> PropsWithChildren&lt;P&gt; = P &amp; &#123; children?: ReactNode | <span class=literal>undefined</span> &#125;;</span><br><span class=line></span><br><span class=line><span class=keyword>type</span> FC&lt;P = &#123;&#125;&gt; = FunctionComponent&lt;P&gt;;</span><br><span class=line></span><br><span class=line><span class=keyword>interface</span> FunctionComponent&lt;P = &#123;&#125;&gt; &#123;</span><br><span class=line>  (props: PropsWithChildren&lt;P&gt;, context?: <span class=built_in>any</span>): ReactElement&lt;<span class=built_in>any</span>, <span class=built_in>any</span>&gt; | <span class=literal>null</span>;</span><br><span class=line>  propTypes?: WeakValidationMap&lt;P&gt; | <span class=literal>undefined</span>;</span><br><span class=line>  contextTypes?: ValidationMap&lt;<span class=built_in>any</span>&gt; | <span class=literal>undefined</span>;</span><br><span class=line>  defaultProps?: Partial&lt;P&gt; | <span class=literal>undefined</span>;</span><br><span class=line>  displayName?: <span class=built_in>string</span> | <span class=literal>undefined</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>当我们升级到 React 18.x 版本后，旧项目在使用 <code>React.FC</code> 定义的组件中将得到 <code>Property &#39;children&#39; does not exist on type &#39;IXXXProps&#39;.</code> 类型错误提示。这是因为在 React 18.x 版本中，React 团队认为 <code>children</code> 只是一个常规 prop，并不是什么特别的东西，默认移除了 <code>children</code> 这个 prop，因此我们需要像定义其他 props 一样去显式定义它。相关的讨论可在此常看：<span class=exturl data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzE3ODgyNTQvcmVhY3QtMTgtdHlwZXNjcmlwdC1jaGlsZHJlbi1mYw==">React 18 TypeScript children FC<i class="fa fa-external-link-alt"></i></span>。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>type</span> FC&lt;P = &#123;&#125;&gt; = FunctionComponent&lt;P&gt;;</span><br><span class=line></span><br><span class=line><span class=keyword>interface</span> FunctionComponent&lt;P = &#123;&#125;&gt; &#123;</span><br><span class=line>  (props: P, context?: <span class=built_in>any</span>): ReactElement&lt;<span class=built_in>any</span>, <span class=built_in>any</span>&gt; | <span class=literal>null</span>;</span><br><span class=line>  propTypes?: WeakValidationMap&lt;P&gt; | <span class=literal>undefined</span>;</span><br><span class=line>  contextTypes?: ValidationMap&lt;<span class=built_in>any</span>&gt; | <span class=literal>undefined</span>;</span><br><span class=line>  defaultProps?: Partial&lt;P&gt; | <span class=literal>undefined</span>;</span><br><span class=line>  displayName?: <span class=built_in>string</span> | <span class=literal>undefined</span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h2 id=常见的-Hooks-类型><a href=#常见的-Hooks-类型 class=headerlink title="常见的 Hooks 类型"></a>常见的 Hooks 类型</h2><p>接下来我们看一下如何在 React 中编写一些常用的 hook。</p><h3 id=useState><a href=#useState class=headerlink title=useState></a>useState</h3><p><code>useState</code> 是一个用于在函数组件中添加状态的 hook，它返回一个包含当前状态和更新状态的数组。其类型定义如下：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>function</span> <span class=title>useState</span>&lt;<span class=title>S</span>&gt;(<span class=params>initialState: S | (() =&gt; S)</span>): [<span class=title>S</span>, <span class=title>Dispatch</span>&lt;<span class=title>SetStateAction</span>&lt;<span class=title>S</span>&gt;&gt;]</span>;</span><br></pre></td></tr></table></figure><p><code>useState</code> 接收一个泛型类型 <code>S</code>，该类型是状态的类型。它需要传递一个初始状态 <code>initialState</code>，可以是一个静态的初始状态值或一个函数，该函数返回初始状态。</p><p>大多数情况下，<code>useState</code> 不需要显式指定状态类型，TypeScript 会自动进行类型推断。但是如果初始值和未来值不同则需要特别声明。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>export</span> <span class=keyword>default</span> <span class=function><span class=keyword>function</span> <span class=title>List</span>(<span class=params></span>) </span>&#123;</span><br><span class=line>  <span class=keyword>const</span> [data, setData] = useState&lt;IData | <span class=literal>null</span>&gt;(<span class=literal>null</span>);</span><br><span class=line>  <span class=keyword>const</span> [num, setNum] = useState(<span class=number>1</span>);</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，如果 data 没有初始值，则为 <code>null</code>，其最终会被赋值 <code>IData</code> 类型的值，所以必须显式地将 data 的类型指定为这两种可能类型的集合。而 num 可以根据初始值推断为 <code>number</code> 类型，setNum 也会推断为 <code>Dispatch&lt;SetStateAction&lt;number&gt;&gt;</code>。</p><h3 id=useMemo><a href=#useMemo class=headerlink title=useMemo></a>useMemo</h3><p><code>useMemo</code> 是一个用于性能优化的 hook，它可以帮助避免在渲染时不必要地计算昂贵的计算结果。其类型定义如下：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>function</span> <span class=title>useMemo</span>&lt;<span class=title>T</span>&gt;(<span class=params>factory: () =&gt; T, deps: DependencyList | <span class=literal>undefined</span></span>): <span class=title>T</span></span>;</span><br></pre></td></tr></table></figure><p>从源码类型定义可以看出，<code>useMemo</code> 接收一个泛型类型 <code>T</code>，该类型是由工厂函数 <code>factory</code> 计算出来的值的类型。</p><h3 id=useCallback><a href=#useCallback class=headerlink title=useCallback></a>useCallback</h3><p><code>useCallback</code> 是一个用于性能优化的 hook，它可以帮助避免在渲染时不必要地创建新函数。其类型定义如下：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>function</span> <span class=title>useCallback</span>&lt;<span class=title>T</span> <span class=title>extends</span> <span class=title>Function</span>&gt;(<span class=params>callback: T, deps: DependencyList</span>): <span class=title>T</span></span>;</span><br></pre></td></tr></table></figure><p><code>useCallback</code> 接收一个泛型函数类型 <code>T</code>，返回一个与传入的回调函数相同类型的函数。</p><h3 id=useRef><a href=#useRef class=headerlink title=useRef></a>useRef</h3><p><code>useRef</code> 是一个用于在函数组件中存储可变值的 hook，它返回一个可变的 <code>ref</code> 对象，该对象包含一个 <code>current</code> 属性，可以用来存储和访问值。其类型定义如下：</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=function><span class=keyword>function</span> <span class=title>useRef</span>&lt;<span class=title>T</span>&gt;(<span class=params>initialValue: T</span>): <span class=title>MutableRefObject</span>&lt;<span class=title>T</span>&gt;</span>;</span><br><span class=line></span><br><span class=line><span class=keyword>interface</span> MutableRefObject&lt;T&gt; &#123;</span><br><span class=line>  <span class=attr>current</span>: T;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p><code>useRef</code> 接收一个泛型类型 <code>T</code>，该类型是 <code>ref</code> 对象 <code>current</code> 属性存储的值的类型。返回的 <code>ref</code> 对象的类型是 <code>MutableRefObject&lt;T&gt;</code>，它是一个包含 <code>current</code> 属性的对象。该属性可以被修改而不会触发组件重新渲染。</p><figure class="highlight typescript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> &#123; useRef, useEffect &#125; <span class=keyword>from</span> <span class=string>&#x27;react&#x27;</span>;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>MyComponent</span>(<span class=params></span>) </span>&#123;</span><br><span class=line>  <span class=keyword>const</span> inputRef = useRef&lt;HTMLInputElement&gt;(<span class=literal>null</span>);</span><br><span class=line></span><br><span class=line>  useEffect(<span class=function>() =&gt;</span> &#123;</span><br><span class=line>    <span class=keyword>if</span> (inputRef.current) &#123;</span><br><span class=line>      inputRef.current.focus();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;, []);</span><br><span class=line></span><br><span class=line>  <span class=keyword>return</span> <span class=xml><span class=tag>&lt;<span class=name>input</span> <span class=attr>type</span>=<span class=string>&quot;text&quot;</span> <span class=attr>ref</span>=<span class=string>&#123;inputRef&#125;</span> /&gt;</span></span>;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>在上述例子中，<code>MyComponent</code> 组件使用 <code>useRef</code> hook 来创建一个 <code>inputRef</code> 引用，它的类型是 <code>HTMLInputElement | null</code>。<code>useEffect</code> hook 在组件挂载后运行一次，它使用 <code>inputRef.current</code> 检查引用是否存在，如果存在则调用 <code>focus()</code> 方法以聚焦输入元素。</p><h1 id=总结><a href=#总结 class=headerlink title=总结></a>总结</h1><p>本文介绍了 TypeScript 的基本概念和高级语法，以及如何在项目中使用它来提高生产力。通过类型定义来指定变量、函数、对象等的类型，从而在编译时就能检测出潜在的风险，减少在运行时才能发现的问题。TypeScript 的高级语言特性使得代码的组织和重构更加方便，帮助开发者编写更加健壮、可维护的 JavaScript 代码，从而提高开发效率。</p><h1 id=参考链接><a href=#参考链接 class=headerlink title=参考链接></a>参考链接</h1><p><span class=exturl data-url="aHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svaW50cm8uaHRtbA==">The TypeScript Handbook<i class="fa fa-external-link-alt"></i></span></p><p><span class=exturl data-url="aHR0cHM6Ly9sZWFybnR5cGVzY3JpcHQuZGV2Lw==">Learn TypeScript<i class="fa fa-external-link-alt"></i></span></p><p><span class=exturl data-url=aHR0cHM6Ly93d3cuZnJlZWNvZGVjYW1wLm9yZy9uZXdzL3R5cGVzY3JpcHQtZm9yLXJlYWN0LWRldmVsb3BlcnMv>TypeScript for React Developers – Why TypeScript is Useful and How it Works<i class="fa fa-external-link-alt"></i></span></p><p><span class=exturl data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDA0MDE5NzA3Ni9hLTEwMjAwMDAwNDAxOTg3MTI=">typescript中intrinsic代表什么<i class="fa fa-external-link-alt"></i></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/TypeScript/ rel=tag><i class="fa fa-tag"></i> TypeScript</a></div><div class=post-nav><div class=post-nav-item><a href=/2020/09/13/deeply-understand-the-principle-of-V8-garbage-collection/ rel=prev title="深入理解 V8 的垃圾回收原理"><i class="fa fa-chevron-left"></i> 深入理解 V8 的垃圾回收原理</a></div><div class=post-nav-item></div></div></footer></article></div><div class=comments id=disqus_thread><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></main><footer class=footer><div class=footer-inner><div class=beian><span class=exturl data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbg==">浙ICP备18010341号-1</span></div><div class=copyright>&copy; <span itemprop=copyrightYear>2023</span><span class=with-love><i class="fa fa-heart"></i></span> <span class=author itemprop=copyrightHolder>KINGMUI</span></div><div class=wordcount><span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-chart-line"></i></span> <span title=站点总字数>157k</span></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-coffee"></i></span> <span title=站点阅读时长>2:22</span></span></div><div class=busuanzi-count><span class=post-meta-item id=busuanzi_container_site_uv><span class=post-meta-item-icon><i class="fa fa-user"></i></span><span class=site-uv title=总访客量><span id=busuanzi_value_site_uv></span></span></span><span class=post-meta-item id=busuanzi_container_site_pv><span class=post-meta-item-icon><i class="fa fa-eye"></i></span><span class=site-pv title=总访问量><span id=busuanzi_value_site_pv></span></span></span></div></div></footer><script size=300 alpha=0.6 zindex=-1 src=https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js></script><script src=https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin=anonymous></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/next-boot.js></script><script src=https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin=anonymous></script><script src=/js/third-party/search/local-search.js></script><script src=//code.tidio.co/2mlfx8hyeje2cy9cft6rpturddkkzkon.js></script><script src=/js/third-party/chat/tidio.js></script><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script class=next-config data-name=disqus type=application/json>{"enable":true,"shortname":"kingmui","count":false,"i18n":{"disqus":"disqus"}}</script><script src=/js/third-party/comments/disqus.js></script></body></html>