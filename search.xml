<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS页面渲染优化属性will-change</title>
    <url>/2017/11/03/CSS%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E5%B1%9E%E6%80%A7will-change/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h3><p>当我们通过某些行为（点击、移动或滚动）触发页面进行大面积绘制的时候，浏览器往往是没有准备的，只能被动使用CPU去计算与重绘，由于没有事先准备，应付渲染够呛，于是掉帧、卡顿。而 <code>will-change</code> 则是真正的行为触发之前告诉浏览器：“浏览器同学，我待会儿就要变形了，你心理和生理上都准备准备”。于是乎，浏览器同学把GPU给拉上了，从容应对即将到来的变形。而CSS属性 will-change 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。本文将介绍CSS属性 will-change 。</p>
<h3 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h3><p>GPU是图形处理器，专门处理和绘制图形相关的硬件。GPU是专为执行复杂的数学和几何计算而设计的，使得CPU从图形处理的任务中解放出来，可以执行其他更多的系统任务。</p>
<p>所谓硬件加速，就是在计算机中把计算量非常大的工作分配给专门的硬件来处理，减轻CPU的工作量。</p>
<p>CSS的动画、变形、渐变并不会自动触发GPU加速，而是使用浏览器稍慢的软件渲染引擎。在 <code>transition</code> 、 <code>transform</code> 和 <code>animation</code> 的世界里，应该卸载进程到GPU以加速速度。只有3D变形会有自己的layer，而2D变形则不会。</p>
<span id="more"></span>

<p>【Hack】<br>我们可能听说过，3D transform会启用GPU加速<sup>①</sup>，例如 <code>translate3D</code> ， <code>scaleZ</code> 之类，但是，这些属性业界往往称之为 <code>hack</code> 加速法。我们实际上不需要 <code>z</code> 轴的变化，但是还是假模假样地声明了，欺骗浏览器，这其实是一种不人道的做法。</p>
<div class="note info"><p>① GPU 即图形处理器，是处理和绘制图形相关的硬件。GPU 是专为执行复杂的数学和几何计算而设计的，可以让 CPU 从图形处理的任务中解放出来，从而执行其他更多的系统任务，例如，页面的计算与重绘。</p>
</div>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="will-change"><a href="#will-change" class="headerlink" title="will-change"></a>will-change</h4><p>功能: 提前通知浏览器元素将要做什么动画，让浏览器提前准备合适的优化设置值： <code>auto | &lt;animateable-feature&gt;</code></p>
<ul>
<li>初始值：auto</li>
<li>适用元素：所有元素</li>
<li>继承性：无</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jYW5pdXNlLmNvbS93aWxsLWNoYW5nZS9lbWJlZA==">兼容性<i class="fa fa-external-link-alt"></i></span>：Chrome36+、Firefox36+、Opera24+、Android37+、</li>
</ul>
<p><code>auto</code></p>
<ul>
<li>表示没有特别指定哪些属性会变化，浏览器需要自己去猜，然后使用浏览器经常使用的一些常规方法优化。</li>
</ul>
<p><code>&lt;animateable-feature&gt;</code> 可以是以下值：<br><code>scroll-position</code></p>
<ul>
<li>表示开发者希望在不久后改变滚动条的位置或者使之产生动画。</li>
</ul>
<p><code>contents</code></p>
<ul>
<li>表示开发者希望在不久后改变元素内容中的某些东西，或者使它们产生动画。</li>
</ul>
<p><code>&lt;custom-ident&gt;</code></p>
<ul>
<li>表示开发者希望在不久后改变指定的属性名或者使之产生动画。如果属性名是简写，则代表所有与之对应的简写或者全写的属性。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>【使用hover】<br>不要这样直接写在默认状态中，因为<code>will-change</code>会一直挂着：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.will-change</span> &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.will-change</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以让父元素hover的时候，声明 <code>will-change</code> ，这样，移出的时候就会自动 <code>remove</code> ，触发的范围基本上是有效元素范围。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.will-change-parent</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.will-change</span> &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.will-change</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.will-change</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【使用javascript脚本】</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例在样式表中直接添加了 <code>will-change</code> 属性，会导致浏览器将对应的优化工作一直保存在内存中，这其实是不必要的，前面我们已经看过为什么应该避免这样的做法。下面是另一个展示如何使用脚本正确地应用 <code>will-change</code> 属性的示例，在大部分的场景中，你都应该这样做。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;element&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当鼠标移动到该元素上时给该元素设置 will-change 属性</span></span><br><span class="line">el.addEventListener(<span class="string">&#x27;mouseenter&#x27;</span>, hintBrowser);</span><br><span class="line"><span class="comment">// 当 CSS 动画结束后清除 will-change 属性</span></span><br><span class="line">el.addEventListener(<span class="string">&#x27;animationEnd&#x27;</span>, removeHint);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hintBrowser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 填写上那些你知道的，会在 CSS 动画中发生改变的 CSS 属性名们</span></span><br><span class="line">  <span class="built_in">this</span>.style.willChange = <span class="string">&#x27;transform, opacity&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeHint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.style.willChange = <span class="string">&#x27;auto&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【直接使用】</p>
<p>但是，如果某个应用在按下键盘的时候会翻页，比如相册或者幻灯片一类的，它的页面很大很复杂，此时在样式表中写上 <code>will-change</code> 是合适的。这会使浏览器提前准备好过渡动画，当键盘按下的时候就能立即看到灵活轻快的动画。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.slide</span> &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>不要将 will-change 应用到太多元素上</strong>：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与 <code>will-change</code> 结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。</li>
<li><strong>有节制地使用：</strong>通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了 <code>will-change</code> 属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是<mark class="label info">当元素变化之前和之后通过脚本来切换</mark> <code>will-change</code> <mark class="label info">的值</mark>。</li>
<li><strong>不要过早应用 will-change 优化：</strong>如果你的页面在性能方面没什么问题，则不要添加 <code>will-change</code> 属性来榨取一丁点的速度。 <code>will-change</code> 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。<mark class="label info">过度使用</mark> <code>will-change</code> <mark class="label info">会导致大量的内存占用，并会导致更复杂的渲染过程</mark>，因为浏览器会试图准备可能存在的变化过程。这会导致更严重的性能问题。</li>
<li><strong>给它足够的工作时间：</strong>这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上 <code>will-change</code> 属性。</li>
</ol>
]]></content>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 5的严格模式</title>
    <url>/2019/04/10/ECMAScript%205%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>ECMAScript 5 引入了 <code>strict mode</code>，现在已经被大多浏览器实现(包括 IE10)。会使 web 浏览器更容易的解析代码(只需要添加 <code>&quot;use strict&quot;;</code> 在源码的最上面)。</p>
</div>

<p>严格模式不仅仅是一个子集：它的产生是为了形成与正常代码不同的语义。不支持严格模式与支持严格模式的浏览器在执行严格模式代码时会采用不同行为。所以在没有对运行环境展开<strong>特性测试</strong>来验证对于严格模式相关方面支持的情况下，就算采用了严格模式也不一定会取得预期效果。严格模式代码和非严格模式代码可以共存，因此项目脚本可以渐进式地采用严格模式。</p>
<p>严格模式对正常的 JavaScript 语义做了一些更改。</p>
<ol>
<li>严格模式通过<strong>抛出错误</strong>来消除了一些原有<strong>静默错误</strong>。</li>
<li>严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下<strong>运行得更快</strong>。</li>
<li>严格模式<strong>禁用了</strong>在 ECMAScript 的未来版本中可能会定义的一些语法。</li>
</ol>
<h3 id="非严格模式到严格模式的区别"><a href="#非严格模式到严格模式的区别" class="headerlink" title="非严格模式到严格模式的区别"></a>非严格模式到严格模式的区别</h3><p>严格模式同时改变了语法及运行时行为。</p>
<span id="more"></span>

<p><strong>语法错误</strong></p>
<p>如果代码中使用 <code>&quot;use strict&quot;</code> 开启了严格模式，则下面的情况都会在脚本运行之前抛出 <code>SyntaxError</code> 异常:</p>
<ul>
<li>八进制语法：<code>var n = 023</code> 和 <code>var s = &quot;\047&quot;</code></li>
<li><code>with</code> 语句</li>
<li>使用 <code>delete</code> 删除一个变量名(而不是属性名)：<code>delete myVariable</code></li>
<li>使用 <code>eval</code> 或 <code>arguments</code> 作为变量名或函数名</li>
<li>使用未来保留字(也许会在 ECMAScript 6 中使用)：<code>implements, interface, let, package, private, protected, public, static,和 yield</code> 作为变量名或函数名</li>
<li>在语句块中使用函数声明：<code>if(a &lt; b) &#123; function f() &#123;&#125; &#125;</code></li>
<li>其他错误<ul>
<li>对象字面量中使用两个相同的属性名：<code>&#123;a: 1, b: 3, a: 7&#125;</code></li>
<li>函数形参中使用两个相同的参数名：<code>function f(a, b, b) &#123;&#125;</code></li>
</ul>
</li>
</ul>
<p>这些错误是有利的，因为可以揭示简陋的错误和坏的实践，这些错误会在代码运行前被抛出。</p>
<p><strong>新的运行时错误</strong></p>
<p>JavaScript 曾经会在一些上下文的某些情况中静默的失败，严格模式会在这些情况下抛出错误。如果你的代码包含这样的场景，请务必测试以确保没有代码受到影响。再说一次，严格模式是可以设置在代码粒度下的。</p>
<ol>
<li>给一个未声明的变量赋值</li>
</ol>
<p>严格模式下无法再意外创建全局变量。在普通的 JavaScript 里面给一个拼写错误的变量名赋值会使全局对象新增一个属性并继续“工作”（尽管后面可能出错：在现在的 JavaScript 中有可能）。严格模式中意外创建全局变量被抛出错误替代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line">  b = a + x * <span class="number">35</span>; <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>改变一个全局对象的值可能会造成不可预期的后果。如果你真的想设置一个全局对象的值，把他作为一个参数并且明确的把它作为一个属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">global</span> = <span class="built_in">this</span>; <span class="comment">// in the top-level context, &quot;this&quot; always refers the global object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line">  <span class="built_in">global</span>.b = a + x * <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>其次，严格模式会使引起静默失败(silently fail，注：不报错也没有任何效果)的赋值操作抛出异常。例如，NaN 是一个不可写的全局变量。在正常模式下，给 NaN 赋值不会产生任何作用；开发者也不会受到任何错误反馈。但在严格模式下，给 NaN 赋值会抛出一个异常。任何在正常模式下引起静默失败的赋值操作 (给不可写属性赋值，给只读属性(getter-only)赋值赋值，给不可扩展对象(non-extensible object)的新属性赋值) 都会抛出异常。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不可写属性赋值</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">&#x27;x&#x27;</span>, &#123; <span class="attr">value</span>: <span class="number">42</span>, <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">obj1.x = <span class="number">9</span>; <span class="comment">// Uncaught TypeError: Cannot assign to read only property &#x27;x&#x27; of object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给只读属性赋值</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj2.x = <span class="number">5</span>; <span class="comment">// Uncaught TypeError: Cannot set property x of #&lt;Object&gt; which has only a getter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不可扩展对象的新属性赋值</span></span><br><span class="line"><span class="keyword">var</span> fixed = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(fixed);</span><br><span class="line">fixed.newProp = <span class="string">&#x27;ohai&#x27;</span>; <span class="comment">// Uncaught TypeError: Cannot add property newProp, object is not extensible</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>尝试删除一个不可配置的属性</li>
</ol>
<p>在严格模式下，试图删除不可删除的属性时会抛出异常(之前这种操作不会产生任何效果)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// Uncaught TypeError: Cannot delete property &#x27;prototype&#x27; of function Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p>在非严格模式中，这样的代码只会静默失败，这样可能会导致用户误以为删除操作成功了。</p>
<ol start="3">
<li>一个对象内出现重名属性</li>
</ol>
<p>在 Gecko 版本 34 之前，严格模式要求一个对象内的所有属性名在对象内必须唯一。正常模式下重名属性是允许的，最后一个重名的属性决定其属性值。因为只有最后一个属性起作用，当代码要去改变属性值而不是修改最后一个重名属性的时候，复制这个对象就产生一连串的 bug。在严格模式下，重名属性被认为是语法错误。<strong>这个问题在 ECMAScript6 中已经不复存在了</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">p</span>: <span class="number">1</span>, <span class="attr">p</span>: <span class="number">2</span> &#125;; <span class="comment">// !!! 语法错误</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>函数参数名不唯一</li>
</ol>
<p>严格模式要求函数的参数名唯一。在正常模式下，最后一个重名参数名会<strong>掩盖</strong>之前的重名参数。之前的参数仍然可以通过 <code>arguments[i]</code> 来访问，还不是完全无法访问。然而，这种隐藏毫无意义而且可能是意料之外的 (比如它可能本来是打错了)，所以在严格模式下重名参数被认为是语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, a, c</span>) </span>&#123; <span class="comment">// !!! 语法错误</span></span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> a + a + c; <span class="comment">// 代码运行到这里会出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>禁止八进制数字语法</li>
</ol>
<p>严格模式禁止八进制数字语法。ECMAScript 并<strong>不包含八进制语法</strong>，但所有的浏览器都支持这种以零(0)开头的八进制语法: <code>0644 === 420</code> 还有 <code>&quot;\045&quot; === &quot;%&quot;</code>。在 ECMAScript 6 中支持为一个数字加 <code>0o</code> 的前缀来表示八进制数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0o10</span>; <span class="comment">// ES6: 八进制</span></span><br></pre></td></tr></table></figure>

<p>有些新手开发者认为数字的前导零没有语法意义，所以他们会用作对齐措施 — 但其实这会改变数字的意义！八进制语法很少有用并且可能会错误使用，所以严格模式下八进制语法会引起语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">015</span> + <span class="comment">// !!! 语法错误</span></span><br><span class="line">          <span class="number">197</span> +</span><br><span class="line">          <span class="number">142</span>;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>禁止给原始值设置属性</li>
</ol>
<p>ECMAScript 6 中的严格模式禁止设置 primitive 值的属性。不采用严格模式，设置属性将会简单忽略(no-op)，采用严格模式，将抛出 <code>TypeError</code> 错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="literal">false</span>.true = <span class="string">&#x27;&#x27;</span>; <span class="comment">// Uncaught TypeError: Cannot create property &#x27;true&#x27; on boolean &#x27;false&#x27;</span></span><br><span class="line">  (<span class="number">14</span>).sailing = <span class="string">&#x27;home&#x27;</span>; <span class="comment">// Uncaught TypeError: Cannot create property &#x27;sailing&#x27; on number &#x27;14&#x27;</span></span><br><span class="line">  <span class="string">&#x27;with&#x27;</span>.you = <span class="string">&#x27;far away&#x27;</span>; <span class="comment">// Uncaught TypeError: Cannot create property &#x27;you&#x27; on string &#x27;with&#x27;</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>arguments</code> 对象和函数属性</li>
</ol>
<p>在严格模式下，访问 <code>arguments.callee</code>， <code>arguments.caller</code>， <code>anyFunction.caller</code> 以及 <code>anyFunction.arguments</code> 都会抛出异常。唯一合法的使用应该是在其中命名一个函数并且重用之。<br>正常模式下，<code>arguments.callee</code> 指向当前正在执行的函数。这个作用很小：直接给执行函数命名就可以了！此外，<code>arguments.callee</code> 十分不利于优化，例如内联函数，因为 <code>arguments.callee</code> 会依赖对非内联函数的引用。在严格模式下，<code>arguments.callee</code> 是一个不可删除属性，而且赋值和读取时都会抛出异常。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;thing&#x27;</span>).style;</span><br><span class="line">s.opacity = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((s.opacity -= <span class="number">0.1</span>) &lt; <span class="number">0</span>) s.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">setTimeout</span>(<span class="built_in">arguments</span>.callee, <span class="number">40</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>可以重新写成:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;thing&#x27;</span>).style;</span><br><span class="line">s.opacity = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fadeOut</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// name the function</span></span><br><span class="line">  <span class="keyword">if</span> ((s.opacity -= <span class="number">0.1</span>) &lt; <span class="number">0</span>) s.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">setTimeout</span>(fadeOut, <span class="number">40</span>); <span class="comment">// use the name of the function</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>严格模式禁用 <code>with</code></li>
</ol>
<p>严格模式禁用 <code>with</code>。<code>with</code> 所引起的问题是块内的任何名称可以映射(map)到 <code>with</code> 传进来的对象的属性，也可以映射到包围这个块的作用域内的变量(甚至是全局变量)，这一切都是在运行时决定的，在代码运行之前是无法得知的。严格模式下，使用 <code>with</code> 会引起语法错误，所以就不会存在 <code>with</code> 块内的变量在运行时才决定引用到哪里的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">with</span> (obj) <span class="comment">// !!! 语法错误</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果没有开启严格模式，with中的这个x会指向with上面的那个x，还是obj.x？</span></span><br><span class="line">  <span class="comment">// 如果不运行代码，我们无法知道，因此，这种代码让引擎无法进行优化，速度也就会变慢。</span></span><br><span class="line">  x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种取代 <code>with</code> 的简单方法是，将目标对象赋给一个短命名变量，然后访问这个变量上的相应属性。</p>
<p><strong>语义差异</strong></p>
<p>这些差异都是一些微小的差异。有可能单元测试没办法捕获这种微小的差异。你很有必要去小心地审查你的代码，来确保这些差异不会影响你代码的语义。幸运的是，这种小心地代码审查可以逐函数地完成。</p>
<ol>
<li>函数调用中的 <code>this</code></li>
</ol>
<p>在普通的函数调用 <code>f()</code> 中，<code>this</code> 的值会指向全局对象 <code>window</code>。在严格模式中，<code>this</code> 的值会指向 <code>undefined</code>。<br>当函数通过 <code>call</code> 和 <code>apply</code> 调用时，如果传入的 <code>thisvalue</code> 参数是一个非 <code>null</code> 和 <code>undefined</code> 的原始值(字符串，数字，布尔值)，则 <code>this</code> 的值会成为那个<strong>原始值对应的包装对象</strong>。如果 <code>thisvalue</code> 参数的值是 <code>undefined</code> 或 <code>null</code>，则 <code>this</code> 的值会指向全局对象 <code>window</code>。在严格模式中，<code>this</code> 的值就是 <code>thisvalue</code> 参数的值，<strong>没有任何类型转换</strong>。</p>
<ol start="2">
<li><code>arguments</code> 对象属性不与对应的形参变量同步更新</li>
</ol>
<p>在非严格模式中，修改 <code>arguments</code> 对象中某个索引属性的值，和这个属性对应的形参变量的值也会同时变化，反之亦然。这会让 JavaScript 的代码混淆引擎让代码变得更难读和理解。在严格模式中 <code>arguments</code> 对象会以<strong>形参变量的拷贝的形式被创建和初始化</strong>，因此 <code>arguments</code> 对象的改变<strong>不会影响形参</strong>。</p>
<ol start="3">
<li><code>eval</code> 相关的区别</li>
</ol>
<p>在严格模式中，<code>eval</code> 不会在当前的作用域内创建新的变量。另外，传入 <code>eval</code> 的字符串参数也会按照严格模式来解析。你需要全面测试来确保没有代码受到影响。另外，如果你并不是为了解决一个非常实际的解决方案中，尽量不要使用 <code>eval</code>。</p>
<p>严格模式下的 <code>eval</code> 不再为上层范围(surrounding scope, 注:包围 <code>eval</code> 代码块的范围)引入新变量。在正常模式下，代码 <code>eval(&quot;var x;&quot;)</code> 会给上层函数(surrounding function)或者全局引入一个新的变量 <code>x</code>。这意味着，一般情况下，在一个包含 <code>eval</code> 调用的函数内所有没有引用到参数或者局部变量的名称都必须在运行时才能被映射到特定的定义 (因为 <code>eval</code> 可能引入的新变量会覆盖它的外层变量)。在严格模式下 <code>eval</code> 仅仅为被运行的代码创建变量，所以 <code>eval</code> 不会使得名称映射到外部变量或者其他局部变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> evalX = <span class="built_in">eval</span>(<span class="string">&quot;&#x27;use strict&#x27;; var x = 42; x&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(x === <span class="number">17</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(evalX === <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>相应的，如果函数 <code>eval</code> 被在严格模式下的 <code>eval(...)</code> 以表达式的形式调用时，其代码会被当做严格模式下的代码执行。当然也可以在代码中显式开启严格模式，但这样做并不是必须的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict1</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(str); <span class="comment">// str中的代码在严格模式下运行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict2</span>(<span class="params">f, str</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> f(str); <span class="comment">// 没有直接调用eval(...): 当且仅当str中的代码开启了严格模式时</span></span><br><span class="line">  <span class="comment">// 才会在严格模式下运行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonstrict</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">eval</span>(str); <span class="comment">// 当且仅当str中的代码开启了&quot;use strict&quot;，str中的代码才会在严格模式下运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strict1(<span class="string">&quot;&#x27;Strict mode code!&#x27;&quot;</span>);</span><br><span class="line">strict1(<span class="string">&quot;&#x27;use strict&#x27;; &#x27;Strict mode code!&#x27;&quot;</span>);</span><br><span class="line">strict2(<span class="built_in">eval</span>, <span class="string">&quot;&#x27;Non-strict code.&#x27;&quot;</span>);</span><br><span class="line">strict2(<span class="built_in">eval</span>, <span class="string">&quot;&#x27;use strict&#x27;; &#x27;Strict mode code!&#x27;&quot;</span>);</span><br><span class="line">nonstrict(<span class="string">&quot;&#x27;Non-strict code.&#x27;&quot;</span>);</span><br><span class="line">nonstrict(<span class="string">&quot;&#x27;use strict&#x27;; &#x27;Strict mode code!&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="调用严格模式"><a href="#调用严格模式" class="headerlink" title="调用严格模式"></a>调用严格模式</h3><p>严格模式可以应用到整个脚本或个别函数中。不要在封闭大括弧 <code>&#123;&#125;</code> 内这样做，在这样的上下文中这么做是没有效果的。在 <code>eval</code>、<code>Function</code>、内联事件处理属性、 <code>WindowTimers.setTimeout()</code> 方法中传入的脚本字符串，其行为类似于开启了严格模式的一个单独脚本，它们会如预期一样工作。</p>
<p><strong>为脚本开启严格模式</strong></p>
<p>为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句 <code>&quot;use strict&quot;;</code> （或 <code>&#39;use strict&#39;;</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为整个脚本开启严格模式</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> v = <span class="string">&quot;Hi!  I&#x27;m a strict mode script!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这种语法存在陷阱，不能盲目的合并冲突代码。试想合并一个严格模式的脚本和一个非严格模式的脚本：合并后的脚本代码看起来是严格模式。反之亦然：非严格合并严格看起来是非严格的。合并均为严格模式的脚本或均为非严格模式的都没问题，只有在合并严格模式与非严格模式有可能有问题。建议按一个个函数去开启严格模式（至少在学习的过渡期要这样做）。</p>
<p>您也可以将整个脚本的内容用一个函数包括起来，然后在这个外部函数中使用严格模式。这样做就可以消除合并的问题，但是这就意味着您必须要在函数作用域外声明一个全局变量。</p>
<p><strong>为函数开启严格模式</strong></p>
<p>同样的，要给某个函数开启严格模式，得把 <code>&quot;use strict&quot;;</code> (或 <code>&#39;use strict&#39;;</code> )声明一字不漏地放在函数体所有语句之前。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数级别严格模式语法</span></span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nested</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;And so am I!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hi!  I&#x27;m a strict mode function!  &quot;</span> + nested();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">notStrict</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;I&#x27;m not strict.&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="严格中立的代码"><a href="#严格中立的代码" class="headerlink" title="严格中立的代码"></a>严格中立的代码</h3><p>迁移严格代码至严格模式的一个潜在消极面是，在遗留的老版本浏览器上，由于没有实现严格模式，JavaScript 语义可能会有所不同。在一些罕见的情况下（比如差劲的关联关系或者代码最小化），你的代码可能不能按照你书写或者测试里的模式那样运行。这里有一些让你的代码保持中立的规范：</p>
<ol>
<li>按照严格模式书写你的代码，并且确保你的代码不会发生仅仅在严格模式下发生的错误（比如上文所说的运行时错误）</li>
<li>远离语义差异<ol>
<li><code>eval</code>：仅仅在你知道你在干什么的情况下使用它</li>
<li><code>arguments</code> 总是通过形参的名字获取函数参数，或者在函数的第一行拷贝 <code>arguments</code>。<code>var args = Array.prototype.slice.call(arguments)</code></li>
</ol>
</li>
<li><code>this</code>：仅在 <code>this</code> 指向你自己创建的对象时使用它</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5 Web 存储</title>
    <url>/2017/11/03/HTML5Web%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各式各样的需求，会经常性地在本地存储大量的数据。传统方式我们是以document.cookie来进行存储的，但是由于cookie的存储大小只有4k左右，并且解析也相当的复杂，每一次发送请求还会携带上cookie，这不仅会造成带宽的浪费，还会给开发者带来诸多不便。在此窘境下，HTML5规范提出了新的解决方案——Web存储。Web存储是将数据存储到用户的电脑上，这样不仅可以缓解服务器压力，同时也提高了用户体验。在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。</p>
</div>

<h3 id="cookie概念"><a href="#cookie概念" class="headerlink" title="cookie概念"></a>cookie概念</h3><ul>
<li>cookie是客户端保持状态的解决方案。cookie存储了服务端发送给客户端的一些特殊信息，这些信息以文本的方式存储在客户端。每当客户端向服务端发送请求时，<strong>cookie数据始终会在同源的http请求中携带（即使不需要）</strong>，即cookie会在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发送给服务器，仅会在本地存储。</li>
</ul>
<span id="more"></span>

<ul>
<li>因为受浏览器的同源策略影响，cookie始终是以域名为单位进行存储的，每个域名间的cookie是相互隔离的，也就是说<strong>不同域名之间的cookie是不可以相互操作的</strong>。</li>
<li>必须通过http协议访问页面，才能访问到cookie中的内容。</li>
<li>cookie数据不能超过4k，因为每次http请求都会携带cookie，所以<strong>cookie只适合保存很小的数据</strong>，如会话标识。</li>
<li>cookie的生命周期默认是会话周期，即关闭浏览器后cookie就没了。可以根据需要给cookie设置过期时间<code>document.cookie = &quot;max-age=60;path=/&quot;;</code></li>
<li>cookie数据还有路径(path)的概念，一个域名下的cookie在该域名下的所有页面中都是可以被访问的。子路径中可以访问父路径中存储的cookie，但是父路径中无法访问子路径中的cookie，一般情况下，我们会把cookie存储到域名的根目录下<code>path=/</code>，这样，在该域名下所有的页面中都可以访问到。</li>
<li>cookie数据在所有同源窗口中都是共享的。</li>
</ul>
<h3 id="localStorage概念"><a href="#localStorage概念" class="headerlink" title="localStorage概念"></a>localStorage概念</h3><blockquote><p>localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。</p>
<footer><strong>w3school</strong><cite><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vaHRtbDUvaHRtbF81X3dlYnN0b3JhZ2UuYXNw">HTML 5 Web 存储<i class="fa fa-external-link-alt"></i></span></cite></footer></blockquote>
<ul>
<li>将数据永久存储在本地，即使关闭页面，关闭电脑，断电等都不会删除数据，除非手动删除或用代码清除。</li>
<li><strong>支持多窗口数据共享</strong>，一些不涉及到安全的数据（不要太过庞大）都可以存储到本地。</li>
</ul>
<h3 id="sessionStorage概念"><a href="#sessionStorage概念" class="headerlink" title="sessionStorage概念"></a>sessionStorage概念</h3><blockquote><p>sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。</p>
<footer><strong>w3school</strong><cite><span class="exturl" data-url="aHR0cDovL3d3dy53M3NjaG9vbC5jb20uY24vaHRtbDUvaHRtbF81X3dlYnN0b3JhZ2UuYXNw">HTML 5 Web 存储<i class="fa fa-external-link-alt"></i></span></cite></footer></blockquote>
<ul>
<li>将数据临时存储在本地，一旦关闭掉当前页面，sessionStorage数据默认会被删除，即生命周期为关闭当前页面窗口。</li>
<li><strong>不支持多窗口数据共享，但是支持链接跳转的数据共享</strong>，在页面跳转的时候可以通过sessionStorage实现数据共享（同源策略）</li>
</ul>
<h3 id="HTML-5-Web-存储特性"><a href="#HTML-5-Web-存储特性" class="headerlink" title="HTML 5 Web 存储特性"></a>HTML 5 Web 存储特性</h3><ul>
<li>设置、读取方便。</li>
<li>容量较大，<strong>sessionStorage可存储大约5M数据</strong>、<strong>localStorage可存储5M~20M数据</strong>。</li>
<li>只能存储字符串，可以将对象通过<code>JSON.stringify()</code>方法编码后存储。</li>
</ul>
<h3 id="HTML-5-Web-存储差异性"><a href="#HTML-5-Web-存储差异性" class="headerlink" title="HTML 5 Web 存储差异性"></a>HTML 5 Web 存储差异性</h3><ul>
<li>相同点<ul>
<li>都是将数据存储在web端，并且都是同源</li>
</ul>
</li>
<li>不同点<ul>
<li>cookie 只能存储4K数据，并且每一次请求都会携带上cookie，体验不好，浪费带宽</li>
<li>sessionStorage和localStorage直接存储在本地，请求不会携带，并且容量比cookie要大的多</li>
<li>sessionStorage 是临时会话，当窗口被关闭时就清除掉，而localStorage 永久存在，cookie有过期时间</li>
<li>cookie 和localStorage 都可以支持多窗口共享，而sessionStorage 不支持多窗口共享，但是支持链接跳转的数据共享</li>
</ul>
</li>
</ul>
<h3 id="sessionStorage和localStorage方法详解"><a href="#sessionStorage和localStorage方法详解" class="headerlink" title="sessionStorage和localStorage方法详解"></a>sessionStorage和localStorage方法详解</h3><table>
<thead>
<tr>
<th>方法/属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>setItem(key,value)</td>
<td>设置存储内容</td>
</tr>
<tr>
<td>getItem(key)</td>
<td>读取存储内容</td>
</tr>
<tr>
<td>removeItem(key)</td>
<td>删除键为key的存储内容</td>
</tr>
<tr>
<td>clear()</td>
<td>清空所有存储内容</td>
</tr>
<tr>
<td>key(n)</td>
<td>以索引值来获取键名</td>
</tr>
<tr>
<td>length</td>
<td>存储的数据的个数</td>
</tr>
</tbody></table>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 存数据</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">// 如果&quot;键&quot;一样，后面存储的会将前面存储的覆盖掉</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;fly1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;fly2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">	sessionStorage.setItem(<span class="string">&#x27;usernameSession1&#x27;</span>,<span class="string">&#x27;fly3&#x27;</span>);</span></span><br><span class="line"><span class="javascript">	sessionStorage.setItem(<span class="string">&#x27;usernameSession2&#x27;</span>,<span class="string">&#x27;fly4&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 取数据</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;username&#x27;</span>));           <span class="comment">// fly2</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(sessionStorage.getItem(<span class="string">&#x27;usernameSession1&#x27;</span>)); <span class="comment">// fly3</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 数据的长度</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.length);   <span class="comment">// 1</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(sessionStorage.length); <span class="comment">// 2</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 删除数据</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">// localStorage.removeItem(&#x27;username&#x27;);</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">// sessionStorage.removeItem(&#x27;usernameSession2&#x27;);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 清除所有的数据</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">// localStorage.clear();</span></span></span><br><span class="line"><span class="javascript">	<span class="comment">// sessionStorage.clear();</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 获取键名</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.key(<span class="number">0</span>));   <span class="comment">// username</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(sessionStorage.key(<span class="number">0</span>)); <span class="comment">// usernameSession1</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- sessionStorage支持链接跳转的数据共享(包括在新窗口中打开) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;sharing.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	sessionStorage.setItem(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;fly&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- sharing.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(sessionStorage.getItem(<span class="string">&#x27;username&#x27;</span>)); <span class="comment">// fly</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage不能在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</p>
]]></content>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo个性化配置</title>
    <url>/2016/11/24/Hexo%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h3><h4 id="给你的-hexo-站点添加-sitemap-网站地图"><a href="#给你的-hexo-站点添加-sitemap-网站地图" class="headerlink" title="给你的 hexo 站点添加 sitemap 网站地图"></a>给你的 hexo 站点添加 sitemap 网站地图</h4><ol>
<li>安装 hexo 的 sitemap 网站地图生成插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在你的 hexo 站点的 <code>_config.yml</code> 文件中添加以下代码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo sitemap网站地图</span></span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>配置成功后，hexo 编译时会在 hexo 站点根目录生成 <code>sitemap.xml</code> 和 <code>baidusitemap.xml</code>。<br>其中 <code>sitemap.xml</code> 适合提交给谷歌搜素引擎，<code>baidusitemap.xml</code> 适合提交百度搜索引擎。</p>
</li>
<li><p>给你的 hexo 网站添加蜘蛛协议 <code>robots.txt</code>。把 <code>robots.txt</code> 放在你的 hexo 站点的 <code>source</code> 文件下即可。代码如下：</p>
</li>
</ol>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo robots.txt</span></span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: http://www.kingmui.cn/sitemap.xml</span><br><span class="line">Sitemap: http://www.kingmui.cn/baidusitemap.xml</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>主动推送 Hexo 博客新链接至百度搜索引擎<br>为了解决百度爬虫被禁止访问的问题，提升网站收录质量和速度。推荐安装 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aXdhbmcvaGV4by1iYWlkdS11cmwtc3VibWl0">hexo-baidu-url-submit<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># baidu_url_submit 配置</span></span><br><span class="line">baidu_url_submit:</span><br><span class="line">  count: 1000 <span class="comment">## 提交最新的一个链接</span></span><br><span class="line">  host: alili.tech <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  token: xxxxx <span class="comment">## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  path: baidu_urls.txt <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br><span class="line">  xz_appid: <span class="string">&#x27;xxxxxx&#x27;</span> <span class="comment">## 你的熊掌号 appid</span></span><br><span class="line">  xz_token: <span class="string">&#x27;xxxxxx&#x27;</span> <span class="comment">## 你的熊掌号 token</span></span><br><span class="line">  xz_count: 10 <span class="comment">## 从所有的提交的数据当中选取最新的10条,该数量跟你的熊掌号而定</span></span><br><span class="line"><span class="comment"># deploy 配置</span></span><br><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: baidu_url_submitter <span class="comment"># 百度</span></span><br><span class="line">- <span class="built_in">type</span>: baidu_xz_url_submitter <span class="comment"># 百度熊掌号</span></span><br></pre></td></tr></table></figure>

<h4 id="给非友情链接的出站链接添加-“nofollow”-标签"><a href="#给非友情链接的出站链接添加-“nofollow”-标签" class="headerlink" title="给非友情链接的出站链接添加 “nofollow” 标签"></a>给非友情链接的出站链接添加 “nofollow” 标签</h4><p>经过 chinaz 站长工具友情链接检测，发现有不必要的 PR 值输出，对于非友情链接的 PR 值输出，我们可以加上 nofollow 便签避免不必要的 PR 输出。这里推荐使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdXpjL2hleG8tYXV0b25vZm9sbG93">hexo-autonofollow<i class="fa fa-external-link-alt"></i></span>，它会自动将 nofollow 属性添加到 hexo 博客文章中的所有外部链接。 配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nofollow:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  exclude:</span><br><span class="line">    - kingmui.cn</span><br></pre></td></tr></table></figure>

<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>由于 Github Pages 是有限制的，它不允许任意域名都跳转过来，而是只限制一个域名，而且这个域名必须声明在 CNAME 文件中。所以，我们需要添加一个 CNAME 文件到项目的 master 中才行。我们使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlZWNyb3NzbGV5L2hleG8tZ2VuZXJhdG9yLWNuYW1l">hexo-generator-cname<i class="fa fa-external-link-alt"></i></span> 来自动在 public 里生成一个 CNAME 文件！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意：只需安装即可，不要在 _config.yml 启用</span></span><br><span class="line">npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure>

<h3 id="RSS-订阅"><a href="#RSS-订阅" class="headerlink" title="RSS 订阅"></a>RSS 订阅</h3><p>目前很多人喜欢用 RSS 阅读器来实时更新某些作者的文章。这里我们利用插件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWdlbmVyYXRvci1mZWVk">hexo-generator-feed<i class="fa fa-external-link-alt"></i></span> 来实现这个功能。</p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed –save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改 <code>_config.yml</code>，具体设置可以参考官方链接里的指示</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">  <span class="built_in">type</span>: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  <span class="built_in">limit</span>: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: <span class="string">&#x27; &#x27;</span></span><br><span class="line">  order_by: -date</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 themes/next/_config.yml 里的 menu 添加 <code>rss: /atom.xml</code></li>
<li>在 themes/next/languages/zh-CN.yml 里的 <code>menu</code> 添加中文翻译 <code>rss: RSS</code></li>
</ol>
<h3 id="个人简历页面"><a href="#个人简历页面" class="headerlink" title="个人简历页面"></a>个人简历页面</h3><p>对于一个优秀的博主而言，每天会有很多开发者进入到他的博客。<br>而无论出于职业生涯还是个人影响力的角度考虑，在博客里放置个人简历是一个很好的展示自己的机会。<br>下面我们来利用 hexo 的 page 功能来创建一个新页面，然后用 markdown 来填充这个简历页面。</p>
<ol>
<li>利用 <code>hexo new page &quot;resume&quot;</code>，可以看到 <code>source</code> 文件夹下出现了 <code>resume</code> 目录，里面有一个 <code>index.md</code> 文件；</li>
<li>在 <code>themes/next/_config.yml</code> 里的 <code>menu:</code> 下添加 <code>resume: /resume</code>，它会在首页创建一个新的 menu: resume 入口；</li>
<li>在 <code>index.md</code> 文件里填写自己的简历即可。</li>
</ol>
<h3 id="修改文章内链接的样式"><a href="#修改文章内链接的样式" class="headerlink" title="修改文章内链接的样式"></a>修改文章内链接的样式</h3><p>修改路径：<code>themes/next/sources/css/_common/components/post/post.styl</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.exturl &#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">  .fa &#123;</span><br><span class="line">    font-size: $font-size-small;</span><br><span class="line">    margin-left: 4px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文末感谢大家的阅读"><a href="#文末感谢大家的阅读" class="headerlink" title="文末感谢大家的阅读"></a>文末感谢大家的阅读</h3><ol>
<li>添加如下配置到 <code>themes/next/_config.yml</code></li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加 &quot;本文结束&quot; 标记</span></span><br><span class="line"><span class="attr">post_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>themes/next/layout/_partials/post</code> 下新建文件 <code>post-end-tag.swig</code>，并且添加如下内容：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center; color: #ccc; font-size:14px; padding: 10px 0&quot;</span>&gt;</span>-------------本文结束 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-paw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 感谢您的阅读-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加到 <code>themes/next/lauyout/_macro/post.swig</code> 文件中</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 END POST BODY 下面添加如下代码 --&gt;</span></span><br><span class="line">&#123;%- if theme.post_end_tag.enabled and not is_index %&#125;</span><br><span class="line">  &#123;&#123; partial(&#x27;_partials/post/post-end-tag.swig&#x27;) &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文章底部添加版权信息"><a href="#文章底部添加版权信息" class="headerlink" title="文章底部添加版权信息"></a>文章底部添加版权信息</h3><ol>
<li>在 <code>themes/next/layout/_macro</code> 目录下新建文件 <code>my-copyright.swig</code>，内容如下：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if page.copyright %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my_post_copyright&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/lib/jquery/index.js?v=2.1.3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>本文标题:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; page.title &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>文章作者:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">title</span>=<span class="string">&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;</span>&gt;</span>&#123;&#123; theme.author &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>发布时间:<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>最后更新:<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>原始链接:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; page.title &#125;&#125;&quot;</span>&gt;</span>&#123;&#123; page.permalink &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;copy-path&quot;</span>  <span class="attr">title</span>=<span class="string">&quot;点击复制文章链接&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-clipboard&quot;</span> <span class="attr">data-clipboard-text</span>=<span class="string">&quot;&#123;&#123; page.permalink &#125;&#125;&quot;</span>  <span class="attr">aria-label</span>=<span class="string">&quot;复制成功！&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>许可协议:<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-creative-commons&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">rel</span>=<span class="string">&quot;license&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">title</span>=<span class="string">&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;</span>&gt;</span>署名-非商业性使用-禁止演绎 4.0 国际<span class="tag">&lt;/<span class="name">a</span>&gt;</span> 转载请保留原文链接及作者。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> clipboard = <span class="keyword">new</span> Clipboard(<span class="string">&#x27;.fa-clipboard&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  $(<span class="string">&#x27;.fa-clipboard&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  clipboard.on(<span class="string">&#x27;success&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    swal(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">title</span>: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">text</span>: <span class="string">&#x27;复制成功&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">icon</span>: <span class="string">&quot;success&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">showConfirmButton</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>themes/next/source/css/_common/components/post/</code> 新建文件 <code>my-post-copyright.styl</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.my_post_copyright &#123;</span><br><span class="line">  width: 85%;</span><br><span class="line">  max-width: 45em;</span><br><span class="line">  margin: 2.8em auto 0;</span><br><span class="line">  padding: 0.5em 1.0em;</span><br><span class="line">  border: 1px solid #d3d3d3;</span><br><span class="line">  font-size: 0.93rem;</span><br><span class="line">  line-height: 1.6em;</span><br><span class="line">  word-break: break-all;</span><br><span class="line">  background: rgba(255,255,255,0.4);</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class="line">.my_post_copyright span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 5.2em;</span><br><span class="line">  color: #b5b5b5;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .raw &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  border-bottom:0;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a:hover &#123;</span><br><span class="line">  color: #a3d2a3;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .post-url:hover &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 1em;</span><br><span class="line">  +mobile()&#123;display:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path:hover &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改 <code>next/layout/_macro/post.swig</code> 文件，添加如下代码：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;% include &#x27;my-copyright.swig&#x27; %&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改 <code>next/sources/css/_common/components/post/post.styl</code> 文件，添加如下代码：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;my-post-copyright&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>若文章需要版权声明可添加 <code>copyright: true</code>。</li>
</ol>
<h3 id="Algolia-搜索服务"><a href="#Algolia-搜索服务" class="headerlink" title="Algolia 搜索服务"></a>Algolia 搜索服务</h3><ol>
<li><p>前往 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxnb2xpYS5jb20v">Algolia 注册页面<i class="fa fa-external-link-alt"></i></span>，注册一个新账户。 可以使用 GitHub 或者 Google 账户直接登录，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。注册完成后，创建一个新的 Index，这个 Index 将在后面使用。</p>
</li>
<li><p>Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 Hexo Algolia 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 Algolia 服务站点上找到需要使用的一些配置的值，包括 ApplicationID、Search-Only API Key、 Admin API Key。注意，Admin API Key 需要保密保存。点击 ALL API KEYS 找到新建 INDEX 对应的 key， 编辑权限，在弹出框中找到 ACL 选择勾选 Add records, Delete records, List indices, Delete index 权限，点击 update 更新。</li>
</ol>
<p>编辑 <code>站点配置文件</code>，新增以下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换除了 chunkSize 以外的其他字段为在 Algolia 获取到的值。</span></span><br><span class="line">algolia:</span><br><span class="line">  applicationID: <span class="string">&#x27;applicationID&#x27;</span></span><br><span class="line">  indexName: <span class="string">&#x27;indexName&#x27;</span></span><br><span class="line">  chunkSize: 5000</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>当配置完成，在站点根目录下执行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span>(windows 为 <span class="built_in">set</span>) HEXO_ALGOLIA_INDEXING_KEY=Search-Only API key</span><br><span class="line">hexo clean</span><br><span class="line">hexo algolia</span><br></pre></td></tr></table></figure>

<p>来更新 Index。请注意观察命令的输出。</p>
<ol start="5">
<li>更改主题配置文件，找到 Algolia Search 配置部分：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line">algolia_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  hits:</span><br><span class="line">    per_page: 10</span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search <span class="keyword">for</span> Posts</span><br><span class="line">    hits_empty: <span class="string">&quot;We didn&#x27;t find any results for the search: <span class="variable">$&#123;query&#125;</span>&quot;</span></span><br><span class="line">    hits_stats: <span class="string">&quot;<span class="variable">$&#123;hits&#125;</span> results found in <span class="variable">$&#123;time&#125;</span> ms&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="DaoVoice-实现在线联系"><a href="#DaoVoice-实现在线联系" class="headerlink" title="DaoVoice 实现在线联系"></a>DaoVoice 实现在线联系</h3><ol>
<li><span class="exturl" data-url="aHR0cDovL2Rhc2hib2FyZC5kYW92b2ljZS5pby9nZXQtc3RhcnRlZD9pbnZpdGVfY29kZT0yNTZjYzhiZA==">注册登录<i class="fa fa-external-link-alt"></i></span>填写邀请码（256cc8bd）。<br>完成注册后，修改 <code>themes/next/layout/_partials/head.swig</code> 添加下面的代码:</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  (<span class="function"><span class="keyword">function</span>(<span class="params">i, s, o, g, r, a, m</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    i[<span class="string">&#x27;DaoVoiceObject&#x27;</span>] = r;</span></span><br><span class="line"><span class="javascript">    (i[r] =</span></span><br><span class="line"><span class="javascript">      i[r] ||</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        (i[r].q = i[r].q || []).push(<span class="built_in">arguments</span>);</span></span><br><span class="line"><span class="javascript">      &#125;),</span></span><br><span class="line"><span class="javascript">      (i[r].l = <span class="number">1</span> * <span class="keyword">new</span> <span class="built_in">Date</span>());</span></span><br><span class="line"><span class="javascript">    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[<span class="number">0</span>]);</span></span><br><span class="line"><span class="javascript">    a.async = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    a.src = g;</span></span><br><span class="line"><span class="javascript">    a.charset = <span class="string">&#x27;utf-8&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    m.parentNode.insertBefore(a, m);</span></span><br><span class="line"><span class="javascript">  &#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>, <span class="string">&#x27;script&#x27;</span>, (<span class="string">&#x27;https:&#x27;</span> == <span class="built_in">document</span>.location.protocol ? <span class="string">&#x27;https:&#x27;</span> : <span class="string">&#x27;http:&#x27;</span>) + <span class="string">&#x27;//widget.daovoice.io/widget/&#123;&#123;theme.daovoice_app_id&#125;&#125;.js&#x27;</span>, <span class="string">&#x27;daovoice&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  daovoice(<span class="string">&#x27;init&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">app_id</span>: <span class="string">&#x27;&#123;&#123;theme.daovoice_app_id&#125;&#125;&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">  daovoice(<span class="string">&#x27;update&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改主题的配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Online contact</span></span><br><span class="line">daovoice: <span class="literal">true</span></span><br><span class="line">daovoice_app_id: 我们注册获取的id</span><br></pre></td></tr></table></figure>

<h3 id="添加腾讯空间-404-公益页面"><a href="#添加腾讯空间-404-公益页面" class="headerlink" title="添加腾讯空间 404 公益页面"></a>添加腾讯空间 404 公益页面</h3><p>新建 <code>404.html</code> 页面，将下面代码拷进去保存，放到主题的 <code>source</code> 目录下即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>404公益页面-宝贝回家志愿者协会-King Mui<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;180x180&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.kingmui.cn/avatar.jpg?v=6.5.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/png&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;32x32&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.kingmui.cn/avatar.jpg?v=6.5.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/png&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;16x16&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.kingmui.cn/avatar.jpg?v=6.5.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.mod_404</span> <span class="selector-class">.desc</span> <span class="selector-class">.desc_link</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-decoration</span>: none <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#4599ff</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.mod_404</span> <span class="selector-class">.desc</span> <span class="selector-class">.desc_link</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: <span class="number">#2e8cff</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/plain&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://www.qq.com/404/search_children.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">homePageUrl</span>=<span class="string">&quot;/&quot;</span> <span class="attr">homePageName</span>=<span class="string">&quot;回到我的主页&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/data.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/page.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="利用-Gulp-压缩代码"><a href="#利用-Gulp-压缩代码" class="headerlink" title="利用 Gulp 压缩代码"></a>利用 Gulp 压缩代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>),</span><br><span class="line">  imageminPngquant = <span class="built_in">require</span>(<span class="string">&#x27;imagemin-pngquant&#x27;</span>),</span><br><span class="line">  $ = <span class="built_in">require</span>(<span class="string">&#x27;gulp-load-plugins&#x27;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 html</span></span><br><span class="line">gulp.task(<span class="string">&#x27;html&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class="line">    .pipe($.htmlclean())</span><br><span class="line">    .pipe(</span><br><span class="line">      $.htmlmin(&#123;</span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>, <span class="comment">// 折叠有助于文档树中文本节点的空白区域</span></span><br><span class="line">        <span class="attr">minifyCSS</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minifyJS</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minifyURLs</span>: <span class="literal">true</span>, <span class="comment">// 使用 relatedurl 压缩各种属性中的 URL</span></span><br><span class="line">        <span class="attr">keepClosingSlash</span>: <span class="literal">true</span>, <span class="comment">// 单标签保留尾部斜杠</span></span><br><span class="line">        <span class="attr">removeAttributeQuotes</span>: <span class="literal">true</span>, <span class="comment">// 尽可能删除属性周围的引号</span></span><br><span class="line">        <span class="attr">removeEmptyAttributes</span>: <span class="literal">true</span>, <span class="comment">// 删除所有空格作属性值</span></span><br><span class="line">        <span class="attr">removeComments</span>: <span class="literal">true</span>, <span class="comment">// 清除HTML注释</span></span><br><span class="line">        <span class="attr">removeScriptTypeAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">removeStyleLinkTypeAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">useShortDoctype</span>: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩图片</span></span><br><span class="line">gulp.task(<span class="string">&#x27;image&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src(<span class="string">&#x27;./public/images/*&#x27;</span>)</span><br><span class="line">    .pipe(</span><br><span class="line">      $.cache(</span><br><span class="line">        $.imagemin(&#123;</span><br><span class="line">          <span class="attr">interlaced</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">progressive</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">optimizationLevel</span>: <span class="number">5</span>,</span><br><span class="line">          <span class="attr">svgoPlugins</span>: [&#123; <span class="attr">removeViewBox</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">          <span class="comment">// 使用pngquant深度压缩png图片的imagemin插件</span></span><br><span class="line">          <span class="attr">use</span>: [imageminPngquant()]</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./public/images/&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除缓存</span></span><br><span class="line">gulp.task(<span class="string">&#x27;clearCache&#x27;</span>, <span class="function">() =&gt;</span> $.cache.clearAll());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 css</span></span><br><span class="line"><span class="comment">// gulp.task(&#x27;css&#x27;, function() &#123;</span></span><br><span class="line"><span class="comment">//     return gulp.src(&#x27;./public/**/*.css&#x27;)</span></span><br><span class="line"><span class="comment">//         .pipe($.cleanCss(&#123;compatibility: &#x27;ie8&#x27;, debug: true&#125;, (details) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//             console.log(`$&#123;details.name&#125;: $&#123;details.stats.originalSize&#125;`);</span></span><br><span class="line"><span class="comment">//             console.log(`$&#123;details.name&#125;: $&#123;details.stats.minifiedSize&#125;`);</span></span><br><span class="line"><span class="comment">//           &#125;))</span></span><br><span class="line"><span class="comment">//         .pipe(gulp.dest(&#x27;./public&#x27;));</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 js</span></span><br><span class="line"><span class="comment">// gulp.task(&#x27;js&#x27;, function() &#123;</span></span><br><span class="line"><span class="comment">//     return gulp.src(&#x27;./public/**/*.js&#x27;)</span></span><br><span class="line"><span class="comment">//         .pipe($.uglify())</span></span><br><span class="line"><span class="comment">//         .pipe(gulp.dest(&#x27;./public&#x27;));</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;html&#x27;</span>]);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 的 Async/Await</title>
    <url>/2019/04/05/JavaScript%20%E7%9A%84%20Async%E5%92%8CAwait/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在过去很长的时间里，JavaScript 开发人员在处理异步代码时不得不依赖回调函数来解决。结果，我们中的很多人都经历过回调地域。</p>
<p>然后我们迎来了 Promise。他们为回调提供了更有组织的替代方案，并且大多数社区很快也都转而使用它们。</p>
<p>现在，随着最新添加的 Async / Await，我们终于可以编写更高质量的 JavaScript 代码！</p>
<h3 id="什么是-Async-Await？"><a href="#什么是-Async-Await？" class="headerlink" title="什么是 Async/Await？"></a>什么是 Async/Await？</h3><p>Async / Await 是一个备受期待的 JavaScript 功能，它使异步函数的使用更加愉快和易于理解。它构建在 Promise 之上，并与所有现有的基于 Promise 的 API 兼容。</p>
<p><strong>Async - 定义异步函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">someName</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自动把函数转换为 <code>Promise</code></li>
<li>当调用异步函数时，函数返回值会被 <code>resolve</code> 处理</li>
<li>异步函数内部可以使用 <code>await</code></li>
</ul>
<span id="more"></span>

<p><strong>Await - 暂停异步函数的执行</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> someAsyncCall();</span><br></pre></td></tr></table></figure>

<ul>
<li>当使用在 <code>Promise</code> 前面时，<code>await</code> 等待 <code>Promise</code> 完成，并返回 <code>Promise</code> 的结果</li>
<li><code>await</code> 只能和 <code>Promise</code> 一起使用，不能和 <code>callback</code> 一起使用</li>
<li><code>await</code> 只能用在 <code>async</code> 函数中</li>
</ul>
<p>假设我们想从服务器获取一些 JSON 文件。我们将编写一个使用 axios 库的函数，并将 HTTP GET 请求发送到 <code>https://tutorialzine.com/misc/files/example.json</code>。我们必须等待服务器响应，因此这个 HTTP 请求必然是异步的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise approach</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// To make the function blocking we manually create a Promise.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    axios.get(<span class="string">&#x27;https://tutorialzine.com/misc/files/example.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// The data from the request is available in a .then block</span></span><br><span class="line">      <span class="comment">// We return the result using resolve.</span></span><br><span class="line">      resolve(json);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async/Await approach</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// async 关键字将自动创建一个新的 Promise 并返回它</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getJSONAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await 关键字使我们不必编写 .then() 语句块。</span></span><br><span class="line">  <span class="keyword">let</span> json = <span class="keyword">await</span> axios.get(<span class="string">&#x27;https://tutorialzine.com/misc/files/example.json&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The result of the GET request is available in the json variable.</span></span><br><span class="line">  <span class="comment">// 我们就像在普通的同步函数中一样返回它</span></span><br><span class="line">  <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，使用 Async / Await 版本的代码更短，更容易阅读。除了使用的语法不同之外，两个函数功能完全相同，它们都返回 Promises 并使用 axios 的 JSON 响应来解析。我们可以这样调用我们的异步函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSONAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with result.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Async-Await-是否会取代-Promise"><a href="#Async-Await-是否会取代-Promise" class="headerlink" title="Async/Await 是否会取代 Promise"></a>Async/Await 是否会取代 Promise</h3><p>不会。当我们在使用 Async / Await 时，我们仍在使用 Promise，也就是说 <code>Async/Await</code> 底层依然使用了 <code>Promise</code>。从长远来看，对 Promises 的良好理解实际上对您很有帮助。</p>
<p>甚至有一些 Async / Await 用例并没有削减它，我们不得不回到 Promises 寻求帮助。 一个使用场景是当我们需要进行多个独立的异步调用并等待所有这些调用完成时。</p>
<p>如果我们尝试使用 async 和 await 执行此操作，将发生以下情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getABC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> A = <span class="keyword">await</span> getValueA(); <span class="comment">// getValueA 花费 2 秒</span></span><br><span class="line">  <span class="keyword">let</span> B = <span class="keyword">await</span> getValueB(); <span class="comment">// getValueB 花费 4 秒</span></span><br><span class="line">  <span class="keyword">let</span> C = <span class="keyword">await</span> getValueC(); <span class="comment">// getValueC 花费 3 秒</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> A * B * C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次遇到 <code>await</code> 关键字时，<code>Promise</code> 都会停下，一直到运行结束，所以总共花费是 2+4+3 = 9 秒。<code>await</code> 把异步变成了同步。</p>
<p>这不是最佳的解决方案，因为三个变量 A，B 和 C 不相互依赖。换句话说，在我们得到 B 之前，我们不需要知道 A 的值。所以我们可以并行得到它们并且等待几秒钟。</p>
<p>多个异步函数同时执行时，需要借助 <code>Promise.all</code>。这将确保在继续之前我们仍然拥有所有结果，但异步调用将并行触发，而不是一个接一个地触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getABC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Promise.all() 允许同时执行所有的异步函数</span></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getValueA, getValueB, getValueC]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> results.reduce(<span class="function">(<span class="params">total, value</span>) =&gt;</span> total * value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式将花费更少的时间。<code>getValueA</code> 和 <code>getValueC</code> 调用将在 <code>getValueB</code> 结束时完成。我们将有效地将执行时间减少到最慢请求的时间 4 秒（<code>getValueB</code> 的耗时），而不是时间的总和。</p>
<h3 id="Async-Await-的错误处理"><a href="#Async-Await-的错误处理" class="headerlink" title="Async/Await 的错误处理"></a>Async/Await 的错误处理</h3><p>在 Async/Await 语法中，我们可以使用 <code>try/catch</code> 进行错误处理。在 Promise 中的 <code>.catch()</code> 分支会进入 <code>catch</code> 语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomethingAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// This async call may fail.</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> someAsyncCall();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// If it does we will catch the error here.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 子句将处理由等待的异步调用或我们可能在 <code>try</code> 块内写入的任何其他失败代码所引发的错误。</p>
<p>如果有必要，我们也可以在执行异步函数时捕获错误。由于所有异步函数都返回 Promise，因此我们可以在调用它们时简单地包含一个 <code>.catch()</code> 事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Async function without a try/catch block.</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomethingAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// This async call may fail.</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> someAsyncCall();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We catch the error upon calling the function.</span></span><br><span class="line">doSomethingAsync().</span><br><span class="line">    .then(successHandler)</span><br><span class="line">    .catch(errorHandler);</span><br></pre></td></tr></table></figure>

<p>选择您喜欢的错误处理方法并坚持下去非常重要。同时使用 <code>try / catch</code> 和 <code>.catch()</code> 很可能会导致未知的问题。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><span class="exturl" data-url="aHR0cHM6Ly90dXRvcmlhbHppbmUuY29tLzIwMTcvMDcvamF2YXNjcmlwdC1hc3luYy1hd2FpdC1leHBsYWluZWQ=">JavaScript Async/Await Explained in 10 Minutes<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 函数式编程</title>
    <url>/2019/06/02/JavaScript-Functional-Programming/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>函数式编程风格起源于 20 世纪 30 年代 <code>lambda</code> 演算的发明。函数自 17 世纪诞生以来，一直是作为微积分的一部分而存在的。<strong>函数可以作为函数的参数传递，还可以作为函数的执行结果被返回</strong>。更复杂的函数被称为高阶函数，它可以精确的控制函数，既可以将函数当作参数传递，也可以将函数作为执行结果返回，或者二者兼而有之。在 20 世纪 30 年代，Alonzo Church 在普林斯顿大学用高阶函数做实验时发明了 <code>lambda</code> 演算。</p>
<p>20 世纪 50 年代初，John McCarthy 借鉴了 <code>lambda</code> 演算的概念，并将它应用到一门新的名为 Lisp 的编程语言上。Lisp 实现了高阶函数的概念，并<strong>将函数作为第一类成员或者第一类公民</strong>。一个函数被当作第一类成员时，它不仅可以被声明为一个变量，而且可以被当作函数参数传递。这些函数甚至可以作为函数的执行结果被返回。</p>
<h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>JavaScript 可以进行函数式编程，因为 JavaScript 中的函数就是第一类公民。这意味着<strong>变量可以做的事情函数同样也可以</strong>。ES6 标准中还添加了不少语言特性，可以帮助我们更充分地使用函数式编程技术，其中包括箭头函数、Promise 对象和扩展运算符等。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createScream = <span class="function"><span class="params">logger</span> =&gt;</span> <span class="function"><span class="params">message</span> =&gt;</span> logger(message.toUpperCase() + <span class="string">&#x27;!!!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意函数声明过程中使用箭头的数目，<strong>一个以上的箭头表示我们声明的是高阶函数</strong>。</p>
<p>我们可以说 JavaScript 就是函数式编程语言，因为它的函数是第一类成员。这意味着<strong>函数就是数据</strong>。它们可以像变量那样被保存、检索或者在应用程序内部传递。</p>
<h2 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h2><p>函数式编程还是更广义编程范式的一部分：声明式编程。</p>
<h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>声明式编程是一种编程风格，采用该风格的应用程序代码有一个比较突出的特点，那就是<strong>对执行结果的描述远胜于执行过程</strong>，即它关注的是你要做什么，而不是如何做。它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件。它没有描述控制流步骤。声明式编程的例子有 HTML、SQL 等。</p>
<p><strong>HTML file</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Declarative Programming<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>SQL file</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from studens where firstName = &#x27;declarative&#x27;;</span><br></pre></td></tr></table></figure>

<p>在一个声明式程序中，<strong>语法本身描述了将会发生什么，相关的执行细节被隐藏了</strong>。</p>
<p>声明式程序<strong>易于解释具体用途</strong>。因为其代码本身就描述了将会发生什么。</p>
<p>声明式方法更易读，因此也更方便解释具体用途。每个这类函数的具体实现细节都被封装起来。本质上来说，使用声明式编程编写的应用程序更容易解释具体用途，当一个应用易于解释具体用途时，该应用也更易于进行功能扩展。</p>
<h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><p>命令式编程风格的特点是，其代码重点关注的是<strong>达成目标的具体过程</strong>。需要辅以大量注释说明帮助用户理解它的具体用途。</p>
<p>下面是一个例子，数组中的每个元素都乘以 2，我们使用声明式 <code>map</code> 函数，让编译器来完成其余的工作。而使用命令式，需要编写所有的流程步骤。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式</span></span><br><span class="line"><span class="keyword">const</span> doubleWithDec = numbers.map(<span class="function"><span class="params">number</span> =&gt;</span> number * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令式</span></span><br><span class="line"><span class="keyword">const</span> doubleWithImp = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> numberdouble = numbers[i] * <span class="number">2</span>;</span><br><span class="line">  doubleWithImp.push(numberdouble);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式编程基本概念"><a href="#函数式编程基本概念" class="headerlink" title="函数式编程基本概念"></a>函数式编程基本概念</h2><p>函数式编程是声明式编程的一部分。JavaScript 中的函数是第一类公民，这意味着函数是数据，你可以像保存变量一样在应用程序中保存、检索和传递这些函数。</p>
<p>函数式编程有些核心的概念，如下：</p>
<ul>
<li>不可变性（Immutability）</li>
<li>纯函数（Pure Functions）</li>
<li>数据转换（Data Transformations）</li>
<li>高阶函数（Higher-Order Functions）</li>
<li>递归</li>
<li>组合</li>
</ul>
<h3 id="不可变性（Immutability）"><a href="#不可变性（Immutability）" class="headerlink" title="不可变性（Immutability）"></a>不可变性（Immutability）</h3><p>不可变性就是指不可改变。在函数式编程中，<strong>数据是不可变的，它们永远无法修改</strong>。如果要改变或更改数据，则必须复制数据副本来更改。在不修改原生数据结构的前提下，我们在这些数据结构的拷贝上进行编辑，并使用它们取代原生的数据。</p>
<p>例如，这是一个 <code>student</code> 对象和 <code>changeName</code> 函数，如果要更改学生的名称，则需要先复制 <code>student</code> 对象，然后返回新对象。</p>
<p>在 JavaScript 中，函数参数是对实际数据的引用，你不应该使用 <code>student.firstName = &#39;testing11&#39;</code>，这会改变实际的 <code>student</code> 对象，应该使用 <code>Object.assign</code> 复制对象并返回新对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> student = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;testing&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;testing&#x27;</span>,</span><br><span class="line">  <span class="attr">marks</span>: <span class="number">500</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeName</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// student.firstName = &quot;testing11&quot; //should not do it</span></span><br><span class="line">  <span class="keyword">let</span> copiedStudent = <span class="built_in">Object</span>.assign(&#123;&#125;, student);</span><br><span class="line">  copiedStudent.firstName = <span class="string">&#x27;testing11&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> copiedStudent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(changeName(student));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(student);</span><br></pre></td></tr></table></figure>

<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>纯函数是一个<strong>返回结果只依赖于输入参数</strong>的函数。纯函数<strong>至少需要接收一个参数</strong>并且<strong>总是返回一个值或者其他函数</strong>。它们<strong>不会产生副作用，不修改全局变量</strong>，或者任何应用程序的 <code>state</code>。它们将输入的参数当作不可变数据。</p>
<p><strong>纯函数的可测试性</strong></p>
<blockquote>
<p>纯函数天生是可测试的。它们不会改变执行环境或者“世界”中的任何东西，因此不需要装配或者卸载复杂的测试环境。纯函数需要访问的任意数据都是通过参数进行传递的。当测试一个纯函数时，用户控制着参数，因此也可以预估执行结果。</p>
</blockquote>
<p>纯函数是函数式编程中的另外一个核心概念。它会使你的开发工作更容易，因为它们不会影响应用程序的状态。当编写函数时，请务必遵循以下三条规则：</p>
<ol>
<li>函数应该至少接收一个参数</li>
<li>函数应该返回一个值或者其他函数</li>
<li>函数不应该修改或者影响任何传给它的参数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> student = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;testing&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;testing&#x27;</span>,</span><br><span class="line">  <span class="attr">marks</span>: <span class="number">500</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非纯函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendAddress</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  student.address = &#123; <span class="attr">streetNumber</span>: <span class="string">&#x27;0000&#x27;</span>, <span class="attr">streetName</span>: <span class="string">&#x27;first&#x27;</span>, <span class="attr">city</span>: <span class="string">&#x27;somecity&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(appendAddress());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendAddress</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> copystudent = <span class="built_in">Object</span>.assign(&#123;&#125;, student);</span><br><span class="line">  copystudent.address = &#123; <span class="attr">streetNumber</span>: <span class="string">&#x27;0000&#x27;</span>, <span class="attr">streetName</span>: <span class="string">&#x27;first&#x27;</span>, <span class="attr">city</span>: <span class="string">&#x27;somecity&#x27;</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> copystudent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(appendAddress(student));</span><br><span class="line"><span class="built_in">console</span>.log(student);</span><br></pre></td></tr></table></figure>

<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>如果数据是不可变的，那么应用程序内部如何进行状态转换呢？函数式编程的做法是将一种数据转换为另外一种数据。我们使用函数生成转换后的副本。这些函数使得命令式的代码更少，并且大大降低了复杂度。</p>
<p>用户不需要通过一个特定的框架来了解如何从一种数据集转换到另外一种。JavaScript 语言已经内置了完成该任务所需的工具，如 <code>Array.map</code>、<code>Array.reduce</code>、<code>Array.join</code>、<code>Array.filter</code>等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cities = [<span class="string">&#x27;irving&#x27;</span>, <span class="string">&#x27;lowell&#x27;</span>, <span class="string">&#x27;houston&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// we can get the comma separated list</span></span><br><span class="line"><span class="built_in">console</span>.log(cities.join(<span class="string">&#x27;,&#x27;</span>));</span><br><span class="line"><span class="comment">// irving,lowell,houston</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if we want to get cities start with i</span></span><br><span class="line"><span class="keyword">const</span> citiesI = cities.filter(<span class="function"><span class="params">city</span> =&gt;</span> city[<span class="number">0</span>] === <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(citiesI);</span><br><span class="line"><span class="comment">// [ &#x27;irving&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if we want to capitalize all the cities</span></span><br><span class="line"><span class="keyword">const</span> citiesC = cities.map(<span class="function"><span class="params">city</span> =&gt;</span> city.toUpperCase());</span><br><span class="line"><span class="built_in">console</span>.log(citiesC);</span><br><span class="line"><span class="comment">// [ &#x27;IRVING&#x27;, &#x27;LOWELL&#x27;, &#x27;HOUSTON&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数的使用对于函数式编程也是必不可少的。高阶函数是可以操作其他函数的函数。它们可以将函数当作参数传递，也可以返回一个函数，或者二者兼而有之。</p>
<p>柯里化（Currying）是一种采用了高阶函数的函数式编程技巧。柯里化实际上是一种将某个操作中已经完成的结果保留，直到其余部分后续也完成后可以一并提供的机制。这是通过在一个函数中返回另外一个函数实现的，即柯里函数。</p>
<p>下面是一个柯里化的例子。函数 <code>userLogs</code> 会保存一些信息（username），在其余的信息（message）可用时返回一个函数方便其他函数调用或复用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userLogs = <span class="function"><span class="params">userName</span> =&gt;</span> <span class="function"><span class="params">message</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;userName&#125;</span> -&gt; <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> log = userLogs(<span class="string">&#x27;grandpa23&#x27;</span>);</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;attempted to load 20 fake members&#x27;</span>);</span><br><span class="line"></span><br><span class="line">getFakeMembers(<span class="number">20</span>).then(<span class="function"><span class="params">members</span> =&gt;</span> log(<span class="string">`successfully loaded <span class="subst">$&#123;member.length&#125;</span> members`</span>), <span class="function"><span class="params">error</span> =&gt;</span> log(<span class="string">&#x27;encountered an error loading members&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归是用户创建的函数调用自身的一种技术。一般来说，在解决实际问题涉及到循环时，递归函数可以提供一种替代性的方案。<strong>只要可能，最好使用递归而不是循环</strong>。</p>
<p><strong>浏览器堆栈调用的不足之处</strong></p>
<blockquote>
<p>应该尽可能地使用递归解决循环有关的问题。不过并非所有 JavaScript 引擎都对大量的递归调用做了性能优化。过多的递归调用会导致 JavaScript 报错。可以通过一些高级技术清理调用堆栈并停止递归调用来避免这些错误。未来的 JavaScript 引擎预计会完全解决调用堆栈的不足。</p>
</blockquote>
<p>下面是一个演示递归的例子，在这个递归中，打印一个类似于楼梯的名称。我们也可以使用 <code>for</code> 循环，但只要可能，我们更喜欢递归。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMyName</span>(<span class="params">name, count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= name.length) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name.substring(<span class="number">0</span>, count));</span><br><span class="line">    printMyName(name, ++count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printMyName(<span class="string">&#x27;Bhargav&#x27;</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">Bh</span></span><br><span class="line"><span class="comment">Bha</span></span><br><span class="line"><span class="comment">Bhar</span></span><br><span class="line"><span class="comment">Bharg</span></span><br><span class="line"><span class="comment">Bharga</span></span><br><span class="line"><span class="comment">Bhargav</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// without recursion</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Bhargav&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> output = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; name.length; i++) &#123;</span><br><span class="line">  output = output + name[i];</span><br><span class="line">  <span class="built_in">console</span>.log(output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21xeXFpbmdmZW5nL0Jsb2cvaXNzdWVzLzQ1">JavaScript 专题之函数组合<i class="fa fa-external-link-alt"></i></span></p>
<p>在 React 中，我们将功能划分为小型可重用的纯函数，我们必须将所有这些可重用的函数放在一起，最终使其成为产品。将所有较小的函数组合成更大的函数，最终，得到一个应用程序，这称为合成。</p>
<p>函数式编程会将具体的业务逻辑<strong>拆分成小型的纯函数</strong>，以便能够将精力聚焦于特定任务。最终，用户将会需要把这些小型函数整合到一起。具体来说，用户可能需要合成它们，以串联或者并联的方式对它们进行调用，或者将它们合成为一个更大的函数，直到构造出一个应用程序为止。</p>
<p>对于合成来说，与之有关的实现、模式和技术真可谓五花八门。我们比较熟悉的一种方式就是链式调用。在 JavaScript 中，函数可以使用点符号连接在一起，其作用是获得上一个函数的返回值。</p>
<p>字符串有一个 <code>replace</code> 方法，该方法返回的模板字符串也包含一个 <code>replace</code> 方法。因此我们可以在转换一个字符时使用点符号将 <code>replace</code> 方法串联起来实现链式调用。</p>
<p>链式调用只是合成技术之一。合成的目标是<strong>通过整合若干简单函数构造一个更高阶的函数</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Bhargav Bachina&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = name</span><br><span class="line">  .split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  .filter(<span class="function"><span class="params">name</span> =&gt;</span> name.length &gt; <span class="number">5</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    val = val.toUpperCase();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Name:::::&#x27;</span> + val);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Count::::&#x27;</span> + val.length);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br></pre></td></tr></table></figure>

<p>在 React 中，我们使用了不同于链接的方法，因为如果有 30 个这样的函数，就很难进行链接。这里的目的是将所有更简单的函数组合起来生成一个更高阶的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = compose(</span><br><span class="line">  splitmyName,</span><br><span class="line">  countEachName,</span><br><span class="line">  comvertUpperCase,</span><br><span class="line">  returnName</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure>

<p>underscore 中的 compose 函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">var</span> start = args.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = start;</span><br><span class="line">    <span class="keyword">var</span> result = args[start].apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">while</span> (i--) result = args[i].call(<span class="built_in">this</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三个简单的规则"><a href="#三个简单的规则" class="headerlink" title="三个简单的规则"></a>三个简单的规则</h3><ol>
<li>保持数据的不可变性</li>
<li>确保尽量使用纯函数，只接收一个参数，返回数据或者其他函数</li>
<li>尽量使用递归处理循环（如果有可能的话）</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript如何使用变量设置对象的键名</title>
    <url>/2018/06/19/JavaScript%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%AE%E5%90%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>&#123;thetop: 10&#125;</code> 是一个有效的对象字面量。代码将创建一个属性名为 <code>thetop</code> 且值为 <code>10</code> 的对象。与以下内容相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj = &#123;<span class="attr">thetop</span>: <span class="number">10</span>&#125;;</span><br><span class="line">obj = &#123;<span class="string">&quot;thetop&quot;</span>: <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>在 ES5 及更早版本中，你<mark class="label info">不能直接在对象字面量中使用变量作为属性名称</mark>。唯一的选择是执行以下操作：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thetop = <span class="string">&quot;top&quot;</span>;</span><br><span class="line"><span class="comment">// 创建对象字面量</span></span><br><span class="line"><span class="keyword">var</span> aniArgs = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将变量属性名称赋值为 10</span></span><br><span class="line">aniArgs[thetop] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>ES6 将 <code>ComputedPropertyName</code> <span class="exturl" data-url="aHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC1pbml0aWFsaXplcg==">定义<i class="fa fa-external-link-alt"></i></span>为对象字面量语法的一部分，这允许你像这样编写代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> thetop = <span class="string">&quot;top&quot;</span>,</span><br><span class="line">	obj = &#123; [thetop]: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.top); <span class="comment">// -&gt; 10</span></span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjI3NDI0Mi9ob3ctdG8tdXNlLWEtdmFyaWFibGUtZm9yLWEta2V5LWluLWEtamF2YXNjcmlwdC1vYmplY3QtbGl0ZXJhbA==">来源<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript并非所有的东西都是对象</title>
    <url>/2018/01/19/JavaScript%E5%B9%B6%E9%9D%9E%E6%89%80%E6%9C%89%E7%9A%84%E4%B8%9C%E8%A5%BF%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>虽然很多语言宣称：“一切皆是对象”，但在 javascript 中，并不是所有的值都是对象。这篇博文解释了 javascript 中的两种值类型：原始值（primitive）和对象（object），以及混合使用两种类型时的注意事项。</p>
</div>

<h3 id="原始值-vs-对象"><a href="#原始值-vs-对象" class="headerlink" title="原始值 vs 对象"></a>原始值 vs 对象</h3><p>javascript 中的值可以被划分为两大类：原始值（primitive）和对象（object）。</p>
<p><strong>下面的值是原始值。</strong></p>
<ol>
<li>字符串</li>
<li>数字：在 JavaScript 中所有的数字都是浮点数</li>
<li>布尔值</li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ol>
<span id="more"></span>

<p><strong>所有其它的值都是对象（object）</strong>。对象可以进一步划分：</p>
<ol>
<li>原始值的包装器：<code>Boolean</code>, <code>Number</code>, <code>String</code>。</li>
<li>用字面量创建的对象。下面的字面量产生对象，也可以通过构造函数创建对象。</li>
</ol>
<ul>
<li><code>[]</code> 就是 <code>new Array()</code></li>
<li><code>&#123;&#125;</code> 就是 <code>new Object()</code></li>
<li><code>function() &#123;&#125;</code> 就是 <code>new Function()</code></li>
<li><code>/\s*/</code> 就是 <code>new RegExp(&quot;\\s*&quot;)</code></li>
</ul>
<ol start="3">
<li>日期：<code>new Date()</code></li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>对象是可变的。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.foo = <span class="number">123</span>; <span class="comment">// 添加属性和值</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line">obj.foo; <span class="comment">// 读属性，返回属性的值</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>每个对象都有自己唯一的标识符，因此通过字面量或构造函数创建的对象和任何其他对象都不相等，我们可以通过 <code>===</code> 进行比较。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#125; === &#123;&#125;; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>对象是通过引用来比较的，只有两个对象有相同的标识，才认为这个对象是相等的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj === obj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>变量保存了对象的引用。因此，如果两个变量引用了相同的对象，我们改变其中一个变量时，另一个也会随之改变。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> var2 = var1;</span><br><span class="line"></span><br><span class="line">var1.foo = <span class="number">123</span>; <span class="comment">// 修改变量 val1 的属性</span></span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line">var2.foo; <span class="comment">// val2 也改变了</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>正如预期的那样，原始值和对象不一样：</p>
<ul>
<li>原始值是不可变的，你不能给它们添加属性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">str.foo = <span class="number">123</span>; <span class="comment">// 添加属性（此操作将被忽略）</span></span><br><span class="line">str.foo; <span class="comment">// 读属性的值，返回 undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>原始值没有内部标识，原始值是按值比较的：比较两个原始值的依据是他们的内容，如果两个原始值的内容相同，就认为这两个原始值相同。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span> === <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这意味着，一个原始值的标识就是它的值，javascript 引擎没有为原始值分配唯一标识。</p>
<h3 id="陷阱：原始值和它们的包装类型"><a href="#陷阱：原始值和它们的包装类型" class="headerlink" title="陷阱：原始值和它们的包装类型"></a>陷阱：原始值和它们的包装类型</h3><p>原始值类型 <code>boolean</code>, <code>number</code> 以及 <code>string</code> 都有自己对应的包装类型 <code>Boolean</code>, <code>Number</code> 和 <code>String</code>。包装类型的实例都是对象值，两种类型之间的转换也很简单：</p>
<ul>
<li>转换为包装类型：<code>new String(&quot;abc&quot;)</code></li>
<li>转换为原始类型：<code>new String(&quot;abc&quot;).valueOf()</code></li>
</ul>
<p><strong>原始值类型以及它们相应的包装器类型有很多不同点</strong>，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<p><strong>包装类型的实例是一个对象</strong>，因此和 JavaScript 对象一样，包装类型也无法进行值的比较（只能比较引用）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">a == b; <span class="comment">// false</span></span><br><span class="line">a == a; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="原始值没有自己的方法"><a href="#原始值没有自己的方法" class="headerlink" title="原始值没有自己的方法"></a>原始值没有自己的方法</h3><p>包装对象类型很少被直接使用，但它们的原型对象定义了许多其对应的原始值也可以调用的方法。 例如，<code>String.prototype</code> 是包装类型 <code>String</code> 的原型对象。它的所有方法都可以使用在字符串原始值上。包装类型的方法 <code>String.prototype.indexOf</code> 在字符串原始值上也有，它们并不是两个拥有相同名称的方法，而的的确确就是同一个方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.charAt === <span class="built_in">String</span>.prototype.charAt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在数字的包装类型 <code>Number</code> 的原型对象上有 <code>toFixed</code> 方法，即 <code>Number.prototype.toFixed</code>，但是当我们写如下代码时却发生错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">5.</span>toFixed(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<p>此错误是解析错误（SyntaxError），5 后面跟着一个点号（.），这个点被当作了小数点，而小数点后面应该是一个数，以下代码可以正常运行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="number">5</span>).toFixed(<span class="number">3</span>); <span class="comment">// &quot;5.000&quot;</span></span><br><span class="line"><span class="comment">// 5..toFixed(3)</span></span><br><span class="line"><span class="comment">// &quot;5.000&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="值的分类：typeof-和-instanceof"><a href="#值的分类：typeof-和-instanceof" class="headerlink" title="值的分类：typeof 和 instanceof"></a>值的分类：<code>typeof</code> 和 <code>instanceof</code></h3><p>如果你想要对值进行分类，你需要注意原始值和对象之间的区别。<code>typeof</code> 运算符可以用来区分原始值和对象。<code>instanceof</code> 可以用来区分对象。而且，<code>instanceof</code> 对于所有的原始值都返回 <code>false</code>。</p>
<p><strong>typeof 运算符</strong></p>
<p><code>typeof</code> 可以用来判断原始值的类型，以及区分对象值和原始值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>typeof</code> 返回以下字符串：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>null</td>
<td>“object”</td>
</tr>
<tr>
<td>布尔值</td>
<td>“boolean”</td>
</tr>
<tr>
<td>数字</td>
<td>“number”</td>
</tr>
<tr>
<td>字符串</td>
<td>“string”</td>
</tr>
<tr>
<td>函数</td>
<td>“function”</td>
</tr>
<tr>
<td>其他</td>
<td>“object”</td>
</tr>
</tbody></table>
<p>注释：</p>
<ul>
<li><code>typeof</code> 在操作 <code>null</code> 时会返回 <code>&quot;object&quot;</code>，这是 JavaScript 语言本身的 bug。不幸的是，这个 bug 永远不可能被修复了，因为太多已有的代码已经依赖了这样的表现。这并不意味着，<code>null</code> 实际上就是一个对象。</li>
<li><code>typeof</code> 还可以<strong>检查一个变量是否已声明</strong>，而不会抛出异常。没有任何一个函数可以实现此功能，因为你不能把一个未声明的变量传递给函数的参数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclaredVariable</span><br><span class="line"><span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line">undeclaredVariable</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: undeclaredVariable is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数也是对象类型。这可能是很多人无法理解的，但有时候却是非常有用的。</li>
<li>数组是一个对象。</li>
</ul>
<p><strong>instanceof 运算符</strong></p>
<p>在 JavaScript 中，判断一个变量的类型尝尝会用 <code>typeof</code> 运算符，在使用 <code>typeof</code> 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “<code>object&quot;</code>。ECMAScript 引入了另一个 Java 运算符 <code>instanceof</code> 来解决这个问题。<code>instanceof</code> 运算符与 <code>typeof</code> 运算符相似，用于识别正在处理的对象的类型。与 <code>typeof</code> 方法不同的是，<code>instanceof</code> 方法要求开发者明确地确认对象为某特定类型。</p>
<p>通常来讲，使用 <code>instanceof</code> 就是判断一个实例是否属于某种类型。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">value <span class="keyword">instanceof</span> Constructor</span><br></pre></td></tr></table></figure>

<p>如果上面的表达式返回 <code>true</code>，则表示 <code>value</code> 是 <code>Constructor</code> 的一个实例。它等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Constructor.prototype.isPrototypeOf(value)</span><br></pre></td></tr></table></figure>

<p>大多数对象是 <code>Object</code> 的实例，因为原型链的末端（prototype chain）是 <code>Object.prototype</code>。原始值不是任何对象的实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>instanceof</code> <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi93ZWIvMTMwNl9qaWFuZ2pqX2pzaW5zdGFuY2VvZi8=">复杂用法<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> Foo); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>原文：<span class="exturl" data-url="aHR0cDovLzJhbGl0eS5jb20vMjAxMS8wMy9qYXZhc2NyaXB0LXZhbHVlcy1ub3QtZXZlcnl0aGluZy1pcy5odG1s">JavaScript values: not everything is an object<i class="fa fa-external-link-alt"></i></span></p>
<p>译文：<span class="exturl" data-url="aHR0cHM6Ly9qdXN0amF2YWMuY29tL2phdmFzY3JpcHQvMjAxMi8xMi8yMi9qYXZhc2NyaXB0LXZhbHVlcy1ub3QtZXZlcnl0aGluZy1pcy1hbi1vYmplY3QuaHRtbA==">JavaScript 并非所有的东西都是对象<i class="fa fa-external-link-alt"></i></span></p>
<p>译者：<span class="exturl" data-url="aHR0cDovL3dlaWJvLmNvbS9qdXN0amF2YWM=">justjavac<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式</title>
    <url>/2019/03/27/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案</p>
</div>

<p>当然我们可以用一个通俗的说法：设计模式是<strong>解决某个特定场景下对某种问题的解决方案</strong>。因此，当我们遇到合适的场景时，我们可能会条件反射一样自然而然想到符合这种场景的设计模式。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><div class="note default"><p>单例模式的定义：<strong>保证一个类仅有一个实例</strong>，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</p>
</div>

<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUser</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.getName();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理实现单例模式</span></span><br><span class="line"><span class="keyword">var</span> ProxyMode = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> CreateUser(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 测试单体模式的实例</span></span><br><span class="line"><span class="keyword">var</span> a = ProxyMode(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = ProxyMode(<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="comment">// 因为单体模式是只实例化一次，所以下面的实例是相等的</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><div class="note default"><p>策略模式的定义：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。</p>
</div>

<p>策略模式的目的就是将算法的实现分离开来。</p>
<p>一个基于策略模式的程序至少由两部分组成。第一个部分是一组<strong>策略类</strong>（可变），策略类<strong>封装了具体的算法</strong>，并负责具体的计算过程。第二个部分是<strong>环境类 Context</strong>（不变），Context 接受客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明 Context 中要维持对某个策略对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略类</span></span><br><span class="line"><span class="keyword">var</span> levelObj = &#123;</span><br><span class="line">  <span class="function"><span class="title">A</span>(<span class="params">money</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> money * <span class="number">4</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">B</span>(<span class="params">money</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> money * <span class="number">3</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">C</span>(<span class="params">money</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> money * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 环境类</span></span><br><span class="line"><span class="keyword">var</span> calculateBouns = <span class="function"><span class="keyword">function</span>(<span class="params">level, money</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> levelObj[level](money);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(calculateBouns(<span class="string">&#x27;A&#x27;</span>, <span class="number">10000</span>)); <span class="comment">// 40000</span></span><br></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><div class="note default"><p>代理模式的定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。</p>
</div>

<p>常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载）</p>
<p>图片懒加载的方式：先通过一张 loading 图占位，然后通过异步的方式加载原图，等原图加载好了再把图片加载到 <code>img</code> 标签里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> imgFunc = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      imgNode.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    imgFunc.setSrc(<span class="built_in">this</span>.src);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">setSrc</span>: <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      imgFunc.setSrc(<span class="string">&#x27;./loading,gif&#x27;</span>);</span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyImage.setSrc(<span class="string">&#x27;./pic.png&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>使用代理模式实现图片懒加载的优点还有符合单一职责原则。减少一个类或方法的粒度和耦合度。</p>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><div class="note default"><p>中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以<strong>解除对象与对象之间的紧耦合关系</strong>。</p>
</div>

<p>例如：现实生活中，航线上的飞机只需要和机场的塔台通信就能确定航线和飞行状态，而不需要和所有飞机通信。同时塔台作为中介者，知道每架飞机的飞行状态，所以可以安排所有飞机的起降和航线安排。</p>
<p>中介者模式适用的场景：例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发 <code>change</code> 事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">  <span class="comment">//手机库存</span></span><br><span class="line">  <span class="string">&#x27;red|32G&#x27;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&#x27;red|64G&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;blue|32G&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">  <span class="string">&#x27;blue|64G&#x27;</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> colorSelect = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;colorSelect&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> memorySelect = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;memorySelect&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> numSelect = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;numSelect&#x27;</span>);</span><br><span class="line"><span class="comment">//中介者</span></span><br><span class="line"><span class="keyword">var</span> mediator = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">changed</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">case</span> colorSelect:</span><br><span class="line">          <span class="comment">//TODO</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> memorySelect:</span><br><span class="line">          <span class="comment">//TODO</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> numSelect:</span><br><span class="line">          <span class="comment">//TODO</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">colorSelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  mediator.changed(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">memorySelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  mediator.changed(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">numSelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  mediator.changed(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><div class="note default"><p>装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。</p>
</div>

<p>例如：现有 4 种型号的自行车分别被定义成一个单独的类，如果给每辆自行车都加上前灯、尾灯、铃铛这 3 个配件，如果用类继承的方式，需要创建 <code>4*3=12</code> 个子类。但如果通过装饰者模式，只需要创建 3 个类。</p>
<p>装饰者模式适用的场景：原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性。</p>
<p>例：用 AOP 装饰函数实现装饰者模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>; <span class="comment">// 保存原函数引用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回包含了原函数和新函数的 &#x27;代理函数&#x27;</span></span><br><span class="line">    beforefn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，修正 this</span></span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = self.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    afterfn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// func1 和 func3 为挂载函数</span></span><br><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func = func.before(func1).after(func3);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWRmNGY3NGYyNjVkYTQzMGYzMTE5MDk=">JavaScript 设计模式<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 执行机制</title>
    <url>/2018/11/15/Javascript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="关于-Javascript"><a href="#关于-Javascript" class="headerlink" title="关于 Javascript"></a>关于 Javascript</h3><p>Javascript 是一门<strong>单线程</strong>语言，在最新的 HTML5 中提出了 <span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTgvMDcvd2ViLXdvcmtlci5odG1s">Web-Worker<i class="fa fa-external-link-alt"></i></span>，但 Javascript 是单线程这一核心仍未改变。所以一切的 Javascript 版“多线程”都是用单线程模拟出来的！</p>
<h3 id="Javascript-事件循环"><a href="#Javascript-事件循环" class="headerlink" title="Javascript 事件循环"></a>Javascript 事件循环</h3><p>既然 JS 是单线程语言，那么就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理 JS 任务也要一个一个的按顺序执行。如果一个任务耗时过长，那么后一个任务就必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全加载出来吗？因此聪明的程序员将任务分为两类：</p>
<span id="more"></span>

<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：</p>
<ol>
<li>同步任务和异步任务分别进入不同的执行“场所”。同步任务进入<strong>主线程</strong>，异步任务进入 <code>Event Table</code> 并注册函数</li>
<li>当指定的任务完成时，<code>Event Table</code> 会将这个函数移入 <code>Event Queue</code></li>
<li>当主线程内的任务执行完毕，会去 <code>Event Queue</code> 读取对应的函数，进入主线程执行</li>
<li>上述过程会不断重复，也就是常说的 <code>Event Loop</code> (事件循环)</li>
</ol>
<p><img data-src="http://cdn.kingmui.cn/javascript_event_queue_2.webp"></p>
<p>我们不禁要问了，那怎么知道主线程执行栈为空啊？JS 引擎存在 <code>monitoring process</code> 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 <code>Event Queue</code> 那里检查是否有等待被调用的函数。</p>
<p>举个🌰</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;www.javascript.com&#x27;</span>,</span><br><span class="line">  data,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;发送成功!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面是一段简易的 Ajax 请求代码：</p>
<ol>
<li>Ajax 进入 <code>Event Table</code>，注册回调函数 <code>success</code></li>
<li>执行 <code>console.log(&#39;代码执行结束&#39;)</code></li>
<li>Ajax 事件完成，回调函数 <code>success</code> 进入 <code>Event Queue</code></li>
<li>主线程从 <code>Event Queue</code> 读取回调函数 <code>success</code> 并执行</li>
</ol>
<h3 id="又爱又恨的-setTimeout"><a href="#又爱又恨的-setTimeout" class="headerlink" title="又爱又恨的 setTimeout"></a>又爱又恨的 setTimeout</h3><p>大名鼎鼎的 <code>setTimeout</code> 无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时 3 秒执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;延时3秒&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>渐渐的 <code>setTimeout</code> 用的地方多了，问题也出现了，有时候明明写的延时 3 秒，实际却 5，6 秒才执行函数，这又是怎么回事呢？</p>
<p>先看个🌰</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  task();</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;执行console&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>根据前面我们的结论，<code>setTimeout</code> 是异步的，应该先执行 <code>console.log</code> 这个同步任务，所以我们的结论是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行console</span></span><br><span class="line"><span class="comment"># task()</span></span><br></pre></td></tr></table></figure>

<p>然后我们修改一下前面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  task();</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">10000000</span>);</span><br></pre></td></tr></table></figure>

<p>乍一看其实差不多嘛，但我们把这段代码在 Chrome 执行一下，却发现控制台执行 <code>task()</code> 需要的时间远远超过 3 秒，说好的延时三秒，为什么现在需要这么长的时间啊？</p>
<p>这时候我们需要重新理解 <code>setTimeout</code> 的定义。我们先说上述代码是怎么执行的：</p>
<ol>
<li><code>task()</code> 进入 <code>Event Table</code> 并注册，计时开始</li>
<li>执行 <code>sleep</code> 函数，很慢…很慢…非常慢，计时仍在继续</li>
<li>3 秒到了，计时事件 <code>timeout</code> 完成，<code>task()</code> 进入 <code>Event Queue</code>，但是 <code>sleep</code> 也太慢了吧，还没执行完，只好等着</li>
<li><code>sleep</code> 终于执行完了，<code>task()</code> 终于从 <code>Event Queue</code> 进入了主线程执行</li>
</ol>
<p>上述的流程走完，我们知道 <code>setTimeout</code> 这个函数，是<strong>经过指定时间后，把要执行的任务加入到 <code>Event Queue</code> 中</strong>，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于 3 秒。</p>
<p>我们还经常遇到 <code>setTimeout(fn, 0)</code> 这样的代码，0 秒后执行又是什么意思呢？是不是可以立即执行呢？</p>
<p>答案是不会的，<code>setTimeout(fn, 0)</code> 的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。</p>
<p>关于 <code>setTimeout</code> 要补充的是，即便主线程为空，0ms 实际上也是达不到的。根据 HTML 的标准，最低是 4ms。</p>
<h4 id="使用-setTimeout-的注意事项"><a href="#使用-setTimeout-的注意事项" class="headerlink" title="使用 setTimeout 的注意事项"></a>使用 setTimeout 的注意事项</h4><ul>
<li><p><strong>如果当前任务执行时间过久，会影延迟到期定时器任务的执行</strong></p>
</li>
<li><p><strong>使用 setTimeout 设置的回调函数中的 this 环境不是指向回调函数</strong></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">test</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.test);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.showName, <span class="number">1000</span>);</span><br><span class="line">obj.showName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先输出 2 1</span></span><br><span class="line"><span class="comment">// 1s后输出 1 undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>未激活的页面，setTimeout 执行最小间隔是 1000ms</strong></li>
</ul>
<p>如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000ms，目的是为了优化后台页面的加载损耗以及降低耗电量。</p>
<ul>
<li><strong>延时执行时间有最大值</strong></li>
</ul>
<p>Chrome、Safari、Firefox 都是以 32 bit 来存储延时值的，32 bit 最大只能存放的数字是 2147483647（2**31-1），这就意味着，如果 setTimeout 设置的延时值大于 2147483647ms（大约 24.8 天）时就会溢出，这将导致定时器会被立即执行。</p>
<ul>
<li><strong>setTimeout 存在嵌套调用问题</strong></li>
</ul>
<p>如果 setTimeout 存在嵌套调用，调用超过 5 次后，系统会设置最短执行时间间隔为 4ms。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> endTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;cost time&#x27;</span>, endTime - startTime);</span><br><span class="line">  startTime = startTime;</span><br><span class="line">  <span class="built_in">setTimeout</span>(cb, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(cb, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4ms，那么浏览器会将每次调用的时间间隔设置为 4ms。可以看下<span class="exturl" data-url="aHR0cHM6Ly9jcy5jaHJvbWl1bS5vcmcvY2hyb21pdW0vc3JjL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvZnJhbWUvZG9tX3RpbWVyLmNj">源码<i class="fa fa-external-link-alt"></i></span>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 11 of the algorithm at</span></span><br><span class="line"><span class="comment">// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html requires</span></span><br><span class="line"><span class="comment">// that a timeout less than 4ms is increased to 4ms when the nesting level is</span></span><br><span class="line"><span class="comment">// greater than 5.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> kMaxTimerNestingLevel = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> base::TimeDelta kMinimumInterval =</span><br><span class="line">    base::TimeDelta::<span class="built_in">FromMilliseconds</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不一定是一个很好的主意。</p>
<h3 id="又恨又爱的-setInterval"><a href="#又恨又爱的-setInterval" class="headerlink" title="又恨又爱的 setInterval"></a>又恨又爱的 setInterval</h3><p>上面说完了 <code>setTimeout</code>，当然不能错过它的孪生兄弟 <code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code> 会每隔指定的时间将注册的函数置入 <code>Event Queue</code>，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，对于 <code>setInterval(fn, ms)</code> 来说，我们已经知道不是每过 ms 毫秒会执行一次 <code>fn</code>，而是每过 ms 毫秒，会有 <code>fn</code> 进入 <code>Event Queue</code>。一旦 <code>setInterval</code> 的回调函数 <code>fn</code> 执行时间超过了延迟时间 ms，那么就完全看不出来有时间间隔了。</p>
<h3 id="Promise-与-process-nextTick-callback"><a href="#Promise-与-process-nextTick-callback" class="headerlink" title="Promise 与 process.nextTick(callback)"></a>Promise 与 process.nextTick(callback)</h3><p>传统的定时器我们已经研究过了，接着我们探究 <code>Promise</code> 与 <code>process.nextTick(callback)</code> 的表现。</p>
<p><code>process.nextTick(callback)</code> 类似 node.js 版的 <code>setTimeout</code>，在事件循环的下一次循环中调用 <code>callback</code> 回调函数。</p>
<mark class="label info">我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</mark>

<ul>
<li>macro-task(宏任务)：整体代码 script，setTimeout，setInterval，setImmediate，I/O 操作，UI 渲染</li>
<li>micro-task(微任务)：Promise，async / await，process.nextTick，MutationObserver</li>
</ul>
<p>不同类型的任务会进入对应的 <code>Event Queue</code>，比如 <code>setTimeout</code> 和 <code>setInterval</code> 会进入相同的 <code>Event Queue</code>。</p>
<p>事件循环的顺序决定了 JS 代码的执行顺序。进入整体代码（宏任务）后，开始第一次循环，接着执行所有的微任务，然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用文章最开始的一段代码说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;then&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;console&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>这段代码作为宏任务，进入主线程</li>
<li>先遇到 <code>setTimeout</code>，那么将其回调函数注册后分发到宏任务 <code>Event Queue</code></li>
<li>接下来遇到了 <code>Promise</code>，<code>new Promise</code> 立即执行，<code>then</code> 函数分发到微任务 <code>Event Queue</code>。遇到 <code>console.log()</code>，立即执行</li>
<li>整体代码作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 <code>then</code> 在微任务 <code>Event Queue</code> 里面，执行</li>
<li>OK，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务 <code>Event Queue</code> 开始。我们发现了宏任务 <code>Event Queue</code> 中 <code>setTimeout</code> 对应的回调函数，立即执行</li>
<li>结束</li>
</ol>
<p>事件循环，宏任务，微任务的关系如图所示：</p>
<p><img data-src="http://cdn.kingmui.cn/javascript_event_queue_1.png"></p>
<p>我们来分析一段较复杂的代码，看看你是否真的掌握了 JS 的执行机制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第一轮事件循环流程分析如下：</p>
<ol>
<li><p>整体 script 作为第一个宏任务进入主线程，遇到 <code>console.log</code>，输出 1</p>
</li>
<li><p>遇到 <code>setTimeout</code>，其回调函数被分发到<strong>宏任务</strong> <code>Event Queue</code> 中。我们暂且记为 <code>setTimeout1</code></p>
</li>
<li><p>遇到 <code>process.nextTick()</code>，其回调函数被分发到<strong>微任务</strong> <code>Event Queue</code> 中。我们记为 <code>process1</code></p>
</li>
<li><p>遇到 <code>Promise</code>，<code>new Promise</code> 直接执行，输出 7。<code>then</code> 被分发到<strong>微任务</strong> <code>Event Queue</code> 中。我们记为 <code>then1</code></p>
</li>
<li><p>又遇到了 <code>setTimeout</code>，其回调函数被分发到<strong>宏任务</strong> <code>Event Queue</code> 中，我们记为 <code>setTimeout2</code></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>宏任务 Event Queue</th>
<th>微任务 Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td>process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td>then1</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>上表是第一轮事件循环宏任务结束时各 <code>Event Queue</code> 的情况，此时已经输出了 1 和 7</p>
</li>
<li><p>我们发现了 <code>process1</code> 和 <code>then1</code> 两个微任务</p>
</li>
<li><p>执行 <code>process1</code>，输出 6</p>
</li>
<li><p>执行 <code>then1</code>，输出 8</p>
</li>
</ol>
<p>好了，第一轮事件循环正式结束，这一轮的结果是输出 <code>1，7，6，8</code>。那么第二轮事件循环从 <code>setTimeout1</code> 宏任务开始：</p>
<ol>
<li>首先输出 2。接下来遇到了 <code>process.nextTick()</code>，同样将其分发到<strong>微任务</strong> <code>Event Queue</code> 中，记为 <code>process2</code>。<code>new Promise</code> 立即执行输出 4，<code>then</code> 也分发到<strong>微任务</strong> <code>Event Queue</code> 中，记为 <code>then2</code></li>
</ol>
<table>
<thead>
<tr>
<th>宏任务 Event Queue</th>
<th>微任务 Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout2</td>
<td>process2</td>
</tr>
<tr>
<td></td>
<td>then2</td>
</tr>
</tbody></table>
<ol start="2">
<li>第二轮事件循环宏任务结束，我们发现有 <code>process2</code> 和 <code>then2</code> 两个微任务可以执行</li>
<li>输出 3</li>
<li>输出 5</li>
</ol>
<p>第二轮事件循环结束，第二轮输出 <code>2，4，3，5</code>。第三轮事件循环开始，此时只剩 <code>setTimeout2</code> 了，执行</p>
<ol>
<li>直接输出 9</li>
<li>将 <code>process.nextTick()</code> 分发到<strong>微任务</strong> <code>Event Queue</code> 中。记为 <code>process3</code></li>
<li>直接执行 <code>new Promise</code>，输出 11</li>
<li>将 <code>then</code> 分发到<strong>微任务</strong> <code>Event Queue</code> 中，记为 <code>then3</code></li>
</ol>
<table>
<thead>
<tr>
<th>宏任务 Event Queue</th>
<th>微任务 Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>process3</td>
</tr>
<tr>
<td></td>
<td>then3</td>
</tr>
</tbody></table>
<ol start="5">
<li>第三轮事件循环宏任务执行结束，执行两个微任务 <code>process3</code> 和 <code>then3</code></li>
<li>输出 10</li>
<li>输出 12</li>
</ol>
<p>第三轮事件循环结束，第三轮输出 <code>9，11，10，12</code>。整段代码，共进行了三次事件循环，完整的输出为 <code>1，7，6，8，2，4，3，5，9，11，10，12</code><br>(请注意，Node 环境下的事件监听依赖 <code>libuv</code> 与前端环境不完全相同，输出顺序可能会有误差)</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><h4 id="JS-的异步"><a href="#JS-的异步" class="headerlink" title="JS 的异步"></a>JS 的异步</h4><p>我们开篇就说 Javascript 是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。</p>
<h4 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 Event Loop"></a>事件循环 Event Loop</h4><p>事件循环是 JS 实现异步的一种方法，也是 JS 的执行机制。</p>
<h4 id="Javascript-的执行和运行"><a href="#Javascript-的执行和运行" class="headerlink" title="Javascript 的执行和运行"></a>Javascript 的执行和运行</h4><p>执行和运行有很大的区别，Javascript 在不同的环境下，比如 Node，浏览器，Ringo等等，<strong>执行方式是不同</strong>的。而运行大多指 Javascript 解析引擎，是统一的。</p>
<h4 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h4><ul>
<li>Javascript 是一门单线程语言</li>
<li><code>Event Loop</code> 是 Javascript 的执行机制</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 高级特性</title>
    <url>/2023/03/01/TypeScript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TypeScript 是由<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQW5kZXJzX0hlamxzYmVyZw==">安德斯·海尔斯伯格<i class="fa fa-external-link-alt"></i></span>（Anders Hejlsberg）在微软开发的严格超集语言，是 JavaScript 的一个强类型版本。任何 JavaScript 中的特性都可以在 TypeScript 中使用，这也就意味着我们可以运用已熟知的 JavaScript 技能，以及以前不支持的编码功能去开发复杂的大型应用，从而提高代码的可读性和可维护性。此外，TypeScript 还提供了诸如类型推断、联合类型、类型保护和泛型等高级特性，以便我们可以更好地处理日趋复杂的代码库。</p>
<h1 id="为什么需要-TypeScript"><a href="#为什么需要-TypeScript" class="headerlink" title="为什么需要 TypeScript"></a>为什么需要 TypeScript</h1><p>TypeScript 为 JavaScript 添加了类型系统的支持。使用 TypeScript 的好处有很多，例如：</p>
<ul>
<li>代码即文档</li>
<li>编译器自动提示</li>
<li>一定程度上能够避免低级 bug</li>
<li>代码的可维护性更强</li>
</ul>
<p>TypeScript 可以让我们在编写 JavaScript 代码时拥有更好的代码质量和更强的编译时错误检查。在开发阶段能够帮助我们更快速、更精准地定位问题，以降低代码在运行时才能引发错误的风险。并且在开发大型项目时，TypeScript 的类型系统可以帮助我们更好地组织代码，使团队成员能够更快地了解项目。</p>
<h1 id="TypeScript-的高级特性"><a href="#TypeScript-的高级特性" class="headerlink" title="TypeScript 的高级特性"></a>TypeScript 的高级特性</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>TypeScript 支持 JavaScript 中的大多数操作符，包括算数、关系、逻辑、位、赋值、条件、类型转换和其他操作符。此外，TypeScript 还提供了一些额外的特殊操作符，如<strong>类型保护</strong>和<strong>断言</strong>操作符。</p>
<span id="more"></span>

<h3 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h3><p>类型保护是一种缩小类型的机制。TypeScript 通过编译时进行类型保护，使得在编写代码时就能发现和修复类型错误。</p>
<p>类型保护的形式有多种，例如：</p>
<ol>
<li>类型断言：使用 <code>as</code> 语法手动指定变量的类型</li>
<li><code>instanceof</code> 运算符：检查一个变量是否是某个类的实例</li>
<li><code>typeof</code> 运算符：检查一个变量的类型是否是某个类型</li>
<li><code>in</code> 运算符：检查一个变量是否是某个对象的属性</li>
<li>用户自定义的类型保护函数：使用特定的逻辑，检查一个变量是否符合特定的类型</li>
</ol>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>TypeScript 和 JavaScript 里面都有 <code>typeof</code> 关键字，二者的作用都差不多。</p>
<ul>
<li>在 TypeScript 中，<code>typeof</code> <strong>返回的是一个 TypeScript 类型定义</strong>，即将 JS data 转换成 TS type。它只能对数据进行转换，不能转换 <code>type</code> 和 <code>interface</code>。</li>
<li>在 JavaScript 中，<code>typeof</code> <strong>返回的是一个字符串</strong>，指示操作数的 JavaScript 类型，即将 JS data 转换成 JS data。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> organization = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TOrganization = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IOrganization &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方式会被认为是 JS 的 typeof</span></span><br><span class="line"><span class="keyword">const</span> JsData1 = <span class="keyword">typeof</span> organization; <span class="comment">// const JsData1 = &quot;object&quot;</span></span><br><span class="line"><span class="keyword">const</span> JsData2 = <span class="keyword">typeof</span> TOrganization; <span class="comment">// &#x27;TOrganization&#x27; only refers to a type, but is being used as a value here.</span></span><br><span class="line"><span class="keyword">const</span> JsData3 = <span class="keyword">typeof</span> IOrganization; <span class="comment">// &#x27;IOrganization&#x27; only refers to a type, but is being used as a value here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方式会被认为是 TS 的 typeof</span></span><br><span class="line"><span class="keyword">type</span> TsType1 = <span class="keyword">typeof</span> organization; <span class="comment">// type TsType1 = &#123;name: string; age: number&#125;</span></span><br><span class="line"><span class="keyword">type</span> TsType2 = <span class="keyword">typeof</span> TOrganization; <span class="comment">// &#x27;TOrganization&#x27; only refers to a type, but is being used as a value here.</span></span><br><span class="line"><span class="keyword">type</span> TsType3 = <span class="keyword">typeof</span> IOrganization; <span class="comment">// &#x27;IOrganization&#x27; only refers to a type, but is being used as a value here.</span></span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 可以用于检查对象是否属于特定类。它仅适用于 <code>class</code> 类，不适用于其他 TypeScript 结构，如 <code>interface</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">objectVariable <span class="keyword">instanceof</span> ClassName;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> emailAddress: <span class="built_in">string</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> firstName: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> surname: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    emailAddress: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(emailAddress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">contact: Contact</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (contact <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + contact.firstName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="keyof-索引类型查询"><a href="#keyof-索引类型查询" class="headerlink" title="keyof 索引类型查询"></a>keyof 索引类型查询</h3><p><code>keyof</code> 有时被称为索引查询运算符，因为它查询在它之后指定的类型的所有键的联合类型。换句话说，它将对象类型的所有键作为字符串类型的联合类型返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">keyof T</span><br></pre></td></tr></table></figure>

<p>结果为泛型 <code>T</code> 上已知的公共属性名的联合类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserKeys = keyof User;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// type UserKeys = &quot;name&quot; | &quot;age&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="T-K-索引访问"><a href="#T-K-索引访问" class="headerlink" title="T[K] 索引访问"></a>T[K] 索引访问</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">T[K]</span><br></pre></td></tr></table></figure>

<p>结果为泛型 <code>T</code> 上 <code>K</code> 属性的值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]; <span class="comment">// obj[key] 的类型是 T[K]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中，我们使用泛型定义了入参 <code>obj: T</code> 和 <code>key: K</code>，此时有 <code>obj[key]: T[K]</code>。当我们返回 <code>obj[key]</code>，编译器会实例化 <code>obj[key]</code> 的真实类型，因此返回值类型可以随着属性值类型的改变而改变。</p>
<h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">propertyName <span class="keyword">in</span> objectVariable;</span><br></pre></td></tr></table></figure>

<p><code>in</code> 关键字在 TypeScript 中有两层含义，第一层含义与 JavaScript 一致，用于检查属性是否属于特定对象。TypeScript 编译器使用 <code>in</code> 表达式来收窄表达式中变量的类型。其返回值取决于 <code>propertyName</code> 属性是否属于 <code>objectVariable</code> 对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> q: A | B = ...;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> q) &#123;</span><br><span class="line">  <span class="comment">// q: A</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// q: B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，<code>in</code> 在 TypeScript 中的另一层含义是在<strong>映射类型</strong>（Mapped Types）中，<code>in</code> 关键字用作语法的一部分，用于遍历枚举类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P]; <span class="comment">// P 是泛型 T 中的任意属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// type PersonPartial = &#123; name?: string;  age?: number; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="extends-继承"><a href="#extends-继承" class="headerlink" title="extends 继承"></a>extends 继承</h3><p><code>extends</code> 用于定义泛型类型或接口。它表示泛型类型或接口必须继承指定的类型，并受其约束。</p>
<p>在 TypeScript 中，<code>extends</code> 主要有三种使用场景：</p>
<ul>
<li>类型继承，类型 A 继承类型 B（<code>interface</code> 可用 <code>extends</code> 继承，<code>type</code> 不可以）</li>
<li>定义范型，约束范型必须与目标类型相匹配</li>
<li>条件匹配，判断类型 A 是否匹配类型 B</li>
</ul>
<p>当我们在定义接口类型时，可以为多个接口提取其可复用部分作为基础类型定义，然后通过<strong>类型继承</strong>来派生出其他子类型，例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> T1 &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> T2 &#123;</span><br><span class="line">  <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重继承用逗号隔开</span></span><br><span class="line"><span class="keyword">interface</span> T3 <span class="keyword">extends</span> T1, T2 &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> t3: T3 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>,</span><br><span class="line">  <span class="attr">location</span>: <span class="string">&#x27;Hangzhou&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义接口泛型时，如果想要约束这个泛型的有效范围，则可以使用 <code>extends</code> 来定义<strong>范型约束</strong>，我们还可以为其指定默认值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> LANGUAGE &#123;</span><br><span class="line">  JAVA,</span><br><span class="line">  GO,</span><br><span class="line">  JAVASCRIPT,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 约束范型 T 的类型并且指定默认值</span></span><br><span class="line"><span class="keyword">interface</span> IProgrammer&lt;T <span class="keyword">extends</span> LANGUAGE = LANGUAGE.JAVASCRIPT&gt; &#123;</span><br><span class="line">  <span class="attr">language</span>: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件匹配是一种利用条件表达式进行类型的关系检测，我们将在下文详细讨论。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断范型 T 是否匹配 number</span></span><br><span class="line"><span class="keyword">type</span> TNumber&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="built_in">any</span> : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T1 = TNumber&lt;<span class="built_in">number</span>&gt;; <span class="comment">// type T1 = any</span></span><br><span class="line"><span class="keyword">type</span> T2 = TNumber&lt;<span class="built_in">string</span>&gt;; <span class="comment">// type T2 = never</span></span><br></pre></td></tr></table></figure>

<h3 id="as-断言"><a href="#as-断言" class="headerlink" title="as 断言"></a>as 断言</h3><p><code>as</code> 关键字是一个类型断言运算符，用于将一个值的类型强制转换为另一种类型。这意味着，即使编译器检测到的变量类型与我们预期的类型不匹配，也可以使用类型断言将其转换为正确的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure>

<p>上述例子中，我们显式将 <code>someValue</code> 指定为 <code>any</code> 类型，此时 <code>strLength</code> 为 <code>any</code> 类型，因为无法从一个 <code>any</code> 类型的值中推断出 <code>length</code> 属性的类型。当我们通过类型断言将 <code>someValue</code> 转换为 <code>string</code> 类型后，<code>strLength</code> 将能得到正确的 <code>number</code> 类型。</p>
<p>TypeScript 还有一个<strong>非空断言运算符</strong>（<code>!</code>）用于断言一个变量非空，它位于我们想要告诉 TypeScript 不是 <code>null</code> 或 <code>undefined</code> 的变量或表达式之后。非空断言运算符是避免代码中不必要的 <code>null</code> 和 <code>undefined</code> 检查的简洁方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicate</span>(<span class="params">text: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// if (text === null || text === undefined) &#123;</span></span><br><span class="line">  <span class="comment">//   text = &quot;&quot;;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// return text.concat(text);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用非空断言运算符简写代码</span></span><br><span class="line">  <span class="keyword">return</span> text!.concat(text!);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="infer-类型推断"><a href="#infer-类型推断" class="headerlink" title="infer 类型推断"></a>infer 类型推断</h3><p><code>infer</code> 关键字是 TypeScript 中的一个特殊类型，表示在 <code>extends</code> 条件语句中待推断的类型变量。它允许我们在声明一个类型变量时，从其他类型中推断出这个变量的类型。使用 <code>infer</code> 关键字可以使 TypeScript 更加灵活，并改善类型推断的表现。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T1&lt;T&gt; = T <span class="keyword">extends</span> (infer U)[] ? U : T;</span><br></pre></td></tr></table></figure>

<p>上述示例中，我们通过推断传入的类型是否是数组，如果是数组，则返回数组中推断的元素类型 <code>U</code>，否则返回 <code>T</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ParamType&lt;T&gt; = T <span class="keyword">extends</span> (...args: infer P) =&gt; <span class="built_in">any</span> ? P : T;</span><br></pre></td></tr></table></figure>

<p>上述代码表示：如果 <code>T</code> 能赋值给 <code>(...args: infer P) =&gt; any</code>，则结果是 <code>(...args: infer P) =&gt; any</code> 类型中的参数 <code>P</code>，否则返回 <code>T</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Func = <span class="function">(<span class="params">user: User</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Type1 = ParamType&lt;Func&gt;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// type Type1 = User</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Type2 = ParamType&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// type Type2 = string</span></span><br></pre></td></tr></table></figure>

<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="索引类型（Index-types）"><a href="#索引类型（Index-types）" class="headerlink" title="索引类型（Index types）"></a>索引类型（Index types）</h3><p>当我们从对象中获取一些属性的值时，索引类型能够帮助我们检查使用了动态属性名的代码。 </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> organization = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">organization: <span class="built_in">any</span>, keys: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> organization[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getValues(organization, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]); <span class="comment">// [&#x27;zcy&#x27;, 6]</span></span><br><span class="line">getValues(organization, [<span class="string">&#x27;location&#x27;</span>]); <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>getValues(organization, [&#39;location&#39;])</code> 输出 <code>[undefined]</code>，TypeScript 编译器并没有给出错误提示。接下来我们运用前一章节操作符中学到的<strong>索引类型查询</strong>（<code>keyof</code>）和<strong>索引访问</strong>（<code>T[K]</code>）操作符来纠正类型约束。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IOrganization &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> organization: IOrganization = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValues</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">organization: T, keys: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> keys.map(<span class="function"><span class="params">key</span> =&gt;</span> organization[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&#x27;zcy&#x27;, 6]</span></span><br><span class="line">getValues(organization, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;&quot;location&quot;&#x27; is not assignable to type &#x27;keyof IOrganization&#x27;.</span></span><br><span class="line">getValues(organization, [<span class="string">&#x27;location&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="映射类型（Mapped-Types）"><a href="#映射类型（Mapped-Types）" class="headerlink" title="映射类型（Mapped Types）"></a>映射类型（<strong>Mapped Types</strong>）</h3><p>有时候我们希望能从现有类型派生出新的类型。映射类型就是 TypeScript 为我们提供的基于现有类型创建新类型的一种方式，新类型会以相同的形式去转换旧类型中的每个属性。</p>
<p>在使用映射类型时，我们可以应用两个附加的修饰符 <code>readonly</code> 和 <code>?</code> 来分别影响属性的可变性和可选性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T readonly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Make all properties in T optional</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br></pre></td></tr></table></figure>

<p>我们可以通过添加 <code>-</code> 或 <code>+</code> 前缀来<strong>删除</strong>或<strong>添加</strong>这些修饰符。若没有显式指定前缀，则默认为 <code>+</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为 TOrganization 类型移除 readonly 修饰符</span></span><br><span class="line"><span class="keyword">type</span> Mutable&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TOrganization = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> age: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnlockedOrganization = Mutable&lt;TOrganization&gt;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// type UnlockedOrganization = &#123;</span></span><br><span class="line"><span class="comment">//   name: string;</span></span><br><span class="line"><span class="comment">//   age: number;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 MaybeOrganization 类型移除 ? 修饰符</span></span><br><span class="line"><span class="keyword">type</span> Concrete&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MaybeOrganization = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  location?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Organization = Concrete&lt;MaybeOrganization&gt;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// type Organization = &#123;</span></span><br><span class="line"><span class="comment">//   name: string;</span></span><br><span class="line"><span class="comment">//   age: string;</span></span><br><span class="line"><span class="comment">//   location: number;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>

<p>此外，我们还可以利用 <code>as</code> 为生成的键名重新映射。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Getters&lt;T&gt; = &#123;</span><br><span class="line">  <span class="comment">// 模板字面量类型后文会提及</span></span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; P&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span> T[P]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IOrganization &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  location: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LazyOrganization = Getters&lt;IOrganization&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type LazyOrganization = &#123;</span></span><br><span class="line"><span class="comment">//   getName: () =&gt; string;</span></span><br><span class="line"><span class="comment">//   getAge: () =&gt; number;</span></span><br><span class="line"><span class="comment">//   getLocation: () =&gt; string;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="条件类型（Conditional-Types）"><a href="#条件类型（Conditional-Types）" class="headerlink" title="条件类型（Conditional Types）"></a>条件类型（<strong>Conditional Types</strong>）</h3><p>条件类型是 TypeScript 中非常强大的工具，是一种在编译时执行的特殊类型，可以让我们在编写代码时根据特定条件来确定类型，以灵活地处理复杂的类型问题。</p>
<p>条件类型看起来有点类似于 JavaScript 中的条件表达式，语法如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">SomeType <span class="keyword">extends</span> OtherType ? TrueType : FalseType</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SomeType</code> 和 <code>OtherType</code> 是比较的类型</li>
<li>如果 <code>SomeType</code> 可以赋值给 <code>OtherType</code>，则类型为 <code>TrueType</code></li>
<li>如果 <code>SomeType</code> 无法赋值给 <code>OtherType</code>，则类型为 <code>FalseType</code></li>
</ul>
<p>条件类型可以用于创建动态类型。例如：</p>
<p>1、创建具有多种可能类型的对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Options = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> | <span class="string">&#x27;green&#x27;</span> | <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">  size: <span class="string">&#x27;small&#x27;</span> | <span class="string">&#x27;medium&#x27;</span> | <span class="string">&#x27;large&#x27;</span>;</span><br><span class="line">  colors: <span class="built_in">string</span>[];</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof Options]: Options[K] <span class="keyword">extends</span> <span class="built_in">string</span> ? K : <span class="built_in">never</span>;</span><br><span class="line">&#125;[keyof Options];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> item: Item = <span class="string">&#x27;color&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们通过条件类型筛选出了 <code>Options</code> 中所有值类型为 <code>string</code> 的属性所组成的联合类型 <code>Item</code>。</p>
<p>2、创建只有满足特定条件的类型的类</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataStore</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> data: T;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">data: T</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getData&lt;K <span class="keyword">extends</span> keyof T&gt;(key: K): T[K] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> DataStore(&#123; <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> name = store.getData(<span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="模板字面量类型（Template-Literal-Types）"><a href="#模板字面量类型（Template-Literal-Types）" class="headerlink" title="模板字面量类型（Template Literal Types）"></a><strong><strong>模板字面量类型（Template Literal Types）</strong></strong></h3><p>模板字面量类型是一种特殊的类型，用于在运行时生成字符串值。它们使用反引号 ``` 括起来，并且允许在字符串中嵌入表达式，跟 JavaScript 的模板字符串是相同的语法，但是只能用在类型操作中。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> World = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Greeting = <span class="string">`hello <span class="subst">$&#123;World&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// type Greeting = &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>为了帮助进行字符串操作，TypeScript 内置了一组可用于操纵字符串的类型，这些类型出于性能的考虑被内置在编译器中，无法在 <code>.d.ts</code> 文件中找到。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert string literal type to uppercase</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Uppercase&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert string literal type to lowercase</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Lowercase&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert first character of string literal type to uppercase</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Capitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert first character of string literal type to lowercase</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Uncapitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br></pre></td></tr></table></figure>

<p>从 TypeScript 4.1 开始，存在 4 种内置类型：<code>Uppercase</code>、<code>Lowercase</code>、<code>Capitalize</code> 和 <code>Uncapitalize</code>，它们都是使用关键字 <code>intrinsic</code> 定义的。<code>intrinsic</code>（adj. 固有的; 内在的; 本身的;）是 TypeScript 引入的一个关键字，就如同它的含义一样，是 TypeScript 内置的。它们的共同特点是生成的类型涉及到了值的转换，而不是类型的转换，这在 TypeScript 中通过已有的类型书写方式是无法表达的，所以 TypeScript 只能通过内置关键字在编译期实现。这些内置函数会直接使用 JavaScript 字符串运行时函数，而不是本地化识别。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> IntrinsicTypeKind &#123;</span><br><span class="line">  Uppercase,</span><br><span class="line">  Lowercase,</span><br><span class="line">  Capitalize,</span><br><span class="line">  Uncapitalize</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> intrinsicTypeKinds: ReadonlyMap&lt;<span class="built_in">string</span>, IntrinsicTypeKind&gt; = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(&#123;</span><br><span class="line">  <span class="attr">Uppercase</span>: IntrinsicTypeKind.Uppercase,</span><br><span class="line">  <span class="attr">Lowercase</span>: IntrinsicTypeKind.Lowercase,</span><br><span class="line">  <span class="attr">Capitalize</span>: IntrinsicTypeKind.Capitalize,</span><br><span class="line">  <span class="attr">Uncapitalize</span>: IntrinsicTypeKind.Uncapitalize</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyStringMapping</span>(<span class="params">symbol: <span class="built_in">Symbol</span>, str: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (intrinsicTypeKinds.get(symbol.escapedName <span class="keyword">as</span> <span class="built_in">string</span>)) &#123;</span><br><span class="line">      <span class="keyword">case</span> IntrinsicTypeKind.Uppercase: <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">      <span class="keyword">case</span> IntrinsicTypeKind.Lowercase: <span class="keyword">return</span> str.toLowerCase();</span><br><span class="line">      <span class="keyword">case</span> IntrinsicTypeKind.Capitalize: <span class="keyword">return</span> str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">case</span> IntrinsicTypeKind.Uncapitalize: <span class="keyword">return</span> str.charAt(<span class="number">0</span>).toLowerCase() + str.slice(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L21haW4vc3JjL2NvbXBpbGVyL2NoZWNrZXIudHM=">此处<i class="fa fa-external-link-alt"></i></span>找到上述编译器源码的定义。</p>
<h3 id="不可变类型（Immutable-Types）"><a href="#不可变类型（Immutable-Types）" class="headerlink" title="不可变类型（Immutable Types）"></a>不可变类型（Immutable Types）</h3><p>不可变类型是指一旦创建了该类型的值，就不能对其进行修改，这有助于防止由于意外副作用导致的错误。可以通过使用 <code>const</code> 和 <code>readonly</code> 关键字来实现。</p>
<p><code>const</code> 断言是一种类型断言。使用 <code>const</code> 断言将导致 TypeScript 根据值结构为变量提供不可变类型。对于对象，<code>readonly</code> 修饰符以递归的方式应用于所有嵌套属性。<code>const</code> 断言是一种使对象或数组在编译时深度不可变的简便方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> variableName = someValue <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bill = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Bill&quot;</span>,</span><br><span class="line">  <span class="attr">profile</span>: &#123;</span><br><span class="line">    <span class="attr">level</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">scores</span>: [<span class="number">90</span>, <span class="number">65</span>, <span class="number">80</span>],</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// const bill = &#123;</span></span><br><span class="line"><span class="comment">//   readonly name: &quot;Bill&quot;;</span></span><br><span class="line"><span class="comment">//   readonly profile: &#123;</span></span><br><span class="line"><span class="comment">//     readonly level: 1;</span></span><br><span class="line"><span class="comment">//   &#125;;</span></span><br><span class="line"><span class="comment">//   readonly scores: readonly [90, 65, 80];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br><span class="line">bill.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line"><span class="comment">// Cannot assign to &#x27;level&#x27; because it is a read-only property.</span></span><br><span class="line">bill.profile.level = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// Property &#x27;push&#x27; does not exist on type &#x27;readonly [90, 65, 80]&#x27;</span></span><br><span class="line">bill.scores.push(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>readonly</code> 用于声明对象的属性是只读的。这意味着一旦声明了 <code>readonly</code> 修饰符，就不能再对此属性进行赋值。这对于防止意外地修改对象的状态很有用。可以应用于类型别名和接口以及类属性。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeName = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> propertyName: PropertyType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> InterfaceName &#123;</span><br><span class="line">  <span class="keyword">readonly</span> propertyName: PropertyType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> propertyName: PropertyType</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工具类型（Utility-Types）"><a href="#工具类型（Utility-Types）" class="headerlink" title="工具类型（Utility Types）"></a>工具类型（<strong>Utility Types</strong>）</h2><p>TypeScript 提供了很多内置的工具类型，它们可以帮助我们在编写代码时更有效地处理类型，以减少重复代码。</p>
<h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p><code>Required&lt;T&gt;</code> 能将所有类型 <code>T</code> 中的可选属性变成必需的属性。它只适用于可选的属性，如果属性已经是必需的，则不会产生任何影响。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T required</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述源码中，我们发现一个很有意思的用法 <code>-?</code>，就是将可选项代表的 <code>?</code> 去掉，从而让这个类型变成必选项。与之对应的还有个 <code>+?</code>，用来把属性变成可选项，<code>+</code> 是默认的前缀。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IOrganization &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> organization: Required&lt;IOrganization&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述例子中，我们定义了一个 <code>IOrganization</code> 接口，它有两个可选属性：<code>name</code> 和 <code>age</code>。通过使用 <code>Required&lt;IOrganization&gt;</code>，我们能够将它们变成必需的属性。</p>
<h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T readonly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Readonly&lt;T&gt;</code> 能将所有类型 <code>T</code> 中的可变属性变成只读属性。它仅对可变的属性有效，如果属性已经是只读的，则不会产生任何影响。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IOrganization &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> organization: Readonly&lt;IOrganization&gt; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">organization.name = <span class="string">&#x27;lcy&#x27;</span>; <span class="comment">// Error: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们定义了一个 <code>IOrganization</code> 接口，它有两个可变属性：<code>name</code> 和 <code>age</code>。通过使用 <code>Readonly&lt;IOrganization&gt;</code>，我们能够将它们变成只读属性。</p>
<h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p><code>Record&lt;K, T&gt;</code> 能够用于创建一个以键为类型的映射表，其中键类型必须是字符串或数字，这是因为它们是唯一的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with a set of properties K of type T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它会将 <code>K</code> 中所有属性的值转化为 <code>T</code> 类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IOrganization &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> organization: Record&lt;<span class="built_in">string</span>, IOrganization&gt; = &#123;</span><br><span class="line">  <span class="string">&#x27;zc&#x27;</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;,</span><br><span class="line">  <span class="string">&#x27;lc&#x27;</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;lcy&#x27;</span>, <span class="attr">age</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们定义了一个 <code>IOrganization</code> 接口，然后使用 <code>Record&lt;string, IOrganization&gt;</code> 创建了一个 <code>organization</code> 对象。它是一个字符串键和 <code>IOrganization</code> 值的映射，能够存储多个组织的信息。</p>
<h3 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h3><p>在 TypeScript 2.8 中引入了一个条件类型，示例如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>

<p>以上语句的意思是如果 <code>T</code> 是 <code>U</code> 的子类型的话，那么就会返回 <code>X</code>，否则返回 <code>Y</code>。</p>
<p>对于联合类型来说会自动分发条件，例如 <code>T extends U ? X : Y</code>，<code>T</code> 可能是 <code>A | B</code> 的联合类型，那实际情况就变成 <code>(A extends U ? X : Y) | (B extends U ? X : Y)</code> 。</p>
<p>有了以上的了解我们再来理解下面的工具泛型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude from T those types that are assignable to U</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberOrString = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> OnlyNumbers = Exclude&lt;NumberOrString, <span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onlyNumbers: OnlyNumbers = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>根据源码和示例我们可以推断出 <code>Exclude</code> 的作用是从 <code>T</code> 中找出 <code>U</code> 中没有的元素，换种更加贴近语义的说法其实就是从类型 <code>T</code> 中排除类型 <code>U</code> 。</p>
<h3 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h3><p>源码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extract from T those types that are assignable to U</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>如果类型 <code>U</code> 不是类型 <code>T</code> 的子类型，则将导致编译错误。</p>
<p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NumberOrString = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> OnlyStrings = Extract&lt;NumberOrString, <span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onlyStrings: OnlyStrings = <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>根据源码我们推断出 <code>Extract</code> 的作用是提取出 <code>T</code> 包含在 <code>U</code> 中的元素，换种更加贴近语义的说法就是从类型 <code>T</code> 中提取出类型 <code>U</code> 。</p>
<h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p><code>Pick&lt;T, K&gt;</code> 能够从类型 <code>T</code> 中选择一组键，并创建一个新的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * From T, pick a set of properties whose keys are in the union K</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它从 <code>T</code> 中取出一系列 <code>K</code> 的属性。其中 <code>K</code> 的属性必须存在于 <code>T</code> 中。<code>K extends keyof T</code> 表示 <code>K</code> 受到 <code>keyof T</code> 的约束，即 <code>K</code> 的属性必须是 <code>keyof T</code> 的子集。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IOrganization &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  location: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrganizationInfo = Pick&lt;IOrganization, <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> organization: OrganizationInfo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h3><p>用之前的 <code>Pick</code> 和 <code>Exclude</code> 进行组合，实现忽略对象某些属性的功能。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with the properties of T except for those in type K.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>删除的键必须是类型 <code>T</code> 中的属性，否则将导致编译错误。</p>
<p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IOrganization &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  location: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrganizationWithoutLocation = Omit&lt;IOrganization, <span class="string">&#x27;location&#x27;</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> organizationWithoutLocation: OrganizationWithoutLocation = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zcy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p><code>Partial&lt;T&gt;</code> 能够将类型 <code>T</code> 中的所有属性都变为可选的，并创建一个新的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make all properties in T optional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>keyof T</code> 拿到 <code>T</code> 所有属性名，然后 <code>in</code> 进行遍历，将值赋给 <code>P</code>，最后 <code>T[P]</code> 取得相应属性的值。</p>
<p>示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IOrganization &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  location: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialOrganization = Partial&lt;IOrganization&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partialOrganization: PartialOrganization = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><p><code>ReturnType&lt;T&gt;</code> 能够从函数类型 <code>T</code> 中提取返回类型，并创建一个新的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the return type of a function type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>

<p>试图推断返回值，并返回推断类型或 <code>any</code> 。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;zcy&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Name = ReturnType&lt;<span class="keyword">typeof</span> getName&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name: Name = <span class="string">&#x27;zcy&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="在-React-中使用-TypeScript"><a href="#在-React-中使用-TypeScript" class="headerlink" title="在 React 中使用 TypeScript"></a>在 React 中使用 TypeScript</h1><p>在这个部分，我们将探讨下如何在 React 项目中使用 TypeScript。</p>
<h2 id="定义组件-Props-类型"><a href="#定义组件-Props-类型" class="headerlink" title="定义组件 Props 类型"></a>定义组件 Props 类型</h2><p>在 React 项目中，最常用的场景是定义组件的 <code>props</code> 类型。通过声明组件的 <code>props</code> 类型，能够为我们带来：</p>
<ul>
<li>在消费组件时进行参数合法性校验。不需要查看源码查询支持的 <code>props</code> 参数以及类型</li>
<li>更好的组件自解释和 IDE 支持</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; FC &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IFunctionComponentProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">	location?: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FunctionComponent: FC&lt;IFunctionComponentProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, location &#125; = props;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FunctionComponent;</span><br></pre></td></tr></table></figure>

<h2 id="移除-children-类型定义"><a href="#移除-children-类型定义" class="headerlink" title="移除 children 类型定义"></a>移除 <code>children</code> 类型定义</h2><p>在 React 17.x 版本之前，<code>React.FC</code> 和 <code>React.FunctionComponent</code> 为我们隐式定义了 <code>children</code> 属性，即便我们可能并不需要消费 <code>children</code> 这个 prop。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PropsWithChildren&lt;P&gt; = P &amp; &#123; children?: ReactNode | <span class="literal">undefined</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FC&lt;P = &#123;&#125;&gt; = FunctionComponent&lt;P&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> FunctionComponent&lt;P = &#123;&#125;&gt; &#123;</span><br><span class="line">  (props: PropsWithChildren&lt;P&gt;, context?: <span class="built_in">any</span>): ReactElement&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; | <span class="literal">null</span>;</span><br><span class="line">  propTypes?: WeakValidationMap&lt;P&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  contextTypes?: ValidationMap&lt;<span class="built_in">any</span>&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  defaultProps?: Partial&lt;P&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  displayName?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们升级到 React 18.x 版本后，旧项目在使用 <code>React.FC</code> 定义的组件中将得到 <code>Property &#39;children&#39; does not exist on type &#39;IXXXProps&#39;.</code> 类型错误提示。这是因为在 React 18.x 版本中，React 团队认为 <code>children</code> 只是一个常规 prop，并不是什么特别的东西，默认移除了 <code>children</code> 这个 prop，因此我们需要像定义其他 props 一样去显式定义它。相关的讨论可在此常看：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzE3ODgyNTQvcmVhY3QtMTgtdHlwZXNjcmlwdC1jaGlsZHJlbi1mYw==">React 18 TypeScript children FC<i class="fa fa-external-link-alt"></i></span>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FC&lt;P = &#123;&#125;&gt; = FunctionComponent&lt;P&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> FunctionComponent&lt;P = &#123;&#125;&gt; &#123;</span><br><span class="line">  (props: P, context?: <span class="built_in">any</span>): ReactElement&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; | <span class="literal">null</span>;</span><br><span class="line">  propTypes?: WeakValidationMap&lt;P&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  contextTypes?: ValidationMap&lt;<span class="built_in">any</span>&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  defaultProps?: Partial&lt;P&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  displayName?: <span class="built_in">string</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见的-Hooks-类型"><a href="#常见的-Hooks-类型" class="headerlink" title="常见的 Hooks 类型"></a>常见的 Hooks 类型</h2><p>接下来我们看一下如何在 React 中编写一些常用的 hook。</p>
<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p><code>useState</code> 是一个用于在函数组件中添加状态的 hook，它返回一个包含当前状态和更新状态的数组。其类型定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt;(<span class="params">initialState: S | (() =&gt; S)</span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">SetStateAction</span>&lt;<span class="title">S</span>&gt;&gt;]</span>;</span><br></pre></td></tr></table></figure>

<p><code>useState</code> 接收一个泛型类型 <code>S</code>，该类型是状态的类型。它需要传递一个初始状态 <code>initialState</code>，可以是一个静态的初始状态值或一个函数，该函数返回初始状态。</p>
<p>大多数情况下，<code>useState</code> 不需要显式指定状态类型，TypeScript 会自动进行类型推断。但是如果初始值和未来值不同则需要特别声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState&lt;IData | <span class="literal">null</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，如果 data 没有初始值，则为 <code>null</code>，其最终会被赋值 <code>IData</code> 类型的值，所以必须显式地将 data 的类型指定为这两种可能类型的集合。而 num 可以根据初始值推断为 <code>number</code> 类型，setNum 也会推断为 <code>Dispatch&lt;SetStateAction&lt;number&gt;&gt;</code>。</p>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p><code>useMemo</code> 是一个用于性能优化的 hook，它可以帮助避免在渲染时不必要地计算昂贵的计算结果。其类型定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params">factory: () =&gt; T, deps: DependencyList | <span class="literal">undefined</span></span>): <span class="title">T</span></span>;</span><br></pre></td></tr></table></figure>

<p>从源码类型定义可以看出，<code>useMemo</code> 接收一个泛型类型 <code>T</code>，该类型是由工厂函数 <code>factory</code> 计算出来的值的类型。</p>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p><code>useCallback</code> 是一个用于性能优化的 hook，它可以帮助避免在渲染时不必要地创建新函数。其类型定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Function</span>&gt;(<span class="params">callback: T, deps: DependencyList</span>): <span class="title">T</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>useCallback</code> 接收一个泛型函数类型 <code>T</code>，返回一个与传入的回调函数相同类型的函数。</p>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p><code>useRef</code> 是一个用于在函数组件中存储可变值的 hook，它返回一个可变的 <code>ref</code> 对象，该对象包含一个 <code>current</code> 属性，可以用来存储和访问值。其类型定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useRef</span>&lt;<span class="title">T</span>&gt;(<span class="params">initialValue: T</span>): <span class="title">MutableRefObject</span>&lt;<span class="title">T</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> MutableRefObject&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">current</span>: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>useRef</code> 接收一个泛型类型 <code>T</code>，该类型是 <code>ref</code> 对象 <code>current</code> 属性存储的值的类型。返回的 <code>ref</code> 对象的类型是 <code>MutableRefObject&lt;T&gt;</code>，它是一个包含 <code>current</code> 属性的对象。该属性可以被修改而不会触发组件重新渲染。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef&lt;HTMLInputElement&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputRef.current) &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，<code>MyComponent</code> 组件使用 <code>useRef</code> hook 来创建一个 <code>inputRef</code> 引用，它的类型是 <code>HTMLInputElement | null</code>。<code>useEffect</code> hook 在组件挂载后运行一次，它使用 <code>inputRef.current</code> 检查引用是否存在，如果存在则调用 <code>focus()</code> 方法以聚焦输入元素。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了 TypeScript 的基本概念和高级语法，以及如何在项目中使用它来提高生产力。通过类型定义来指定变量、函数、对象等的类型，从而在编译时就能检测出潜在的风险，减少在运行时才能发现的问题。TypeScript 的高级语言特性使得代码的组织和重构更加方便，帮助开发者编写更加健壮、可维护的 JavaScript 代码，从而提高开发效率。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svaW50cm8uaHRtbA==">The TypeScript Handbook<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWFybnR5cGVzY3JpcHQuZGV2Lw==">Learn TypeScript<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWNvZGVjYW1wLm9yZy9uZXdzL3R5cGVzY3JpcHQtZm9yLXJlYWN0LWRldmVsb3BlcnMv">TypeScript for React Developers – Why TypeScript is Useful and How it Works<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDA0MDE5NzA3Ni9hLTEwMjAwMDAwNDAxOTg3MTI=">typescript中intrinsic代表什么<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 V8 的垃圾回收原理</title>
    <url>/2020/09/13/deeply-understand-the-principle-of-V8-garbage-collection/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>JS 语言不像 C/C++，让程序员自己去开辟或者释放内存，而是类似 Java，采用自己的一套垃圾回收算法进行自动的内存管理。作为一名资深前端工程师，需要对 JS 的内存回收机制非常清楚，以便在极端的环境下能够分析出系统性能的瓶颈，另一方面，学习这其中的机制，也对我们深入理解 JS 的闭包特性、以及对内存的高效使用，都有很大的帮助。</p>
</div>

<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>V8 的垃圾回收策略基于<strong>分代回收</strong>机制，该机制又基于<strong>世代假说</strong>。该假说有两个特点：</p>
<ol>
<li>大部分新生对象倾向于早死</li>
<li>不死的对象，会活得更久</li>
</ol>
<p>基于这个理论，现代垃圾回收算法根据<strong>对象的存活时间</strong>将内存进行了分代，并对不同分代的内存采用不同的高效算法进行垃圾回收。</p>
<span id="more"></span>

<h3 id="V8-的内存分代"><a href="#V8-的内存分代" class="headerlink" title="V8 的内存分代"></a>V8 的内存分代</h3><p>在 V8 中，将内存分为了新生代（new space）和老生代（old space）。它们的特点如下：</p>
<ul>
<li>新生代：对象的存活时间较短（新生对象或只经过一次垃圾回收的对象）</li>
<li>老生代：对象存活时间较长（经历过一次或多次垃圾回收的对象）</li>
</ul>
<p>V8 堆的空间等于新生代空间加上老生代空间。我们可以通过 <code>--max-old-space-size</code> 命令设置老生代空间的最大值，<code>--max-new-space-size</code> 命令设置新生代空间的最大值。老生代与新生代的空间大小在程序初始化时设置，一旦生效则不能动态改变。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node --max-old-space-size=2048 test.js // 单位为 MB</span><br><span class="line">node --max-new-space-size=1024 test.js // 单位为 KB</span><br></pre></td></tr></table></figure>

<p>默认设置下，64 位系统的老生代大小为 1400M，32 位系统为 700M。<br>对于新生代，它由两个 <code>reserved_semispace_size</code> 组成。每个 <code>reserved_semispace_size</code> 的大小在不同位数的机器上大小不同。默认设置下，在 64 位与 32 位的系统下分别为 16MB 和 8MB。</p>
<table>
<thead>
<tr>
<th>类型 / 系统位数</th>
<th>64位</th>
<th>32位</th>
</tr>
</thead>
<tbody><tr>
<td>老生代</td>
<td>1400MB</td>
<td>700MB</td>
</tr>
<tr>
<td>reserved_semispace_size</td>
<td>16MB</td>
<td>8MB</td>
</tr>
<tr>
<td>新生代</td>
<td>32MB</td>
<td>16MB</td>
</tr>
</tbody></table>
<h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><h4 id="全停顿（Stop-The-World）"><a href="#全停顿（Stop-The-World）" class="headerlink" title="全停顿（Stop The World）"></a>全停顿（Stop The World）</h4><p>在介绍垃圾回收算法之前，我们先了解一下「全停顿」。垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为「全停顿」。例如，如果一次 GC 需要 50ms，应用逻辑就会暂停 50ms。</p>
<p>全停顿的目的，是为了解决应用逻辑与垃圾回收器看到的情况不一致的问题。例如，在自助餐厅吃饭，高高兴兴地取完食物回来时，结果发现自己餐具被服务员收走了。这里，服务员就好比垃圾回收器，餐具就像是分配的对象，我们就是应用逻辑。在我们看来，只是将餐具临时放在桌上，但是在服务员看来觉得你已经不需要使用，因此就收走了。你与服务员对于同一个事物看到的情况不一致，导致服务员做了与我们不期望的事情。因此，为避免应用逻辑与垃圾回收器看到的情况不一致，垃圾回收算法在执行时，需要停止应用逻辑。</p>
<h4 id="Scavenge-算法"><a href="#Scavenge-算法" class="headerlink" title="Scavenge 算法"></a>Scavenge 算法</h4><p>新生代中的对象主要通过 Scavenge 算法进行垃圾回收。Scavenge 的具体实现，主要采用了 Cheney 算法。</p>
<p><img data-src="http://cdn.kingmui.cn/gc_1.webp" alt="V8堆内存空间示意图"></p>
<p>Cheney 算法采用复制的方式进行垃圾回收。它将堆内存一分为二，每一部分空间称为 semispace。这两个空间，只有一个空间处于使用中，另一个则处于闲置状态。使用中的 semispace 称为 「From 空间」，闲置的 semispace 称为 「To 空间」。</p>
<p>过程如下：</p>
<ol>
<li>从 From 空间分配对象，若 semispace 被分配满，则执行 Scavenge 算法进行垃圾回收</li>
<li>检查 From 空间的存活对象，若对象存活，则检查对象是否符合晋升条件，若符合条件则晋升到老生代，否则将对象从 From 空间复制到 To 空间</li>
<li>若对象不存活，则释放不存活对象的空间</li>
<li>完成复制后，将 From 空间与 To 空间进行角色翻转</li>
</ol>
<h4 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h4><p>对象晋升的条件有两个：</p>
<ol>
<li><strong>对象是否经历过 Scavenge 回收</strong>。对象从 From 空间复制到 To 空间时，会检查对象的内存地址来判断对象是否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</li>
<li><strong>To 空间的内存使用占比是否超过限制</strong>。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置为 25% 比例的原因是，当完成 Scavenge 回收后，To 空间将翻转成 From 空间，继续进行对象内存的分配。若占比过大，将影响后续内存分配。</li>
</ol>
<p>对象晋升到老生代后，将接受新的垃圾回收算法处理。下图为 Scavenge 算法中，对象晋升流程图。</p>
<p><img data-src="http://cdn.kingmui.cn/gc_2.webp" alt="晋升流程图"></p>
<p>Scavenge 算法的缺点是，它的算法机制决定了只能利用一半的内存空间。但是新生代中的对象生存周期短、存活对象少，进行对象复制的成本不是很高，因而非常适合这种场景。</p>
<h4 id="Mark-Sweep-amp-Mark-Compact"><a href="#Mark-Sweep-amp-Mark-Compact" class="headerlink" title="Mark-Sweep &amp; Mark-Compact"></a>Mark-Sweep &amp; Mark-Compact</h4><p>老生代中的对象有两个特点，第一是存活对象多，第二个存活时间长。若在老生代中使用 Scavenge 算法进行垃圾回收，将会导致复制存活对象的效率不高，且还会浪费一半的空间。因而，V8 在老生代采用 Mark-Sweep 和 Mark-Compact 算法进行垃圾回收。</p>
<h4 id="标记清除（Mark-Sweep）"><a href="#标记清除（Mark-Sweep）" class="headerlink" title="标记清除（Mark-Sweep）"></a>标记清除（Mark-Sweep）</h4><p>Mark-Sweep，是标记清除的意思。它主要分为标记和清除两个阶段。</p>
<ul>
<li>标记阶段，它将遍历堆中所有对象，并对存活的对象进行标记</li>
<li>清除阶段，对未标记对象的空间进行回收</li>
</ul>
<p>与 Scavenge 算法不同，Mark-Sweep 不会对内存一分为二，因此不会浪费空间。但是，经历过一次 Mark-Sweep 之后，内存的空间将会变得不连续，这样会对后续内存分配造成影响。例如，当需要分配一个比较大的对象时，没有任何一个碎片内支持分配，这将提前触发一次垃圾回收，尽管这次垃圾回收是没有必要的。</p>
<p><img data-src="http://cdn.kingmui.cn/gc_3.webp" alt="Mark-Sweep标记与清理的示意图"></p>
<h4 id="标记压缩（Mark-Compact）"><a href="#标记压缩（Mark-Compact）" class="headerlink" title="标记压缩（Mark-Compact）"></a>标记压缩（Mark-Compact）</h4><p>为了解决内存碎片的问题，提高内存的利用率，引入了 Mark-Compact 算法。Mark-Compact 在 Mark-Sweep 算法上进行了改进，标记阶段与 Mark-Sweep 相同，但是对未标记的对象处理方式不同。与 Mark-Sweep 是对未标记的对象立即进行回收，Mark-Compact 则是将存活的对象移动到一边，然后再清理端边界外的内存。</p>
<p><img data-src="http://cdn.kingmui.cn/gc_4.webp" alt="Mark-Compact算法"></p>
<p>由于 Mark-Compact 需要移动对象，所以执行速度上，比 Mark-Sweep 要慢。所以，V8 主要使用 Mark-Sweep 算法，然后在当空间内存分配不足时，采用 Mark-Compact 算法。</p>
<h4 id="增量标记（Incremental-Marking）"><a href="#增量标记（Incremental-Marking）" class="headerlink" title="增量标记（Incremental Marking）"></a>增量标记（Incremental Marking）</h4><p>在新生代中，由于存活对象少，垃圾回收效率高，全停顿时间短，造成的影响小。但是老生代中，存活对象多，垃圾回收时间长，全停顿造成的影响大。为了减少全停顿的时间，V8 对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">          GC         JS         GC         JS</span><br><span class="line">主进程 ---------&gt; ---------&gt; ---------&gt; ---------&gt;</span><br></pre></td></tr></table></figure>

<p>长时间的 GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。从 2011 年起，V8 就将「全暂停」标记换成了增量标记。改进后的标记方式，最大停顿时间减少到原来的 1/6。</p>
<h4 id="延迟清理（lazy-sweeping）"><a href="#延迟清理（lazy-sweeping）" class="headerlink" title="延迟清理（lazy sweeping）"></a>延迟清理（lazy sweeping）</h4><ul>
<li>发生在增量标记之后</li>
<li>堆确切地知道有多少空间能被释放</li>
<li>延迟清理是被允许的，因此页面的清理可以根据需要进行清理</li>
<li>当延迟清理完成后，增量标记将重新开始</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解 GC 原理，有助于我们对 NodeJS 项目进行性能瓶颈定位与调优。文章所描述的算法为 V8 中使用的基础算法，现代 V8 引擎已经对垃圾回收进行了很多改进。例如，在 Chrome 64 和 NodeJS V10 中 V8 启用了「并行标记」技术，将标记时间缩短了 <code>60%~70%</code>。还有「Parallel Scavenger」技术，它将新生代的垃圾回收时间缩短了 <code>20%~50%</code>。</p>
<p>垃圾回收是影响服务性能的因素之一，为了提高服务性能，应尽量减少垃圾回收的次数。</p>
<p>V8 堆内存最大值在 64 位系统上为 1464MB，在 32 位系统上为 732MB。计算公式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">V8 堆内存最大保留空间 = 4 * reserved_semispace_size_ + max_old_generation_size_</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Deno 1.0：你需要了解的</title>
    <url>/2020/05/24/deno-1-0-what-you-need-to-know/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="https://cdn.kingmui.cn/deno1-0.jpg" class="">

<div class="note info"><p>Deno 是使用 V8 引擎并用 Rust 语言编写的 JavaScript 和 TypeScript 的简单，现代且安全的运行时。它汇集了许多最佳的开源技术，并在一个小的可执行文件中提供了全面的解决方案。它还解决了 Ryan 在<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1NM0JNOVRCLTh5QQ==">我对Node.js感到遗憾的十件事<i class="fa fa-external-link-alt"></i></span>演讲中谈到的设计缺陷。</p>
</div>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不知道大家还记不记得两年前在 Github 发生的「学不动」事件。那次事件的起因便是著名的 Node 之父 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J5">Ryan Dahl<i class="fa fa-external-link-alt"></i></span> 宣布新开一个叫 Deno 的项目，于是就有国人以一种类似于贴吧灌水的形式在 Deno 的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J5L2Rlbm8vaXNzdWVzLzI1">issiue<i class="fa fa-external-link-alt"></i></span> 区里用中文大量发“学不动啦”，“求别更新”等帖子，顿时引起一片<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI3OTM1NjIwNw==">争论<i class="fa fa-external-link-alt"></i></span>。如今两年时间过去了，ry 也带着他的 Deno 1.0 正式与我们会面。不论我们学的动还是学不动，技术就在那里，不以人的意志为转移。在这篇文章中，我们将会涵盖所有令人激动的 Deno 特性。</p>
<span id="more"></span>

<h3 id="与-Node-js-的区别"><a href="#与-Node-js-的区别" class="headerlink" title="与 Node.js 的区别"></a>与 Node.js 的区别</h3><p>与用 C++ 编写的 Node.js 不同，Deno 用 Rust 语言编写。那么为什么不像 Node.js 一样用 C++ 而是选择用 Rust 呢？主要是因为 Rust 提供了很多现成的模块，对于 Deno 来说，可以节约很多开发时间。也许是看到了 Rust 提供了很多现成模块，Deno 也决定在自己的项目中添加许多现成模块。它的异步操作使用 Rust 的 <span class="exturl" data-url="aHR0cHM6Ly90b2tpby5ycy8=">Tokio<i class="fa fa-external-link-alt"></i></span> 库来实现 Event Loop，并且像 Node.js 一样，使用 V8 引擎执行 JavaScript。</p>
<p>开箱即用地支持 TypeScript，可以直接运行 ts 代码，虽然最终还是要先编译成 js 代码来运行，但这都是内部完成的。这也就意味着你不需要每次编写完 ts 代码后还要去手动编译了，而且也省去了搭建 ts-node 之类的工作。它的内部会根据文件后缀名判断，如果是 <code>.ts</code> 后缀名，就先调用 TS 编译器，将其编译成 JavaScript；如果是 <code>.js</code> 后缀名，则直接传入 V8 引擎运行。</p>
<p>Deno 相对于 Node.js 一大亮点是没有 <code>node_modules</code>，没有 <code>package.json</code>，通过 <code>import URL</code> 的形式进行第三方模块的引用。</p>
<table>
<thead>
<tr>
<th></th>
<th>Node</th>
<th>Deno</th>
</tr>
</thead>
<tbody><tr>
<td>开发语言</td>
<td>C++</td>
<td>Rust</td>
</tr>
<tr>
<td>API 引用方式</td>
<td>模块导入</td>
<td>全局对象</td>
</tr>
<tr>
<td>模块系统</td>
<td>CommonJS &amp; 新版 node 实验性 ES Module</td>
<td>ES Module</td>
</tr>
<tr>
<td>安全</td>
<td>无安全限制</td>
<td>默认安全</td>
</tr>
<tr>
<td>TypeScript</td>
<td>第三方，如通过 ts-node 支持</td>
<td>原生支持</td>
</tr>
<tr>
<td>包管理</td>
<td>npm + node_modules</td>
<td>原生支持</td>
</tr>
<tr>
<td>异步操作</td>
<td>回调</td>
<td>Promise</td>
</tr>
<tr>
<td>包分发</td>
<td>中心化 npmjs.com</td>
<td>去中心化 import url</td>
</tr>
<tr>
<td>入口</td>
<td>package.json 配置</td>
<td>import url 直接引入</td>
</tr>
<tr>
<td>打包、测试、格式化</td>
<td>第三方如 eslint、gulp、webpack、babel 等</td>
<td>原生支持</td>
</tr>
</tbody></table>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>鉴于国内的网络原因，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2p1c3RqYXZhYw==">justjavac<i class="fa fa-external-link-alt"></i></span> 大佬搞了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rlbm9jbi9kZW5vX2luc3RhbGw=">国内镜像<i class="fa fa-external-link-alt"></i></span>加速。要更新到最新版本，请使用 <code>deno upgrade</code>。</p>
<p>Mac/Linux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://x.deno.js.cn/install.sh | sh</span><br></pre></td></tr></table></figure>

<p>Windows</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iwr https://x.deno.js.cn/install.ps1 -useb -outf install.ps1; .\install.ps1</span><br><span class="line"><span class="meta">#</span><span class="bash"> iwr https://x.deno.js.cn/install.ps1 -useb | iex</span></span><br></pre></td></tr></table></figure>

<p>要获得有关任何 Deno 子命令的帮助，请使用以下任一命令。</p>
<ul>
<li><code>deno [subcommand] -h</code></li>
<li><code>deno [subcommand] --help</code></li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>Deno 具有安全控制，默认是安全的。除非明确启用，否则没有文件，网络或环境的访问权限。相比之下，Node.js 拥有对文件系统和网络的完全访问权限。</p>
<p>在没有权限的情况下运行程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deno run file-needing-to-run-a-subprocess.ts</span><br></pre></td></tr></table></figure>

<p>如果代码需要权限设置，执行后，会发现一串报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: Uncaught PermissionDenied: access to run a subprocess, run again with the --allow-run flag</span><br></pre></td></tr></table></figure>

<p>Deno 使用命令行选项来显式指定程序允许访问的系统权限。最常用的包括：</p>
<ul>
<li>环境变量读取权限</li>
<li>网络访问权限</li>
<li>文件系统读/写访问权限</li>
<li>运行子进程权限</li>
</ul>
<p>要查看完整的权限列表，请输入 <code>deno run -h</code> 查看。</p>
<p>最佳做法是将权限白名单用于读，写和网络。这使你可以更详细地了解允许 Deno 使用的内容。例如，要允许 Deno 在 <code>/etc</code> 目录中有读取文件的权限，请使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deno --allow-read=/etc</span><br></pre></td></tr></table></figure>

<p><strong>使用权限的快捷方式</strong></p>
<p>你可能很快就厌倦了每次运行应用程序时都要显式启用权限的情况。要解决此问题，你可以采用以下任意一种方法。</p>
<h4 id="允许所有权限"><a href="#允许所有权限" class="headerlink" title="允许所有权限"></a>允许所有权限</h4><p>你可以使用 <code>--allow-all</code> 或 <code>-A</code> 启用所有权限。不过<strong>不建议这样做</strong>，因为它移除了 Deno 为我们带来的安全性优势。</p>
<h4 id="制作bash脚本"><a href="#制作bash脚本" class="headerlink" title="制作bash脚本"></a>制作bash脚本</h4><p>使用运行程序所需的最小权限创建一个 bash 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">// 允许允许子进程和文件系统的写入权限</span><br><span class="line">deno run --allow-run --allow-write mod.ts</span><br></pre></td></tr></table></figure>

<h4 id="使用任务运行器"><a href="#使用任务运行器" class="headerlink" title="使用任务运行器"></a>使用任务运行器</h4><p>你可以使用 GNU 工具 make 通过一组带有权限的 Deno 命令来创建一个文件。你还可以使用特定于 Deno 的版本 <span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQveC9kcmFrZS8=">Drake<i class="fa fa-external-link-alt"></i></span>。</p>
<h4 id="安装可执行的-Deno-程序"><a href="#安装可执行的-Deno-程序" class="headerlink" title="安装可执行的 Deno 程序"></a>安装可执行的 Deno 程序</h4><p>使用 <code>deno install</code> <span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvbWFudWFsL3Rvb2xzL3NjcmlwdF9pbnN0YWxsZXIjc2NyaXB0LWluc3RhbGxlcg==">安装一个 Deno 程序<i class="fa fa-external-link-alt"></i></span>，该程序具有执行所需的所有权限。安装后，你可以从 <code>$PATH</code> 中的任何位置访问该程序。</p>
<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>Deno <span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkLw==">标准库<i class="fa fa-external-link-alt"></i></span>是由 Deno 官方维护并保证可与 Deno 一起使用的常用模块集合。它涵盖了用户最常用于常见任务的代码，并且宽松地基于 Go 编程语言提供的标准库。</p>
<p>JavaScript 一直因缺乏标准库而备受困扰。用户被迫一次又一次地重新造轮子，开发人员必须经常在 NPM 上搜索第三方模块，以解决平台本应提供的常见问题。</p>
<p>对于像 React 之类的解决复杂问题的库作为第三方包而存在是一件好事，但是对于 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsbHlfdW5pcXVlX2lkZW50aWZpZXI=">UUID<i class="fa fa-external-link-alt"></i></span> 生成等简单的事情，最好使用官方的标准库。这些小型库可作为大型库的构建模块，从而加快开发速度。有多少一度流行的库最终却被遗弃，用户最终只能选择要么自己维护，要么重新选择一个库？实际上，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRpZGVsaWZ0LmNvbS91cC10by0yMC1wZXJjZW50LW9mLXlvdXItYXBwbGljYXRpb24tZGVwZW5kZW5jaWVzLW1heS1iZS11bm1haW50YWluZWQ=">没有积极维护<i class="fa fa-external-link-alt"></i></span>的常用依赖多达 20％ 之多。</p>
<p><strong>Deno 官方维护模块及其对应的 NPM 模块</strong></p>
<table>
<thead>
<tr>
<th>Deno 模块</th>
<th>描述</th>
<th>NPM 模块</th>
</tr>
</thead>
<tbody><tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL2ZtdC9jb2xvcnMudHM=">colors<i class="fa fa-external-link-alt"></i></span></td>
<td>为终端添加颜色</td>
<td><strong>chalk, kleur, and colors</strong></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL2RhdGV0aW1lL1JFQURNRS5tZA==">datetime<i class="fa fa-external-link-alt"></i></span></td>
<td>帮助使用 JavaScript Date 对象</td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL2VuY29kaW5nL1JFQURNRS5tZA==">encoding<i class="fa fa-external-link-alt"></i></span></td>
<td>增加了对外部数据结构（如base32，binary，csv，toml和yaml）的支持</td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL2ZsYWdzL1JFQURNRS5tZA==">flags<i class="fa fa-external-link-alt"></i></span></td>
<td>帮助使用命令行参数</td>
<td><strong>minimist</strong></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL2ZzL1JFQURNRS5tZA==">fs<i class="fa fa-external-link-alt"></i></span></td>
<td>帮助操纵文件系统</td>
<td></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL2h0dHAvUkVBRE1FLm1k">http<i class="fa fa-external-link-alt"></i></span></td>
<td>允许通过 HTTP 提供本地服务</td>
<td><strong>http-server</strong></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL2xvZy9SRUFETUUubWQ=">log<i class="fa fa-external-link-alt"></i></span></td>
<td>用于创建日志</td>
<td><strong>winston</strong></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL3Rlc3RpbmcvUkVBRE1FLm1k">testing<i class="fa fa-external-link-alt"></i></span></td>
<td>用于单元测试</td>
<td><strong>chai</strong></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL3V1aWQvUkVBRE1FLm1k">uuid<i class="fa fa-external-link-alt"></i></span></td>
<td>生成 UUID</td>
<td><strong>uuid</strong></td>
</tr>
<tr>
<td><span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL3dzL1JFQURNRS5tZA==">ws<i class="fa fa-external-link-alt"></i></span></td>
<td>帮助创建 WebSocket 客户端/服务端</td>
<td><strong>ws</strong></td>
</tr>
</tbody></table>
<h3 id="Deno-内置-tsc-引擎"><a href="#Deno-内置-tsc-引擎" class="headerlink" title="Deno 内置 tsc 引擎"></a>Deno 内置 tsc 引擎</h3><p>TypeScript 是 JavaScript 的超集，添加了显式类型。任何有效的 JavaScript 也是有效的 TypeScript，因此将你的代码转换为 TypeScript 是轻而易举的。只需将扩展名更改为 <code>.ts</code> 并开始添加类型即可。</p>
<p>要在 Deno 中使用 TypeScript，无需执行任何操作。如果没有 Deno，则必须将 TypeScript 编译为 JavaScript 才能运行。Deno 在内部为你完成了此操作，从而使 TypeScript 更加易于采用。</p>
<p><strong>使用自定义的 <code>tsconfig.json</code></strong></p>
<p>对于熟悉 TypeScript 的人来说，你将习惯使用 <code>tsconfig.json</code> 文件来提供编译器选项。使用 Deno 时这是可选的，因为它已经具有自己的默认配置。如果你使用自己的 <code>tsconfig.json</code> 且与 Deno 冲突，则会收到警报。</p>
<p>此特性需要 <code>-c</code> 选项和 <code>tsconfig.json</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deno run -c tsconfig.json [file-to-run.ts]</span><br></pre></td></tr></table></figure>

<p>Deno 默认使用严格模式。除非有一些不道德的人将其改写，否则 Deno 将合理地尽可能多的在用户编写一些过于草率的代码时给出警告。</p>
<h3 id="Deno-尽可能使用-Web-标准"><a href="#Deno-尽可能使用-Web-标准" class="headerlink" title="Deno 尽可能使用 Web 标准"></a>Deno 尽可能使用 Web 标准</h3><p>建立 Web 标准需要很长的时间，一旦设定为固定标准，就不会改变它。虽然框架来来去去，但标准终将保留。花费在学习标准化 API 上的时间永远不会浪费，因为没有人敢于破坏标准。它可能已经使用了数十年，甚至可能是你职业生涯的其余部分。新技术来了又走了，但是有很多思想是共通的。你要设置正确的优先级，把 80% 的时间投资到基础知识学习上，把剩下的 20% 留给框架，类库和工具。</p>
<p><code>fetch</code> web API 提供了用于获取资源的接口。浏览器中有一个 JavaScript <code>fetch()</code> 方法。如果你想在 Node.js 中使用此标准，则需要依赖第三方库 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaA==">Node Fetch<i class="fa fa-external-link-alt"></i></span> 实现。但在 Deno 中，它是内置的，并且就像浏览器一样工作，开箱即用。</p>
<p>Deno 1.0 提供以下与 Web 兼容的 API。</p>
<ul>
<li>addEventListener</li>
<li>btoa</li>
<li>atob</li>
<li>clearInterval</li>
<li>clearTimeout</li>
<li>dispatchEvent</li>
<li>fetch</li>
<li>queueMicrotask</li>
<li>removeEventListener</li>
<li>setInterval</li>
<li>setTimeout</li>
<li>AbortSignal</li>
<li>Blob</li>
<li>File</li>
<li>FormData</li>
<li>Headers</li>
<li>ReadableStream</li>
<li>Request</li>
<li>Response</li>
<li>URL</li>
<li>URLSearchParams</li>
<li>console</li>
<li>isConsoleInstance</li>
<li>location</li>
<li>onload</li>
<li>onunload</li>
<li>self</li>
<li>window</li>
<li>AbortController</li>
<li>CustomEvent</li>
<li>DOMException</li>
<li>ErrorEvent</li>
<li>Event</li>
<li>EventTarget</li>
<li>MessageEvent</li>
<li>TextDecoder</li>
<li>TextEncoder</li>
<li>Worker</li>
<li>ImportMeta</li>
<li>Location</li>
</ul>
<p>这些都可以在程序的顶级范围内使用。这意味着如果你避免在 <code>Deno()</code> 名称空间上使用任何方法，则你的代码应与 Deno 和浏览器兼容。尽管并非所有 Deno API 都 100％ 符合其等效的 Web 规范，但这对于前端开发人员而言仍然是不错的福音。</p>
<h3 id="ECMAScript-模块标准"><a href="#ECMAScript-模块标准" class="headerlink" title="ECMAScript 模块标准"></a>ECMAScript 模块标准</h3><p>Deno 与 Node.js 的一项重大变化是 Deno 使用了官方的 ECMAScript 模块标准，而不是传统的 CommonJS。Node.js 直到 2019 年底才启用版本 13.2.0 的 ECMAScript 模块，但即便如此，支持度还是不够，并且仍然包含有争议的 <code>.mjs</code> 文件扩展名。</p>
<p>Deno 使用 URL 或文件路径引用该模块，并包含必需的文件扩展名。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> log <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std/log/mod.ts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; outputToConsole &#125; <span class="keyword">from</span> <span class="string">&quot;./view.ts&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>使用文件扩展名的问题</strong></p>
<p>Deno 期望模块具有文件扩展名，但 TypeScript 则相反。</p>
<img data-src="http://cdn.kingmui.cn/ts-extension-problem.png" class="">

<p>在任何地方使用文件扩展名都应该是合法的，并且这似乎应该是达成共识的。但不幸的是，实际上事情要复杂得多。现在，我们可以使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL3ZzY29kZV9kZW5v">Visual Studio Code Extension<i class="fa fa-external-link-alt"></i></span> 解决仅 Deno 项目的问题。</p>
<h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>Node.js 用回调的方式处理异步操作，Deno 则选择用 Promise。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node 方式</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.readFile(<span class="string">&quot;./data.txt&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Deno 支持 <code>top-level-await</code>，所以以上读取文件的代码可以为：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deno 方式</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> Deno.readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure>

<p>Node.js 如果想要实现 Promise 化，则需要借助第三方模块 promisify，通过包裹一层函数来实现。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node API promisify</span></span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">&quot;es6-promisify&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 top-level-await，只能包一层</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> readFile(<span class="string">&quot;./data.txt&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>

<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>人们对 Deno 中的包管理方式进行了彻底的重新思考。它是分散的，而不是依赖中心化仓库。任何人都可以托管一个程序包，就像任何人都可以托管网络上任何类型的文件一样。</p>
<p>使用像 npm 这样的中心化存储库有优缺点，而 Deno 的这一方面肯定是最具争议的。</p>
<p><strong>Deno 的包管理工作原理</strong></p>
<p>如此简化，可能会令你震惊。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; assertEquals &#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std/testing/asserts.ts&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>让我们与 Node.js 对比下变更：</p>
<ul>
<li>没有了 NPM 这种中心化的包管理器。我们可以直接从网络导入 ECMAScript 模块</li>
<li>不再有“神奇的” Node.js 模块解析。现在，语法是明确的，这使事情更容易理解</li>
<li>不再有 <code>node_modules</code> 目录。而是将依赖项下载并隐藏在你的硬盘驱动器中。如果需要刷新缓存并再次下载，只需在命令中添加 <code>--reload</code></li>
</ul>
<p>Deno 没有 Node.js 中的 <code>node_modules</code> 目录做为包存放的地方，但也需要一个地方存在安装的模块。如果要与项目代码一起下载依赖项而不是使用全局缓存，请使用 <code>$DENO_DIR</code> 环境变量。<code>DENO_DIR</code> 默认为 <code>$HOME/.deno</code>，就是 Deno 存放生成的代码和缓存的源码的路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mac / linux</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export DENO_DIR=$HOME/.deno&#x27;</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile <span class="comment"># 如果是 zsh 则：source ~/.zshrc</span></span><br></pre></td></tr></table></figure>

<h3 id="查找兼容的第三方库"><a href="#查找兼容的第三方库" class="headerlink" title="查找兼容的第三方库"></a>查找兼容的第三方库</h3><p>有一个与 Deno 兼容的第三方模块的<span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQveC8=">用户区<i class="fa fa-external-link-alt"></i></span>。尽管没有官方支持与 Node.js 的向后兼容性，但是仍然有许多库和应用程序可以与 Deno 一起正常工作。有些是开箱即用，而另一些则需要一些努力才能正常工作。</p>
<table>
<thead>
<tr>
<th>库类型</th>
<th>兼容性</th>
</tr>
</thead>
<tbody><tr>
<td>在浏览器中运行 使用ESM语法</td>
<td>确认与 <span class="exturl" data-url="aHR0cHM6Ly93d3cucGlrYS5kZXYvc2VhcmNo">Pika 软件包目录<i class="fa fa-external-link-alt"></i></span>兼容，并使用 NPM 或 <span class="exturl" data-url="aHR0cHM6Ly93d3cucGlrYS5kZXYvY2Ru">Pika CDN<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>在浏览器中运行，使用CommonJS语法</td>
<td>使用 <span class="exturl" data-url="aHR0cHM6Ly9qc3BtLmlvLw==">jspm.io<i class="fa fa-external-link-alt"></i></span> 将模块包装为 ESM 语法或 <span class="exturl" data-url="aHR0cHM6Ly93d3cucGlrYS5kZXYvY2Ru">Pika CDN<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>不在浏览器中运行，不使用Node.js API</td>
<td>使用 <span class="exturl" data-url="aHR0cHM6Ly9qc3BtLmlvLw==">jspm.io<i class="fa fa-external-link-alt"></i></span> 将模块包装为 ESM 语法或 <span class="exturl" data-url="aHR0cHM6Ly93d3cucGlrYS5kZXYvY2Ru">Pika CDN<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>使用 Node.js API</td>
<td>这可能行不通，但请尝试使用 <span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL25vZGUv">NodeJS 标准库的官方兼容层<i class="fa fa-external-link-alt"></i></span></td>
</tr>
</tbody></table>
<h3 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h3><p>Deno 仍然很新，周围的生态系统仍在形成。建议将 <span class="exturl" data-url="aHR0cHM6Ly93d3cucGlrYS5kZXYvY2Ru">Pika<i class="fa fa-external-link-alt"></i></span> 作为在标准库和用户库以外寻找兼容模块的第一站。NPM 上可用的任何软件包也应位于 Pika CDN 上，并已自动转换为可与 <code>import</code> 一起使用。</p>
<p>Pika 背后的开发人员已与 Deno 合作，通过被称为 <span class="exturl" data-url="aHR0cHM6Ly9kZXYudG8vcGlrYS9pbnRyb2R1Y2luZy1waWthLWNkbi1kZW5vLXA4Yg==">X-TypeScript-Types<i class="fa fa-external-link-alt"></i></span> 的 ECMAScript 模块提供 TypeScript 类型。你可以通过简单地使用其 CDN 平台来利用此优势。</p>
<h3 id="告别-package-json"><a href="#告别-package-json" class="headerlink" title="告别 package.json"></a>告别 <code>package.json</code></h3><p>NPM 生态下包信息存放在 <code>package.json</code>，包含但不限于下面的内容：</p>
<ul>
<li>项目元信息</li>
<li>项目依赖和版本号</li>
<li>依赖还进行分类，比如 <code>dependencies</code>、<code>devDependencies</code> 甚至 <code>peerDependencies</code></li>
<li>标记入口，<code>main</code> 和 <code>module</code>，还有 TS 用的 <code>types</code> 与 <code>typings</code>，脚手架的 <code>bin</code> 等等</li>
<li>npm scripts</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Project Name&quot;</span>, <span class="comment">// metadata</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>, <span class="comment">// metadata</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;My application&quot;</span>, <span class="comment">// metadata</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>, <span class="comment">// module functionality</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;src/mod.ts&quot;</span>, <span class="comment">// module functionality</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;npm run _copy-build-files &amp;&amp; rollup -c&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build-watch&quot;</span>: <span class="string">&quot;npm run _copy-build-files &amp;&amp; rollup -cw&quot;</span></span><br><span class="line">  &#125;, <span class="comment">// scripting functionality</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;gpl-3.0&quot;</span>, <span class="comment">// metadata</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@rollup/plugin-TypeScript&quot;</span>: <span class="string">&quot;^3.1.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rollup&quot;</span>: <span class="string">&quot;^1.32.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;TypeScript&quot;</span>: <span class="string">&quot;^3.8.3&quot;</span></span><br><span class="line">  &#125;, <span class="comment">// versioning and categorizing functionality</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;tplant&quot;</span>: <span class="string">&quot;^2.3.3&quot;</span></span><br><span class="line">  &#125; <span class="comment">// versioning and categorizing functionality</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有这些实践随着时间的流逝而融合在一起，现在代表着 JavaScript 生态系统的标准工作方式。很容易忘记这不是官方标准；这些功能成为必需品时，才想到它。现在，JavaScript 已经赶上了，是时候进行重新思考了。</p>
<p>Deno 仍无法取代 <code>package.json</code> 的所有功能，但目前有一些解决方案。</p>
<p><strong>使用 <code>deps.ts</code> 和 URL 进行版本控制</strong></p>
<p>软件包版本控制有一个 Deno 约定，即使用名为 <code>deps.ts</code> 的特殊文件。在内部，依赖项被重新导出。这允许应用程序中的不同模块都引用相同的源。而不是告诉 npm 要下载哪个模块版本，而是在 <code>deps.ts</code> 中的 URL 中引用该模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deps.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; assert &#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@v0.39.0/testing/asserts.ts&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; green, bold &#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@v0.39.0/fmt/colors.ts&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果要更新任何模块，可以在 <code>deps.ts</code> 中更改 URL。例如，将 <code>@v0.39.0</code> 替换为 <code>@v0.41.0</code>，新版本将在所有地方使用。如果改为直接将 <span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkQHYwLjM5LjAvZm10L2NvbG9ycy50cw==">https://deno.land/std@v0.39.0/fmt/colors.ts<i class="fa fa-external-link-alt"></i></span> 导入每个模块，则你将不费吹灰之力遍历整个应用程序并更改每个引用。</p>
<p>假设你之前下载的模块以后不会被篡改可能会带来安全风险。这就是为什么还可以选择创建<span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL21hbnVhbC5tZCNsb2NrLWZpbGU=">锁定<i class="fa fa-external-link-alt"></i></span>文件的原因。这将确保新下载的模块与你最初下载的模块相同。</p>
<h3 id="使用-JSDoc-生成文档"><a href="#使用-JSDoc-生成文档" class="headerlink" title="使用 JSDoc 生成文档"></a>使用 JSDoc 生成文档</h3><p>JSDoc 于 1999 年发布。现在，它是 JavaScript 和 TypeScript 最常用的文档生成器。虽然不是正式的 Web 标准，但它是 <code>package.json</code> 中所有元数据的完美替代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@file </span>Manages the configuration settings for the widget</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author </span>Lucio Fulci</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@copyright </span>2020 Intervision</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@license <span class="variable">gpl</span></span>-3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version </span>1.0</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure>

<p>Deno 开箱即用地支持 JSDoc 并将其用于其内置的文档系统。虽然 <code>deno doc</code> 命令当前不使用上面的元数据，但它会读取函数的描述及其参数的描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a value of (true?) if the rule is to be included</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>key Current key name of rule being checked</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>val Current value of rule being checked</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>deno doc &lt;filename&gt;</code> 来查看程序的文档。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deno doc mod.ts</span><br><span class="line"></span><br><span class="line">function rulesToRemove(key: string, val: any[]): boolean</span><br><span class="line">  Returns a value of if the rule is to be included</span><br></pre></td></tr></table></figure>

<p>在线托管程序时，请使用<span class="exturl" data-url="aHR0cHM6Ly9kb2MuZGVuby5sYW5kLw==">在线文档查看器<i class="fa fa-external-link-alt"></i></span>更详细地查看它。</p>
<h3 id="内置工具链"><a href="#内置工具链" class="headerlink" title="内置工具链"></a>内置工具链</h3><img data-src="http://cdn.kingmui.cn/deno-tool-scream.png" class="">

<p>这是对前端开发人员影响最大的领域。当前的 JavaScript 工具状态非常混乱。当你添加 TypeScript 工具时，复杂性甚至更进一步增加。</p>
<p>JavaScript 的好处之一是它不需要编译，因此可以立即运行在浏览器中。这使得入门门槛很低，你只需要一个记事本和一个浏览器就可以开始写代码。</p>
<p>不幸的是，这种简单性和可访问性已被过度的工具链所破坏。显然将 JavaScript 开发变成了一场噩梦。</p>
<p>工具的混乱已经发展到这样的程度：许多开发人员迫切希望回到实际编写代码的过程中，而不是去研究配置文件并为应该采用的多个竞争标准而苦恼。解决这一问题的一个新兴项目是 Facebook 的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JvbWVqcy9yb21l">rome<i class="fa fa-external-link-alt"></i></span>。这还处于起步阶段。尽管它可能被证明是有益的，但 Deno 有潜力成为更实质性的解决方案。</p>
<p>Deno 本身就是一个完整的生态系统，具有运行时和其自己的模块/包管理系统。这为内置所有其自己的工具提供了更大的空间。让我们研究一下 1.0 中可用的工具，以及如何使用它来减少对第三方库的依赖并简化开发。</p>
<p>目前尚无法在 Deno 中替换整个前端构建管道，但是我们相信这不会等太久的。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试运行器使用 <code>Deno.test()</code> 函数内置在 Deno 的核心中。<span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL3Rlc3Rpbmcv">断言库<i class="fa fa-external-link-alt"></i></span>也在标准库中提供。所有你想要的，例如 <code>assertEquals()</code> 和 <code>assertStrictEq()</code>，以及一些不太常见的断言，例如 <code>assertThrowsAsync()</code> 都包含在其中。</p>
<p>目前，尚无测试覆盖功能。并且需要使用第三方工具，如 <span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQveC9kZW5vbi8=">Denon<i class="fa fa-external-link-alt"></i></span> 来设置观察模式。</p>
<p>要查看所有测试运行程序选项，请使用 <code>deno test --help</code>。尽管它们非常有限，但是你可能会从 Mocha 之类的程序中了解许多功能。例如，<code>--failfast</code> 将在遇到第一个错误时停止，<code>--filter</code> 可用于过滤要运行的测试。</p>
<p><strong>使用测试运行器</strong></p>
<p>最基本的语法是 <code>deno test</code>。这将运行工作目录中以 <code>_test</code> 或 <code>.test</code> 结尾的所有文件，扩展名为 <code>.js</code>，<code>.ts</code>，<code>.jsx</code> 或 <code>.tsx</code>（例如：<code>example_test.ts</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; assertEquals &#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std/testing/asserts.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line">Deno.test(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;testing example&quot;</span>,</span><br><span class="line">  fn(): <span class="keyword">void</span> &#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    assertEquals(&#123; <span class="attr">hello</span>: <span class="string">&quot;world&quot;</span> &#125;, &#123; <span class="attr">hello</span>: <span class="string">&quot;world&quot;</span> &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果你的代码使用 DOM，则需要使用 <code>lib: [&quot;dom&quot;, &quot;esnext&quot;]</code> 提供自己的 <code>tsconfig.json</code>。我们将在下面详细介绍。</p>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>格式化功能由 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RwcmludC9kcHJpbnQ=">dprint<i class="fa fa-external-link-alt"></i></span> 提供，它是 Prettier 的快速替代品，它克隆了所有已建立的 Prettier 2.0 规则。</p>
<p>要格式化一个或多个文件，请使用 <code>deno fmt &lt;files&gt;</code> 或 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWF4ZXRyb3kudnNjb2RlLWRlbm8=">Visual Studio Code<i class="fa fa-external-link-alt"></i></span> 插件。</p>
<h3 id="打包编译"><a href="#打包编译" class="headerlink" title="打包编译"></a>打包编译</h3><p>Deno 可以使用 <code>deno bundle</code> 从命令行创建一个简单的打包文件，但是它也公开了一个<span class="exturl" data-url="aHR0cHM6Ly9kZW5vLmxhbmQvc3RkL21hbnVhbC5tZCNjb21waWxlci1hcGk=">内部编译器 API<i class="fa fa-external-link-alt"></i></span>，因此用户可以构建自己的输出。该 API 目前被标记为不稳定，因此你需要使用 <code>--unstable</code> 标识。</p>
<p>尽管 Deno 具有一些与 Web 兼容的 API，但它们并不完整。如果要编译任何引用 DOM 的前端 TypeScript，则需要在打包编译时告知 Deno 这些类型。你可以使用编译器 API 选项 <code>lib</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;greeter&quot;</span>&gt;</span>Replace me<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test-dom.ts</span></span><br><span class="line"><span class="keyword">let</span> greeter: HTMLElement | <span class="literal">null</span> = <span class="built_in">document</span>.getElementById(<span class="string">&quot;greeter&quot;</span>)!; <span class="comment">// Please forgive the Non-Null Assertion Operator</span></span><br><span class="line"></span><br><span class="line">greeter.innerText = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">compile.ts</span><br><span class="line"><span class="keyword">const</span> [errors, emitted] = <span class="keyword">await</span> Deno.compile(<span class="string">&quot;test-dom.ts&quot;</span>, <span class="literal">undefined</span>, &#123;</span><br><span class="line">  <span class="attr">lib</span>: [<span class="string">&quot;dom&quot;</span>, <span class="string">&quot;esnext&quot;</span>], <span class="comment">// include &quot;deno.ns&quot; for deno namespace</span></span><br><span class="line">  <span class="attr">outDir</span>: <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errors) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;There was an error:&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.error(errors);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(emitted); <span class="comment">// normally we would write the file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是终端中的输出结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> dist/test-dom.js.map: <span class="string">&quot;&#123;&quot;</span>version<span class="string">&quot;:3,&quot;</span>file<span class="string">&quot;:&quot;</span>test-dom.js<span class="string">&quot;,&quot;</span>sourceRoot<span class="string">&quot;:&quot;</span><span class="string">&quot;,&quot;</span>sources<span class="string">&quot;:[&quot;</span>file:///home/david/Downloads/deno-arti...<span class="string">&quot;,</span></span><br><span class="line"><span class="string"> dist/test-dom.js: &quot;</span><span class="string">&quot;use strict&quot;</span>;nlet greeter = document.getElementById(<span class="string">&quot;greeter&quot;</span>);ngreeter.innerText = <span class="string">&quot;Hello world!&quot;</span>;n...<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们编译了引用 DOM 的 <code>test-dom.ts</code> 文件。在 <code>Deno.compile()</code> 中使用 <code>lib</code> 选项会覆盖 Deno 使用的所有 <code>lib</code> 默认选项，因此你需要重新添加 <code>esnext</code> 和 <code>deno.ns</code> 才能使用 Deno 命名空间。</p>
<p>这一切仍然是试验性的，我们希望 <code>bundle</code> 命令能够发展，以处理诸如 <code>tree shaking</code> 之类的事情，并更像 <code>Rollup.js</code>。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>Deno 内置调试功能，但就目前而言，Visual Studio Code 扩展仍不支持它。要调试，请手动使用以下命令。</p>
<ul>
<li><code>deno run -A --inspect-brk fileToDebug.ts</code> 对模块使用最低权限</li>
<li>在 Chrome 或 Chromium 中打开 <code>chrome://inspect</code>。你会看到如下内容</li>
</ul>
<img data-src="http://cdn.kingmui.cn/deno-inspect-with-chrome.png" class="">

<ul>
<li>单击 <code>inspect</code> 以连接并开始调试你的代码</li>
</ul>
<h3 id="安装-VSCode-插件"><a href="#安装-VSCode-插件" class="headerlink" title="安装 VSCode 插件"></a>安装 VSCode 插件</h3><p>由于 <code>import url</code> 的形式和 Deno 全局对象并未被 VSCode 支持，所以需要借助插件 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWF4ZXRyb3kudnNjb2RlLWRlbm8=">Deno<i class="fa fa-external-link-alt"></i></span> 进行支持。</p>
<div class="note warning"><p>注意：需要到 settings 中将 <code>deno.enabled</code> 设置为 <code>true</code> </p>
</div>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .vscode/settings.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;deno.enable&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事实证明，前端生态圈的新技术涌现是好事。从积极的一面来看，我们将有更多更高质量的库的选择权利。但消极的一面是，不断涌现的新框架和库也增加了前端的学习成本。</p>
<p>Deno 成功地解决了 JavaScript 开发中的许多痛点。例如：</p>
<ul>
<li>通过使用 Web 标准，Deno 的 API 将面向未来。这使开发人员有信心，他们不会浪费时间在学习即将过时的东西</li>
<li>原生支持 TypeScript，提供的编译期类型检查可以将大幅减少软件 bug</li>
<li>内置工具意味着无需浪费时间寻找开箱即用的产品</li>
<li>分散式软件包管理使用户从 npm 中解放出来，与使用过时的 CommonJS 规范相比，ECMAScript 模块规范带来了新鲜的空气</li>
</ul>
<p>尽管 Deno 在短时间内还不能完全替代 Node.js，但它已经成为日常使用的绝佳编程环境。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
        <tag>deno</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全总结</title>
    <url>/2020/03/21/front-end-security-summary/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>随着互联网的高速发展，网络迅速普及。人们在享受网络带来便捷的同时，也面临着日益严重的网络安全问题。在一些出名的案例中，上百万的密码、邮件地址和信用卡信息被泄露给了公众，导致网站用户面临个人尴尬和财务威胁。在移动互联网时代，前端人员除了传统的 XSS、CSRF 等安全问题之外，又时常遭遇网络劫持等新型安全问题。当然，浏览器自身也在不断地进化和发展，引入内容安全策略（Content Security Policy）、Same-Site Cookies 等新技术来增强安全性，但是仍存在很多潜在的威胁，这需要前端开发人员不断进行“查漏补缺”。</p>
</div>

<p>本文介绍以下几种常见的前端安全问题及其解决方案：</p>
<ol>
<li>同源策略</li>
<li>XSS</li>
<li>CSRF</li>
<li>SQL 注入</li>
<li>点击劫持</li>
<li><code>window.opener</code> 安全问题</li>
<li>文件上传漏洞</li>
</ol>
<span id="more"></span>

<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvU2VjdXJpdHkvU2FtZS1vcmlnaW5fcG9saWN5">同源策略<i class="fa fa-external-link-alt"></i></span></h3><div class="note "><p>同源的定义：如果两个 URL 的<strong>协议</strong>、<strong>域名</strong>和<strong>端口</strong>都相同的话，则这两个 URL 是同源。</p>
</div>

<p>同源策略是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
<ul>
<li>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作</li>
<li>同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据</li>
<li>同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点</li>
</ul>
<p>解决方案：</p>
<ol>
<li><strong>跨文档消息机制</strong>：可以通过 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dpbmRvdy9wb3N0TWVzc2FnZQ==">window.postMessage<i class="fa fa-external-link-alt"></i></span> 安全地实现跨源通信</li>
<li><strong>跨域资源共享（CORS）</strong>：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9BY2Nlc3NfY29udHJvbF9DT1JT">跨域资源共享<i class="fa fa-external-link-alt"></i></span>是一种机制，它使用额外的 HTTP 头（<code>Access-Control-Allow-Origin: *</code>）来告诉浏览器让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源</li>
<li><strong>内容安全策略（CSP）</strong>：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9DU1A=">内容安全策略<i class="fa fa-external-link-alt"></i></span>是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。HTTP 响应头 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtU2VjdXJpdHktUG9saWN5">Content-Security-Policy<i class="fa fa-external-link-alt"></i></span> 允许站点管理者控制用户代理能够为指定的页面加载哪些资源</li>
<li><strong>JSONP</strong>：JSONP（JSON with Padding）是 JSON 的一种“使用模式”，可以让网页从别的域名获取资料，即跨域读取数据。原理是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的“漏洞”来达到与第三方通讯的目的。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.src = <span class="string">&#x27;https://api.cross-domain.com?callback=jsonp&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跨站脚本攻击（Cross-Site-Scripting）"><a href="#跨站脚本攻击（Cross-Site-Scripting）" class="headerlink" title="跨站脚本攻击（Cross Site Scripting）"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9Dcm9zcy1zaXRlX3NjcmlwdGluZw==">跨站脚本攻击<i class="fa fa-external-link-alt"></i></span>（Cross Site Scripting）</h3><p>XSS 是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。根据开放式 Web 应用安全项目（OWASP），XSS 在 2017 年被认为是 <span class="exturl" data-url="aHR0cHM6Ly9vd2FzcC5vcmcvd3d3LXByb2plY3QtdG9wLXRlbi9PV0FTUF9Ub3BfVGVuXzIwMTcvVG9wXzEwLTIwMTdfQTctQ3Jvc3MtU2l0ZV9TY3JpcHRpbmdfKFhTUyUyOQ==">7 种最常见的 Web 应用程序漏洞之一<i class="fa fa-external-link-alt"></i></span>。</p>
<p>如果 Web 应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。浏览器无法探测到这些恶意脚本是不可信的，所以，这些脚本可以任意读取 cookie，session tokens，或者其它敏感的网站信息，或者让恶意脚本重写 HTML 内容。</p>
<p>在以下2种情况下，容易发生 XSS 攻击：</p>
<ol>
<li>数据从一个不可靠的链接进入到一个 Web 应用程序</li>
<li>没有过滤掉恶意代码的动态内容被发送给 Web 用户</li>
</ol>
<p>恶意内容一般包括 JavaScript，但是，有时候也会包括 HTML，FLASH 或是其他浏览器可执行的代码。XSS 攻击的形式千差万别，但他们通常都会：将 cookies 或其他隐私信息发送给攻击者，将受害者重定向到由攻击者控制的网页，或是经由恶意网站在受害者的机器上进行其他恶意操作。</p>
<p>XSS 有三种形式，通常针对用户的浏览器。</p>
<h4 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h4><p>利用漏洞提交恶意 JavaScript 代码，例如在 <code>input</code>，<code>textarea</code> 等所有可能输入文本信息的区域，输入 <code>&lt;script src=&quot;http://恶意网站&quot;&gt;&lt;/script&gt;</code> 等，提交后信息会存在服务器中，当用户再次打开网站请求到相应的数据时，恶意脚本就会将用户的 Cookie 信息等数据上传到黑客服务器。</p>
<h4 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h4><p>用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于这些不明链接我们一定要慎之又慎。</p>
<p>Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。</p>
<h4 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h4><p>通过修改原始的客户端代码，受害者浏览器的 DOM 环境改变，导致有效载荷的执行。也就是说，页面本身并没有变化，但由于DOM环境被恶意修改，有客户端代码被包含进了页面，并且意外执行。</p>
<h4 id="预防策略"><a href="#预防策略" class="headerlink" title="预防策略"></a>预防策略</h4><ol>
<li>将 Cookie 等敏感信息设置为 <code>httponly</code>，禁止 JavaScript 通过 <code>document.cookie</code> 获得</li>
<li>对所有的输入做严格的校验尤其是在服务器端，<strong>过滤掉任何不合法的输入</strong>，比如手机号必须是数字，通常可以采用正则表达式</li>
<li>删除或禁用任何可能包含可运行代码指令的标记。对 HTML 来说，这些包括类似 <code>&lt;script&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code> 和 <code>&lt;link&gt;</code> 的标签</li>
<li><strong>转义单引号、双引号和尖括号等特殊字符</strong>，可以采用 <code>encodeURIComponent</code> 编码，或者过滤掉这些特殊字符</li>
<li>启用内容安全策略（CSP）作为针对 XSS 攻击的深度防御控制。主要以白名单的形式配置可信任的内容来源。在网页中，能够使白名单中的内容正常执行（包含 JS，CSS，Image 等），而非白名单的内容无法正常执行，从而减少 XSS 攻击，当然，也能够减少运营商劫持的内容注入攻击</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// header</span><br><span class="line">Content-Security-Policy: default-src https:</span><br><span class="line"></span><br><span class="line">// meta tag</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src https:&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="跨站请求伪造（Cross-site-request-forgery）"><a href="#跨站请求伪造（Cross-site-request-forgery）" class="headerlink" title="跨站请求伪造（Cross-site request forgery）"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9DU1JG">跨站请求伪造<i class="fa fa-external-link-alt"></i></span>（Cross-site request forgery）</h3><h4 id="小明的悲惨遭遇"><a href="#小明的悲惨遭遇" class="headerlink" title="小明的悲惨遭遇"></a>小明的悲惨遭遇</h4><p>这一天，小明同学百无聊赖地刷着 Gmail 邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意：</p>
<div class="note "><p>甩卖比特币，一个只要998！！</p>
</div>

<p>聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的心态点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生……</p>
<p>在这平静的外表之下，黑客的攻击已然得手。小明的 Gmail 中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被自动转发到 <code>haker AT hackermail.com</code>。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。</p>
<p>不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。</p>
<p>小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cf2_emc&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cf2_email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker@hakermail.com&quot;</span>/&gt;</span></span><br><span class="line">  .....</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;irf&quot;</span> <span class="attr">value</span>=<span class="string">&quot;on&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;nvp_bu_cftb&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Create Filter&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.forms[<span class="number">0</span>].submit();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>这个页面只要打开，就会向 Gmail 发送一个 Post 请求。请求中，执行了 “Create Filter” 命令，将所有的邮件，转发到 “hacker AT hakermail.com”</li>
<li>小明由于刚刚就登陆了 Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail 的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器</li>
<li>黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己</li>
</ol>
<p>小明很快打开 Gmail，找到了那条过滤器，将其删除。然而，已经泄露的邮件，已经被转让的域名，再也无法挽回了……</p>
<p>以上就是小明的悲惨遭遇。而“点开一个黑客的链接，所有邮件都被窃取”这种事情并不是杜撰的，此事件原型是 2007 年 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF2aWRhaXJleS5jb20vZ29vZ2xlLWdtYWlsLXNlY3VyaXR5LWhpamFjay8=">Gmail 的 CSRF 漏洞<i class="fa fa-external-link-alt"></i></span>。</p>
<h4 id="什么是-CSRF"><a href="#什么是-CSRF" class="headerlink" title="什么是 CSRF"></a>什么是 CSRF</h4><div class="note "><p>CSRF（Cross-site request forgery）跨站请求伪造：<strong>攻击者诱导受害者进入第三方网站</strong>，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，<strong>绕过后台的用户验证</strong>，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
</div>

<p>一个典型的 CSRF 攻击有着如下的流程：</p>
<ol>
<li>受害者登录 a.com，并保留了登录凭证（Cookie）</li>
<li>攻击者引诱受害者访问了 b.com</li>
<li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie</li>
<li>a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li>
<li>a.com 以受害者的名义执行了 act=xx</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com ∂执行了自己定义的操作</li>
</ol>
<h4 id="几种常见的攻击类型"><a href="#几种常见的攻击类型" class="headerlink" title="几种常见的攻击类型"></a>几种常见的攻击类型</h4><ul>
<li>GET 类型的 CSRF</li>
</ul>
<p>GET 类型的 CSRF 利用非常简单，只需要一个 HTTP 请求，一般会这样利用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>在受害者访问含有这个 img 的页面后，浏览器会自动发出一次 HTTP 请求。bank.example 就会收到包含受害者登录信息的一次跨域请求</p>
<ul>
<li>POST 类型的 CSRF</li>
</ul>
<p>这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.example/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。</p>
<p>POST 类型的攻击通常比 GET 要求更加严格一点，但仍不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 POST 上面。</p>
<ul>
<li>链接类型的 CSRF</li>
</ul>
<p>链接类型的 CSRF 并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">重磅消息！！</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于之前用户登录了信任的网站 A，并且保存登录状态，只要用户主动访问上面的这个 PHP 页面，则表示攻击成功。</p>
<h4 id="CSRF-的特点"><a href="#CSRF-的特点" class="headerlink" title="CSRF 的特点"></a>CSRF 的特点</h4><ul>
<li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生</li>
<li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据</li>
<li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”</li>
<li>跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪</li>
</ul>
<p>发起 CSRF 攻击的三个必要条件：</p>
<ol>
<li>目标站点一定要有 CSRF 漏洞</li>
<li>用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态</li>
<li>需要用户打开一个第三方站点，如黑客的站点等</li>
</ol>
<h4 id="预防策略-1"><a href="#预防策略-1" class="headerlink" title="预防策略"></a>预防策略</h4><p>CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。</p>
<ol>
<li><strong>充分利用好 Cookie 的 SameSite 属性</strong></li>
</ol>
<ul>
<li>SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie</li>
<li>Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie</li>
<li>如果使用 None 的话，在任何情况下都会发送 Cookie 数据</li>
</ul>
<ol start="2">
<li><strong>验证请求的来源站点</strong></li>
</ol>
<p>在服务器端验证请求来源的站点，即请求头中的 <code>Origin</code> 和 <code>Referer</code> 属性。<code>Referer</code> 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的<strong>来源地址</strong>，而 <code>Origin</code> 属性只包含了<strong>域名信息</strong>，并没有包含具体的 URL 路径。服务器的策略是优先判断 <code>Origin</code>，如果请求头中没有包含 <code>Origin</code> 属性，再根据实际情况判断是否使用 <code>Referer</code> 值。</p>
<p>Origin 在以下两种情况下并不存在：</p>
<ul>
<li><p><strong>IE11同源策略</strong>：IE 11 不会在跨站 CORS 请求上添加 Origin 标头，Referer 属性将仍然是唯一的标识。最根本原因是因为 IE 11 对同源的定义和其他浏览器有不同，有两个主要的区别：</p>
<ul>
<li>授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），则不受同源策略限制</li>
<li>端口：IE 未将端口号纳入到同源策略的检查中，因此 <code>https://company.com:81/index.html</code> 和 <code>https://company.com/index.html</code> 属于同源并且不受任何限制</li>
</ul>
</li>
<li><p><strong>302重定向</strong>：在 302 重定向之后 Origin 不包含在重定向的请求中，因为 Origin 可能会被认为是其他来源的敏感信息。对于 302 重定向的情况来说都是定向到新的服务器上的 URL，因此浏览器不想将 Origin 泄漏到新的服务器上</p>
</li>
</ul>
<ol start="3">
<li><strong>CSRF Token</strong></li>
</ol>
<p>前面讲到 CSRF 的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用 Cookie 中的信息。</p>
<p>而 CSRF 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 的攻击。</p>
<ol start="4">
<li><strong>在 HTTP 头中自定义属性并验证</strong></li>
</ol>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 <code>csrftoken</code> 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去</p>
<p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL 注入漏洞使得恶意用户能够通过在数据库上执行任意 SQL 代码，从而允许访问、修改或删除数据，而不管该用户的权限如何。成功的注入攻击可能会伪造身份信息、创建拥有管理员权限的身份、访问服务器上的任意数据甚至破坏或修改数据使其变得无法使用。</p>
<p>拼接 SQL 时未仔细过滤，黑客可提交畸形数据改变语义。例如查询某篇文章，提交了这样的数据 <code>id=-1 or 1=1</code> 等。由于 <code>1=1</code> 恒真，导致 <code>where</code> 语句永远是 ture，那么查询的结果相当于整张表的内容，攻击者就达到了目的。或者，通过屏幕上的报错提示推测 SQL 语句等。</p>
<h4 id="预防策略-2"><a href="#预防策略-2" class="headerlink" title="预防策略"></a>预防策略</h4><ol>
<li>禁止目标网站利用动态拼接字符串的方式访问数据库</li>
<li>减少不必要的数据库抛出的错误信息</li>
<li>对数据库的操作赋予严格的权限控制</li>
<li>净化和过滤掉不必要的 SQL 保留字，例如：where、or、exec 等</li>
</ol>
<h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><ol>
<li>诱使用户点击看似无害的按钮（实则点击了透明 iframe 中的按钮）</li>
<li>监听鼠标移动事件，让危险按钮始终在鼠标下方</li>
<li>使用 HTML5 拖拽技术执行敏感操作（例如 deploy key）</li>
</ol>
<h4 id="预防策略-3"><a href="#预防策略-3" class="headerlink" title="预防策略"></a>预防策略</h4><ol>
<li>服务端添加 <code>X-Frame-Options</code> 响应头，这个 HTTP 响应头是为了防御用 iframe 嵌套的点击劫持攻击。这样浏览器就会阻止嵌入网页的渲染</li>
<li>JS 判断顶层视口的域名是不是和本页面的域名一致，不一致则不允许操作，<code>top.location.hostname === self.location.hostname</code></li>
<li>敏感操作使用更复杂的步骤（验证码、输入项目名称以删除）</li>
</ol>
<h3 id="window-opener-安全问题"><a href="#window-opener-安全问题" class="headerlink" title="window.opener 安全问题"></a><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dpbmRvdy9vcGVuZXI=">window.opener<i class="fa fa-external-link-alt"></i></span> 安全问题</h3><p><code>window.opener</code> 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 <code>target=&quot;_blank&quot;</code> 的 <code>&lt;a&gt;</code> 标签打开了一个新的页面 B，那么在 B 页面里，<code>window.opener</code> 的值为 A 页面的 <code>window</code> 对象。</p>
<p>一般来说，打开同源的页面，不会有什么问题。但对于跨域的外部链接来说，存在一个被钓鱼的风险。比如你正在浏览购物网站，从当前网页打开了某个外部链接，在打开的外部页面，可以通过 <code>window.opener.location</code> 改写来源站点的地址。利用这一点，将来源站点改写到钓鱼站点页面上，例如跳转到伪造的高仿购物页面，当再回到购物页面的时候，是很难发现购物网站的地址已经被修改了的，这个时候你的账号就存在被钓鱼的可能了。</p>
<h4 id="预防策略-4"><a href="#预防策略-4" class="headerlink" title="预防策略"></a>预防策略</h4><ol>
<li>设置 rel=noopener 属性</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 值为 null --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://xxxx&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noopener noreferrer&quot;</span>&gt;</span> 外链 <span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将外链替换为内部的跳转连接服务，跳转时先跳到内部地址，再由服务器 redirect 到外链</li>
<li>可以由 <code>widow.open</code> 打开外链</li>
</ol>
<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>服务器未校验上传的文件，致使黑客可以上传恶意脚本。</p>
<h4 id="预防策略-5"><a href="#预防策略-5" class="headerlink" title="预防策略"></a>预防策略</h4><ol>
<li>用文件头来检测文件类型，使用白名单过滤</li>
<li>上传后将文件彻底重命名并移动到不可执行的目录下</li>
<li>升级服务器软件以避免路径解析漏洞</li>
<li>升级用到的开源编辑器</li>
<li>管理后台设置强密码</li>
</ol>
]]></content>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS下使用国内镜像安装Homebrew</title>
    <url>/2019/11/23/macOS%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85Homebrew/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="http://cdn.kingmui.cn/macos-install-homebrew.png" class="">

<p>Homebrew 是一款自由及开放源代码的软件包管理系统，用以简化 macOS 系统上的软件安装过程。它拥有安装、卸载、更新、查看、搜索等很多实用的功能，通过简单的一条指令，就可以实现包管理，十分方便快捷。</p>
<h3 id="获取最新安装脚本到本地编辑"><a href="#获取最新安装脚本到本地编辑" class="headerlink" title="获取最新安装脚本到本地编辑"></a>获取最新安装脚本到本地编辑</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line"></span><br><span class="line">curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install &gt;&gt; brew_install</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>编辑 brew_install 文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/ruby</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This script installs to /usr/<span class="built_in">local</span> only. To install elsewhere (<span class="built_in">which</span> is</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> unsupported) you can untar https://github.com/Homebrew/brew/tarball/master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> anywhere you like.</span></span><br><span class="line">HOMEBREW_PREFIX = &quot;/usr/local&quot;.freeze</span><br><span class="line">HOMEBREW_REPOSITORY = &quot;/usr/local/Homebrew&quot;.freeze</span><br><span class="line">HOMEBREW_CACHE = &quot;#&#123;ENV[&quot;HOME&quot;]&#125;/Library/Caches/Homebrew&quot;.freeze</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注释掉下面这行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> BREW_REPO = <span class="string">&quot;https://github.com/Homebrew/brew&quot;</span>.freeze</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换USTC镜像</span></span><br><span class="line">BREW_REPO = &quot;https://mirrors.ustc.edu.cn/brew.git&quot;.freeze</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或替换为阿里镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> BREW_REPO = <span class="string">&quot;https://mirrors.aliyun.com/homebrew/brew.git&quot;</span>.freeze</span></span><br></pre></td></tr></table></figure>

<h3 id="执行修改后的脚本安装"><a href="#执行修改后的脚本安装" class="headerlink" title="执行修改后的脚本安装"></a>执行修改后的脚本安装</h3><ol>
<li><code>/usr/bin/ruby ~/brew_install</code></li>
<li>当出现 <code>Cloning into &#39;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&#39;...</code> 就不用等了… 等不到的…</li>
<li><code>Command + C</code> 停止</li>
<li><code>cd &quot;$(brew --repo)/Library/Taps/&quot;</code></li>
<li><code>mkdir homebrew</code></li>
<li><code>cd homebrew</code></li>
<li><code>git clone https://mirrors.ustc.edu.cn/homebrew-core.git</code></li>
<li>继续执行 <code>/usr/bin/ruby ~/brew_install</code></li>
<li>看到 <code>Installation successful!</code> 就安装成功了</li>
</ol>
<h3 id="修改-Homebrew-源为国内镜像"><a href="#修改-Homebrew-源为国内镜像" class="headerlink" title="修改 Homebrew 源为国内镜像"></a>修改 Homebrew 源为国内镜像</h3><h4 id="替换-Homebrew-默认源"><a href="#替换-Homebrew-默认源" class="headerlink" title="替换 Homebrew 默认源"></a>替换 Homebrew 默认源</h4><p>替换USTC镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br></pre></td></tr></table></figure>

<p>重置为官方地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git</span><br></pre></td></tr></table></figure>

<h4 id="Homebrew-核心软件仓库"><a href="#Homebrew-核心软件仓库" class="headerlink" title="Homebrew 核心软件仓库"></a>Homebrew 核心软件仓库</h4><p>替换 USTC 镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 阿里镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://mirrors.aliyun.com/homebrew/homebrew-core.git</span></span><br></pre></td></tr></table></figure>

<p>重置为官方地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core</span><br></pre></td></tr></table></figure>

<h4 id="Homebrew-预编译二进制软件包"><a href="#Homebrew-预编译二进制软件包" class="headerlink" title="Homebrew 预编译二进制软件包"></a>Homebrew 预编译二进制软件包</h4><p>请在运行 brew 前设置环境变量 <code>HOMEBREW_BOTTLE_DOMAIN</code>，值为 <code>https://mirrors.ustc.edu.cn/homebrew-bottles</code>。</p>
<p>对于 bash 用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 阿里镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://mirrors.aliyun.com/homebrew/homebrew-bottles</span></span><br></pre></td></tr></table></figure>

<p>对于 zsh 用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<h4 id="Homebrew-cask-软件仓库，提供-macOS-应用和大型二进制文件"><a href="#Homebrew-cask-软件仓库，提供-macOS-应用和大型二进制文件" class="headerlink" title="Homebrew cask 软件仓库，提供 macOS 应用和大型二进制文件"></a>Homebrew cask 软件仓库，提供 macOS 应用和大型二进制文件</h4><p>替换为 USTC 镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;/Library/Taps/homebrew/homebrew-cask</span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br></pre></td></tr></table></figure>

<p>重置为官方地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;/Library/Taps/homebrew/homebrew-cask</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-cask</span><br></pre></td></tr></table></figure>

<h4 id="应用生效"><a href="#应用生效" class="headerlink" title="应用生效"></a>应用生效</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure>

<h3 id="Homebrew-基本用法"><a href="#Homebrew-基本用法" class="headerlink" title="Homebrew 基本用法"></a>Homebrew 基本用法</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>更新 Homebrew</td>
<td><code>brew update</code></td>
</tr>
<tr>
<td>更新所有安装过的软件包</td>
<td><code>brew upgrade</code></td>
</tr>
<tr>
<td>更新指定的软件包</td>
<td><code>brew upgrade wget</code></td>
</tr>
<tr>
<td>查找软件包</td>
<td><code>brew search wget</code></td>
</tr>
<tr>
<td>安装软件包</td>
<td><code>brew install wget</code></td>
</tr>
<tr>
<td>卸载软件包</td>
<td><code>brew remove wget</code></td>
</tr>
<tr>
<td>列出已安装的软件包</td>
<td><code>brew list</code></td>
</tr>
<tr>
<td>查看软件包信息</td>
<td><code>brew info wget</code></td>
</tr>
<tr>
<td>列出软件包的依赖关系</td>
<td><code>brew deps wget</code></td>
</tr>
<tr>
<td>列出可以更新的软件包</td>
<td><code>brew outdated</code></td>
</tr>
</tbody></table>
<h3 id="卸载-Homebrew"><a href="#卸载-Homebrew" class="headerlink" title="卸载 Homebrew"></a>卸载 Homebrew</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnVzdGMuZWR1LmNuL2hlbHAvYnJldy5naXQuaHRtbA==">Homebrew 源使用帮助<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9taXJyb3Iv">阿里云官方镜像站<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL21pcnJvcnMudXN0Yy5lZHUuY24v">中国科学技术大学开源软件镜像<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuLw==">清华大学开源软件镜像站<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS 模块和 ES6 模块的区别</title>
    <url>/2020/08/04/the-difference-between-commonjs-mdule-and-es6-module/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>历史上，JS 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 <code>require</code>、Python 的 <code>import</code>，甚至就连 CSS 都有 <code>@import</code>，但是 JS 任何这方面的支持都没有，这对开发大型复杂的项目形成了巨大障碍。</p>
<p>在 ES6 出来之前，社区制定了一些模块加载方案，最主要的有 <strong>CommonJS</strong> 和 <strong>AMD</strong> 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得<mark class="label info">编译时就能确定模块的依赖关系</mark>，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在<strong>运行时</strong>确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommonJS 模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">const</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">const</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure>

<p>上述代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上读取3个方法。这种加载称为<strong>运行时加载</strong>，因为只有运行时才能得到这个对象，导致完全<strong>没办法在编译时做静态优化</strong>。</p>
<p>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; stat, exists, readfile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码的实质是从 fs 模块加载3个方法，其他方法不加载。这种加载称为<strong>编译时加载</strong>或者静态加载，即 <mark class="label info">ES6 可以在编译时就完成模块加载</mark>，效率比 CommonJS 模块的加载方式高。当然，这也导致了无法引用 ES6 模块本身，因为它不是对象。</p>
<p>由于 ES6 模块是编译时加载，<strong>使得静态分析成为可能</strong>。有了它，就能进一步拓宽 JS 的语法，比如引入宏（macro）和类型检查（type system）这些只能靠静态分析实现的功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不会报错，因为 import 的执行早于 foo 的调用</span></span><br><span class="line"><span class="comment">// 这种行为的本质是，import 命令是编译阶段执行的，在代码运行之前</span></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// import 命令具有提升效果，会提升到整个模块的头部，首先执行</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import 语句会执行所加载的模块，以下代码仅仅执行 lodash 模块，但是不输入任何值</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="comment">// 如果多次重复执行同一句 import 语句，那么只会执行一次</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import 语句是 Singleton 模式</span></span><br><span class="line"><span class="keyword">import</span> &#123; func1 &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; func2 &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>import</code> 和 <code>export</code> 命令<strong>只能在模块的顶层</strong>，不能在代码块之中（如在 if 代码块之间或在函数之中）。这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果 <code>import</code> 命令要取代 Node 的 <code>require</code> 方法，这就现成了一道障碍。因为 <code>require</code> 是运行时加载模块，<code>import</code> 命令无法取代 <code>require</code> 的动态加载功能。</p>
<p>ES2020 提案引入 <code>import()</code> 函数，支持动态加载模块。<code>import</code> 命令能接受什么参数，<code>import()</code> 函数就能接受什么参数。两者区别主要是<strong>后者为动态加载</strong>。<code>import()</code> 返回一个 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"><span class="comment">// import() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用</span></span><br><span class="line"><span class="comment">// 它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块</span></span><br><span class="line"><span class="comment">// import() 函数与所加载的模块没有静态连接关系，这点也与 import 语句不相同</span></span><br><span class="line"><span class="comment">// import() 函数类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">module</span>.loadPageInfo(main);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        main.textContent = err.message;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用场景</span></span><br><span class="line"><span class="comment">// 1. 按需加载</span></span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./dialogBox.js&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">dialogBox</span> =&gt;</span> &#123;</span><br><span class="line">        dialogBox.open();</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 条件加载</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;moduleA&#x27;</span>).then(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 动态的模块路径</span></span><br><span class="line"><span class="comment">// import() 允许模块路径动态生成</span></span><br><span class="line"><span class="keyword">import</span>(getPath())</span><br><span class="line">.then(...);</span><br></pre></td></tr></table></figure>

<p>除了静态加载带来的各种好处，ES6 模块还有以下好处：</p>
<ol>
<li>不再需要 UMD 模块格式，将来服务器和浏览器都会支持 ES6 模块格式</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再需要做成全局变量或者 <code>navigator</code> 对象的属性</li>
<li>不再需要对象作为命名空间（比如 <code>Math</code> 对象），未来这些功能都可以通过模块提供</li>
</ol>
<h4 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h4><p>HTML 网页中，浏览器通过 <code>&lt;script&gt;</code> 标签加载 JS 脚本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// module code</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，由于浏览器脚本的默认语言是 JS，因此 <code>type=&quot;application/javascript&quot;</code> 可以省略。</p>
<p>默认情况下，浏览器是<strong>同步加载</strong> JS 脚本，即渲染引擎遇到 <code>&lt;script&gt;</code> 标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入<strong>脚本下载的时间</strong>。如果脚本体积很大，下载和执行的时间就会很长，因而造成浏览器阻塞，用户会感觉到浏览器“卡死”，没有任何响应。这显然是很不好的用户体验，所以浏览器允许脚本异步加载，下面就是两种<strong>异步加载</strong>的语法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- script 标签打开 defer、async 属性，脚本就会异步加载 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 渲染引擎遇到这一行命令，就会开始下载异步脚本，但不会等它下载和执行，而是直接执行后面的命令 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>defer 与 async 的区别：</p>
<ol>
<li>defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行。多个 defer 会按它们在页面出现的顺序加载。是<mark class="label info">渲染完再执行</mark>。</li>
<li>async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个 async 脚本不能保证加载顺序。是<mark class="label info">下载完就执行</mark>。</li>
</ol>
<h4 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h4><p>浏览器加载 ES6 模块，也可以使用 <code>&lt;script&gt;</code> 标签，但是要加入 <code>type=&quot;module&quot;</code> 属性。浏览器对于带有 <code>type=&quot;module&quot;</code> 的 <code>&lt;script&gt;</code>，都是<strong>异步加载</strong>，不会阻塞浏览器，等同于打开了 <code>&lt;script&gt;</code> 标签的 defer 属性。有多个 <code>type=&quot;module&quot;</code> 的标签，它们会按照在页面出现的顺序依次执行，如果显式指定了 async 则不会按顺序执行。</p>
<p>ES6 模块 也<strong>允许内嵌在网页中</strong>，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&#x27;#message&#x27;</span>).text(<span class="string">&#x27;Hello World&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于外部的模块脚本，有几点注意事项：</p>
<ol>
<li>代码是在<strong>模块作用域</strong>之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见</li>
<li>模块脚本<strong>自动采用严格模块</strong>，不管有没有声明 <code>use strict</code></li>
<li>模块之中，可以使用 <code>import</code> 命令加载其他模块（.js 后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用 <code>export</code> 命令输出对外接口</li>
<li>模块之中，顶层的 <code>this</code> 关键字返回 <code>undefined</code>，而不是指向 <code>window</code>。利用这个语法点，可以侦测当前代码是否运行在 ES6 模块之中</li>
<li>同一个模块如果加载多次，将只执行一次</li>
</ol>
<h4 id="NodeJS-加载"><a href="#NodeJS-加载" class="headerlink" title="NodeJS 加载"></a>NodeJS 加载</h4><p>NodeJS 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，从 V13.2 版本开始，NodeJS 已经默认打开了 ES6 模块支持。</p>
<p>NodeJS 要求 ES6 模块采用 <code>.mjs</code> 后缀文件名。也就是说，只要脚本文件里面使用 <code>import</code> 或 <code>export</code> 命令，那么就必须采用 <code>.mjs</code> 后缀名。NodeJS 遇到 <code>.mjs</code> 文件，就认为它是 ES6 模块，默认启用严格模式。如果不希望将后缀名改成 <code>.mjs</code>，可以在项目的 <code>package.json</code> 文件中，指定 <code>type</code> 字段为 <code>module</code>。一旦设置了以后，该目录里面的 JS 脚本，就被解释成 ES6 模块。如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成 <code>.cjs</code>。如果没有 <code>type</code> 字段，或者 <code>type</code> 字段为 <code>commonjs</code>，则 <code>.js</code> 脚本会被解释成 CommonJS 模块。</p>
<p>总结：<code>.mjs</code> 文件总是以 ES6 模块加载，<code>.cjs</code> 文件总是以 CommonJS 模块加载，<code>.js</code> 文件的加载取决于 <code>package.json</code> 里面 <code>type</code> 字段的设置。</p>
<h4 id="main-字段"><a href="#main-字段" class="headerlink" title="main 字段"></a>main 字段</h4><p><code>package.json</code> 文件有两个字段可以<strong>指定指定模块的入口文件</strong>：<code>main</code> 和 <code>exports</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exports</code> 字段的优先级高于 <code>main</code> 字段，它有多种用法。</p>
<p>1）子目录别名</p>
<p><code>package.json</code> 文件的 <code>exports</code> 字段可以指定脚本或子目录的别名。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;exports&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;./submodeule&quot;</span>: <span class="string">&quot;./src/submodule.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码指定 <code>./src/submodule.js</code> 别名为 <code>submodeule</code>，然后就可以从别名加载这个文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/submodule&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>2）main 的别名</p>
<p><code>exports</code> 字段的别名如果是 <code>.</code>，就代表模块的主入口，优先级高于 <code>main</code> 字段，并且可以直接简写成 <code>exports</code> 字段的值。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;exports&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;.&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;exports&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>exports</code> 字段只有支持 ES6 的 NodeJS 才认识，所以可以用来兼容旧版本的 NodeJS。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;./main-legacy.cjs&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;exports&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;.&quot;</span>: <span class="string">&quot;./main-modern.cjs&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）条件加载</p>
<p>利用 <code>.</code> 这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 NodeJS 运行的时候，打开 <code>--experimental-conditional-exports</code> 标志。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;exports&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;.&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简写为</span></span><br><span class="line"><span class="comment">// 注意：如果还有其他别名，则不能简写</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;exports&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ES6-模块加载-CommonJS-模块"><a href="#ES6-模块加载-CommonJS-模块" class="headerlink" title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;./index.cjs&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;exports&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;require&quot;</span>: <span class="string">&quot;./index.cjs&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;default&quot;</span>: <span class="string">&quot;./wrapper.mjs&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码指定了 CommonJS 入口文件 <code>index.cjs</code>。下面是这个文件的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/pkg/index.cjs</span></span><br><span class="line"><span class="built_in">exports</span>.name = <span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后，ES6 模块可以加载这个文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/pkg/wrapper.mjs</span></span><br><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">&#x27;./index.cjs&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = cjsModule.name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：import 命令加载 CommonJS 模块，只能整体加载，不能只加载单一的输出项</span></span><br><span class="line"><span class="comment">// 特例：NodeJS 内置模块可以整体加载，也可以加载指定的输出项</span></span><br><span class="line"><span class="comment">// ✅</span></span><br><span class="line"><span class="keyword">import</span> packageMain <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span>;</span><br><span class="line"><span class="comment">// ❎</span></span><br><span class="line"><span class="keyword">import</span> &#123; method &#125; <span class="keyword">from</span> <span class="string">&#x27;commonjs-package&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有一种变通的加载方法，就是使用 NodeJS 内置的 `module.createRequire()` 方法</span></span><br><span class="line"><span class="comment">// ES6 模块通过 `module.createRequire()` 方法可以加载 CommonJS 模块</span></span><br><span class="line"><span class="comment">// cjs.cjs</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;cjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// esm.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = createRequire(<span class="keyword">import</span>.meta.url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">&#x27;./cjs.cjs&#x27;</span>);</span><br><span class="line">cjs === <span class="string">&#x27;cjs&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="CommonJS-模块-加载-ES6-模块"><a href="#CommonJS-模块-加载-ES6-模块" class="headerlink" title="CommonJS 模块 加载 ES6 模块"></a>CommonJS 模块 加载 ES6 模块</h4><p>CommonJS 模块的 <code>require</code> 命令不能加载 ES6 模块。只能使用 <code>import()</code> 这个方法加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-app.mjs&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h4 id="加载路径"><a href="#加载路径" class="headerlink" title="加载路径"></a>加载路径</h4><p>ES6 模块的加载路径必须给出脚本的<strong>完整路径</strong>，不能省略脚本的后缀名。<code>import</code> 命令和 <code>package.json</code> 文件的 <code>main</code> 字段如果省略脚本的后缀名，会报错。</p>
<p>为了与浏览器的 <code>import</code> 加载规则相同，NodeJS 的 <code>.mjs</code> 文件支持 URL 路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo.mjs?query=1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>目前，NodeJS 的 <code>import</code> 命令只支持加载本地模块（file: 协议）和 data: 协议，不支持加载远程模块。此外，脚本路径只支持相对路径，不支持绝对路径（<code>/</code> 或 <code>//</code> 开头的路径）。与浏览器不同的是，NodeJS 的 <code>import</code> 命令是<strong>异步加载</strong>。</p>
<h4 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h4><p>ES6 模块应该是通用的，同一个模块不用修改，就可以运行于浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块特有的一些内部变量。</p>
<p>首先，就是 <code>this</code> 关键字。ES6 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code>；CommonJS 模块的顶层 <code>this</code> 指向当前模块，这是两者的一个重大差异。</p>
<p>其次，以下这些顶层变量在 ES6 模块之中也是不存在的。</p>
<ul>
<li>arguments</li>
<li>require</li>
<li>module</li>
<li>exports</li>
<li>__filename</li>
<li>__dirname</li>
</ul>
<h4 id="循环加载（Circular-Dependency）"><a href="#循环加载（Circular-Dependency）" class="headerlink" title="循环加载（Circular Dependency）"></a>循环加载（Circular Dependency）</h4><p>循环加载指的是，A 脚本的执行依赖 B 脚本，B 脚本的执行又依赖 A 脚本。通常，循环加载表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。但是实际上，这是很难避免的，尤其是依赖关系复杂的大型项目。对于 JS 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，<strong>处理循环加载的方法是不一样的，返回的结果也不一样</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="CommonJS-模块的循环加载"><a href="#CommonJS-模块的循环加载" class="headerlink" title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h4><p>CommonJS 的一个模块，就是一个脚本文件。<code>require</code> 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。以后需要用到这个模块的时候，就会到 <code>exports</code> 属性上面取值。即使再次执行 <code>require</code> 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，<mark class="label info">CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果</mark>，除非手动清除系统缓存。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 模块名</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    <span class="comment">// 模块输出的各种接口</span></span><br><span class="line">    <span class="attr">&quot;exports&quot;</span>: &#123;...&#125;,</span><br><span class="line">    <span class="comment">// 该模块的脚本是否执行完毕</span></span><br><span class="line">    <span class="attr">&quot;loaded&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 <code>require</code> 的时候，就会全部执行。<strong>一旦出现某个模块被循环加载</strong>，就<mark class="label info">只会输出已经执行的部分</mark>，还未执行的部分不会输出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 加载 b.js，此时 a.js 代码就停在这里，等待 b.js 执行完毕，再往下执行</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 a.js 中，b.done = %j&#x27;</span>, b.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 发生了循环加载</span></span><br><span class="line"><span class="comment">// 系统会去 a.js 模块对应的 exports 属性取值，可是因为 a.js 还没有执行完</span></span><br><span class="line"><span class="comment">// 从 exports 属性只能取回已经执行的部分（exports.done = false;），而不是最后的值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="comment">// b.js 接着往下执行，等到全部执行完毕，再把执行权交还给 a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 b.js 中，a.done = %j&#x27;</span>, a.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a.js&#x27;</span>);</span><br><span class="line"><span class="comment">// 这里不会再次执行 b.js，而是输出缓存的 b.js 的执行结果</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;在 main.js 中，a.done=%j，b.done=%j&#x27;</span>, a.done, b.done);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行 main.js</span></span><br><span class="line">node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 中，a.done = false</span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 中，b.done = true</span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 中，a.done=true，b.done=true</span><br></pre></td></tr></table></figure>

<h4 id="ES6-模块的循环加载"><a href="#ES6-模块的循环加载" class="headerlink" title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h4><p>ES6 模块处理循环加载与 CommonJS 模块有本质不同。ES6 模块是动态引用，如果使用 <code>import</code> 从一个模块加载变量 <code>import foo from &#39;foo&#39;</code>，那些变量不会被缓存，而是成为一个指向被加载模块的引用，<strong>需要开发者自己保证，真正取到的时候能够取到值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node --experimental-modules a.mjs</span><br><span class="line"></span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>

<p>首先，执行 <code>a.mjs</code> 后，引擎发现它加载了 <code>b.mjs</code>，因此会优先执行 <code>b.mjs</code>，然后再执行 <code>a.mjs</code>。接着，执行 <code>b.mjs</code> 时，已知它从 <code>a.mjs</code> 输入了 <code>foo</code> 接口，这时不会去执行 <code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行 <code>console.log(foo);</code> 时，才发现这个接口没有定义，因此报错。</p>
<p>解决这个问题的方法，就是让 <code>b.mjs</code> 运行时，<code>foo</code> 已经定义。可以通过将 <code>foo</code> 写成函数来解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; foo &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; bar &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ES6 模块与 CommonJS 模块的差异：</p>
<ol>
<li>当导出的是一个原始类型数据时，CommonJS 模块输出的是值的缓存，不存在动态更新，即输出的是<strong>值的拷贝</strong>，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值；ES6 模块输出的接口，与其对应的值是<mark class="label info">动态绑定关系</mark>，通过该接口，可以取到模块内部实时的值，即输出的是<strong>值的引用</strong>，这个值指向的地址是<strong>只读</strong>的，不能重新赋值</li>
<li>CommonJS 模块是<strong>运行时加载</strong>；ES6 模块是<strong>编译时</strong>输出接口</li>
<li>CommonJS 是单个值导出；ES6 模块可以导出多个</li>
<li>CommonJS 是动态语法，<strong>可以写在条件判断语句中</strong>；ES6 模块是静态语法<strong>只能写在顶层</strong></li>
<li>CommonJS 的 <code>this</code> 指向当前模块；<mark class="label info">ES6 模块自动采用严格模式</mark>，<code>this</code> 指向 <code>undefined</code></li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title>中文简繁体切换功能的实现</title>
    <url>/2018/09/15/%E4%B8%AD%E6%96%87%E7%AE%80%E7%B9%81%E4%BD%93%E5%88%87%E6%8D%A2%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了能够更好地照顾不同的用户，一些网站会提供简繁两种版本切换，提高用户的体验。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一般而言，网站要实现简繁字体的切换，需要先准备两套字体库。而基本的思路是：找到当前文字在字体库中的索引，然后根据索引值去另一套字体库中取出对应的文字，从而实现字体的替换。具体逻辑如下：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exchange</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> simplified = <span class="string">&quot;万与丑&quot;</span>,</span><br><span class="line">    	traditional = <span class="string">&quot;萬與醜&quot;</span>,</span><br><span class="line">    	index,</span><br><span class="line">    	result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = text.length; i &lt; len; i++) &#123;</span><br><span class="line">        index = simplified.indexOf(text[i]);</span><br><span class="line">        result += index === -<span class="number">1</span> ? text[i] : traditional[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，简繁体切换大致可分为3个过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 获取 `body` 标签内的字体内容</span><br><span class="line">- 转换为简体或繁体</span><br><span class="line">- 存储当前的字体类型（状态）</span><br></pre></td></tr></table></figure>

<h3 id="获取页面内容"><a href="#获取页面内容" class="headerlink" title="获取页面内容"></a>获取页面内容</h3><p>毫无疑问，我们所要切换的便是页面中的汉字。众所周知，判断汉字可以使用正则表达式 <code>/[\u4e00-\u9fa5]/g</code> ，而我们首先面临的最大问题正是：如何获取页面中的字体内容？分析网页的结构可得，显示给用户的内容一般都在 <code>&lt;body&gt;</code> 标签中或者其各个子标签中，我们该如何获取这些包裹着内容的标签呢？又该如何判断元素与所需字体呢？</p>
<p>接下来，让我们先来学习两个原生 JS 的 API。</p>
<h4 id="childNodes"><a href="#childNodes" class="headerlink" title="childNodes"></a>childNodes</h4><div class="note info"><p><code>childNodes</code> 属性以 NodeList 对象返回节点的子节点集合，包括元素节点、文本内容、注释、属性等。</p>
</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].childNodes; <span class="comment">// 获取 body 标签的子节点集合</span></span><br></pre></td></tr></table></figure>

<p>我们可以先使用 <code>length</code> 属性来确定子节点的数量，然后遍历所有的子节点，便可得到 <code>body</code> 标签中所有的 DOM 节点以及节点中所需的文本内容。</p>
<h4 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h4><div class="note info"><p><code>nodeType</code> 属性可用来区分不同类型的节点，比如 元素, 文本 和 注释。<br>如果节点是元素节点，则 <code>nodeType</code> 属性将返回 1。<br>如果节点是文本节点，则 <code>nodeType</code> 属性将返回 3。</p>
</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].nodeType === <span class="number">1</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>有了 <code>nodeType</code> 作为当前元素的判断，我们便可轻松的分离出 DOM 节点与文本节点，从而进行不同需求的操作。大致逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateBody</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objs = (obj ? obj : <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>]).childNodes;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; objs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objs[i].nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">            objs[i].textContent = exchange(objs[i].textContent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objs[i].nodeType === <span class="number">1</span> ) &#123;</span><br><span class="line">            translateBody(objs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，我们便得到了所需的文本内容。下面，我们将进行 <code>exchange</code> 函数的编写。</p>
<h3 id="转换简繁字体"><a href="#转换简繁字体" class="headerlink" title="转换简繁字体"></a>转换简繁字体</h3><p>根据上面的总结，<code>exchange</code> 函数编写如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exchange</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>, j,</span><br><span class="line">        s = <span class="string">&quot;万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾&quot;</span>,</span><br><span class="line">        t = <span class="string">&quot;萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽&quot;</span>;</span><br><span class="line">    <span class="comment">//如果当前是 繁体切换为简体，进行交换。</span></span><br><span class="line">    <span class="keyword">if</span> (fontType) &#123;</span><br><span class="line">        j = s; s = t; t = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">        j = s.indexOf(text[i]);</span><br><span class="line">        result += j === -<span class="number">1</span> ? text[i] : t[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保存与切换状态"><a href="#保存与切换状态" class="headerlink" title="保存与切换状态"></a>保存与切换状态</h3><p>当用户进入网站时，读取曾经保存的状态，而每当状态切换时，我们都要重置当前存储的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fontType = <span class="built_in">parseInt</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;font_type&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>我们定义 <code>fontType</code> 这个变量来表示当前的文本类型（简体或繁体），<code>&#39;0&#39;</code> 表示显示简体，<code>&#39;1&#39;</code> 表示显示繁体。当用户是第一次进入页面时，<code>fontType</code> 值为 <code>NaN</code>，此时我们默认显示中文简体，当 <code>fontType</code> 不为 <code>NaN</code> 时，则显示对应存储的类型。</p>
<p>当切换状态时， 逻辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fontType = fontType ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;font_type&#x27;</span>, fontType);</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:translatePage();&quot;</span>&gt;</span>简繁切换<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fontType = <span class="built_in">parseInt</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;font_type&#x27;</span>));</span><br><span class="line"><span class="keyword">let</span> stopDOM = [<span class="string">&quot;BR&quot;</span>,<span class="string">&quot;TIME&quot;</span>,<span class="string">&quot;IMG&quot;</span>,<span class="string">&quot;CANVAS&quot;</span>,<span class="string">&quot;SCRIPT&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (fontType) &#123;</span><br><span class="line">    translateBody();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isNaN</span>(fontType)) &#123;</span><br><span class="line">	<span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;font_type&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateBody</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objs = (obj ? obj : <span class="built_in">document</span>.body).childNodes;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; objs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objs[i].nodeType === <span class="number">3</span> &amp;&amp; <span class="regexp">/[\u4e00-\u9fa5]/g</span>.test(objs[i].textContent)) &#123;</span><br><span class="line">            objs[i].textContent = exchange(objs[i].textContent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objs[i].nodeType === <span class="number">1</span> &amp;&amp; !stopDOM.includes(objs[i].tagName)) &#123;</span><br><span class="line">            translateBody(objs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exchange</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>, j,</span><br><span class="line">        s = <span class="string">&quot;万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾&quot;</span>,</span><br><span class="line">        t = <span class="string">&quot;萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (fontType) &#123;</span><br><span class="line">        j = s; s = t; t = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">        j = s.indexOf(text[i]);</span><br><span class="line">        result += j === -<span class="number">1</span> ? text[i] : t[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translatePage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fontType = fontType ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	<span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;font_type&#x27;</span>, fontType);</span><br><span class="line">    translateBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>学习Javascript闭包（Closure）</title>
    <url>/2018/05/05/learning_javascript_closures/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>闭包是由<strong>函数</strong>以及<strong>创建该函数的词法环境</strong>组合而成。<strong>这个环境包含了这个闭包创建时所能访问的所有局部变量</strong>。 – MDN</p>
</div>

<div class="note info"><p>闭包是有权访问另一个函数作用域的函数。 – 《JavaScript 高级程序设计(第 3 版)》</p>
</div>

<div class="note info"><p>函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。 – 《JavaScript 权威指南(第 6 版)》</p>
</div>

<div class="note info"><p>当函数可以<strong>记住并访问所在的词法作用域</strong>时，就产生了闭包，即使函数是在当前词法作用域之外执行。 – 《你不知道的 JavaScript(上卷)》</p>
</div>

<div class="note info"><p>闭包是个函数，而它「记住了周围发生了什么」。表现为由「一个函数」体中定义了「另个函数」。 – <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ3JhY2Vjb2RlLmNvbS9wb3N0cy8yMzg1Lmh0bWw=">闭包的秘密<i class="fa fa-external-link-alt"></i></span></p>
</div>

<div class="note info"><p>闭包就是能够读取其他函数内部变量的函数。 – <span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMDkvMDgvbGVhcm5pbmdfamF2YXNjcmlwdF9jbG9zdXJlcy5odG1s">阮一峰<i class="fa fa-external-link-alt"></i></span></p>
</div>

<p>要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。</p>
<p><strong>内部函数将能够访问到外部函数作用域中的变量</strong>，即使外部函数已经执行完毕。</p>
<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成<strong>定义在一个函数内部的函数</strong>。</p>
<p>所以，在本质上，闭包就是<strong>将函数内部和函数外部连接起来的一座桥梁</strong>。</p>
<p>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p>
<span id="more"></span>

<h3 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h3><p>编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。</p>
<p>而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p>
<p>下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为<strong>模块模式</strong>（module pattern）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 1 */</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包使用的例子"><a href="#闭包使用的例子" class="headerlink" title="闭包使用的例子"></a>闭包使用的例子</h3><p>闭包的用途之一是<strong>实现对象的私有数据</strong>。数据私有是让我们能够面向接口编程而不是面向实现编程的基础。而面向接口编程是一个重要的概念，有助于我们创建更加健壮的软件，因为实现细节比接口约定相对来说更加容易被改变。</p>
<p>在 JavaScript 中，闭包是用来实现数据私有的原生机制。当你使用闭包来实现数据私有时，被封装的变量只能在闭包容器函数作用域中使用。你无法绕过对象被授权的方法在外部访问这些数据。在 JavaScript 中，任何定义在闭包作用域下的公开方法才可以访问这些数据。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getSecret = <span class="function"><span class="params">secret</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> secret</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;Closure for object privacy.&#x27;</span>, <span class="function"><span class="params">assert</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">&#x27;.get() should have access to the closure.&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> obj = getSecret(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> actual = obj.get();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    assert.ok(secret, <span class="string">&#x27;This throws an error.&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    assert.ok(</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      <span class="string">`The secret var is only available</span></span><br><span class="line"><span class="string">      to privileged methods.`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert.equal(actual, expected, msg);</span><br><span class="line">  assert.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的例子里，<code>get()</code> 方法定义在 <code>getSecret()</code> 作用域下，这让它可以访问任何 <code>getSecret()</code> 中的变量，于是它就是一个被授权的方法。在这个例子里，它可以访问参数 <code>secret</code>。</p>
<p>对象不是唯一的产生私有数据的方式。闭包还可以被用来创建<strong>有状态的函数</strong>，这些函数的执行过程可能由它们自身的内部状态所决定。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Secret - creates closures with secret messages.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// secret(msg: String) =&gt; getSecret() =&gt; msg: String</span></span><br><span class="line"><span class="keyword">const</span> secret = <span class="function"><span class="params">msg</span> =&gt;</span> <span class="function">() =&gt;</span> msg;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;secret&#x27;</span>, <span class="function"><span class="params">assert</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">&#x27;secret() should return a function that returns the passed secret.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> theSecret = <span class="string">&#x27;Closures are easy.&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> mySecret = secret(theSecret);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> actual = mySecret();</span><br><span class="line">  <span class="keyword">const</span> expected = theSecret;</span><br><span class="line"></span><br><span class="line">  assert.equal(actual, expected, msg);</span><br><span class="line">  assert.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在函数式编程中，闭包经常用于偏函数应用和柯里化。为了说明这个，我们先定义一些概念：</p>
<p><strong>函数应用</strong>：一个过程，指将参数传给一个函数，并获得它的返回值。</p>
<p><strong>偏函数应用</strong>：一个过程，它传给某个函数其中一部分参数，然后返回一个新的函数，该函数等待接受后续参数。换句话说，偏函数应用是一个函数，它接受另一个函数为参数，这个作为参数的函数本身接受多个参数，它返回一个函数，这个函数与它的参数函数相比，接受更少的参数。偏函数应用提前赋予一部分参数，而返回的函数则等待调用时传入剩余的参数。</p>
<p>偏函数应用通过闭包作用域来提前赋予参数。你可以实现一个通用的函数来赋予指定的函数部分参数，它看起来如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">partialApply(targetFunction: <span class="built_in">Function</span>, ...fixedArgs: Any[]) =&gt;</span><br><span class="line">  functionWithFewerParams(...remainingArgs: Any[])</span><br></pre></td></tr></table></figure>

<p><code>partialApply</code> 接受一个多参数的函数，以及一串我们想要提前赋给这个函数的参数，它返回一个新的函数，这个函数将接受剩余的参数。</p>
<p>下面给一个例子来说明，假设你有一个函数，求两个数的和：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>

<p>现在你想要得到一个函数，它能够对任何传给它的参数都加 <code>10</code>，我们可以将它命名为 <code>add10()</code>。<code>add10(5)</code> 的结果应该是 <code>15</code>。我们的 <code>partialApply()</code> 函数可以做到这个：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add10 = partialApply(add, <span class="number">10</span>);</span><br><span class="line">add10(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子里，参数 <code>10</code> 通过闭包作用域被提前赋予 <code>add()</code>，从而让我们获得 <code>add10()</code>。</p>
<p>现在让我们看一下如何实现 <code>partialApply()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generic Partial Application Function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partialApply = <span class="function">(<span class="params">fn, ...fixedArgs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...remainingArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, fixedArgs.concat(remainingArgs));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;add10&#x27;</span>, <span class="function"><span class="params">assert</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">&#x27;partialApply() should partially apply functions&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> add10 = partialApply(add, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> actual = add10(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">  assert.equal(actual, expected, msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如你所见，它只是简单地返回一个函数，这个函数通过闭包访问了传给 <code>partialApply()</code> 函数的 <code>fixedArgs</code> 参数。</p>
<h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><ol>
<li>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</li>
<li>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</li>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
<li>闭包只能取得包含函数中任何变量的<strong>最后一个值</strong>，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。</li>
</ol>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>当函数被调用过了，并且以后不会被用到，那么垃圾回收机制就会销毁由函数创建的作用域。JavaScript 有两种垃圾回收机制，即 <strong>标记清除</strong> 和 <strong>引用计数</strong>，对于现代浏览器，绝大多数都会采用标记清除。</p>
<ul>
<li><p><strong>标记清除</strong></p>
<ul>
<li>垃圾收集器在运行的时候会<strong>给</strong>存储在内存中的<strong>所有变量加上标记</strong>，然后它会去掉环境中变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并且回收它们所占用的内存空间。</li>
</ul>
</li>
<li><p><strong>引用计数</strong></p>
<ul>
<li>引用计数是跟踪记录<strong>每个值被引用的次数</strong>。当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数就是 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。下次运行垃圾回收器时就可以释放那些引用次数为 0 的值所占用的内存。缺点：循环引用会导致引用次数永远不为 0。</li>
</ul>
</li>
</ul>
<p>在 JavaScript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemNmeS5jYy9hcnRpY2xlL21hc3Rlci10aGUtamF2YXNjcmlwdC1pbnRlcnZpZXctd2hhdC1pcy1hLWNsb3N1cmUtMjEyNy5odG1s">什么是闭包？<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Git Hook 自动部署 Hexo 到个人 VPS</title>
    <url>/2018/03/24/%E4%BD%BF%E7%94%A8%20Git%20Hook%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%20Hexo%20%E5%88%B0%E4%B8%AA%E4%BA%BA%20VPS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="CentOS-升级-Git-到最新版本"><a href="#CentOS-升级-Git-到最新版本" class="headerlink" title="CentOS 升级 Git 到最新版本"></a>CentOS 升级 Git 到最新版本</h3><p>CentOS 上的 Git 最新版本只有1.8.3，因此我们需要自己重新安装一遍 。</p>
<h4 id="卸载旧版本-Git"><a href="#卸载旧版本-Git" class="headerlink" title="卸载旧版本 Git"></a>卸载旧版本 Git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Development tools</span></span><br><span class="line">$ yum -y groupinstall Development tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># GCC 用于编译安装包</span></span><br><span class="line">$ yum install gcc perl-ExtUtils-MakeMaker</span><br><span class="line"></span><br><span class="line"><span class="comment"># *卸载 CentOS 自带的老版本 Git</span></span><br><span class="line">$ yum -y remove git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装前环境配置</span></span><br><span class="line">$ yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidoc xmlto perl-devel perl-CPAN autoconf*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统检测(CentOS 7.4 64位)</span></span><br><span class="line">$ cat /etc/centos-release</span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br><span class="line">$ uname -a</span><br><span class="line">Linux rmhost 3.10.0-693.2.2.el7.x86_64 <span class="comment">#1 SMP Tue Sep 12 22:26:13 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="下载-Git"><a href="#下载-Git" class="headerlink" title="下载 Git"></a>下载 Git</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择安装目录</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/src</span><br><span class="line"><span class="comment"># *下载最新版 git</span></span><br><span class="line">$ wget https://github.com/git/git/archive/v2.16.3.tar.gz</span><br><span class="line"><span class="comment"># *解压</span></span><br><span class="line">$ tar zxvf v2.16.3.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> git-2.16.3</span><br><span class="line">$ make configure</span><br><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/git --with-iconv=/usr/<span class="built_in">local</span>/libiconv</span><br><span class="line">$ make all doc</span><br><span class="line">$ make install install-doc install-html</span><br></pre></td></tr></table></figure>

<h4 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/profile</span><br><span class="line"><span class="comment"># *在最后一行添加</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/git/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># *保存后使其立即生效</span></span><br><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br></pre></td></tr></table></figure>

<h3 id="配置服务器远程-Git"><a href="#配置服务器远程-Git" class="headerlink" title="配置服务器远程 Git"></a>配置服务器远程 Git</h3><p>大家都知道 Git 是分布式的版本控制系统，远程仓库跟本地仓库是没什么不同的。</p>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><div class="note danger"><p>虽说现在的仓库只有我们自己在使用，新建一个 <code>git</code> 用户显得不是很有必要，但是为了安全起见，还是建议使用单独的 <code>git</code> 用户来专门运行 <code>git</code> 服务</p>
</div>

<p>创建一个 <code>git</code> 用户，用来运行 <code>git</code> 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adduser git</span><br><span class="line">$ chmod 740 /etc/sudoers</span><br><span class="line">$ vim /etc/sudoers</span><br><span class="line"><span class="comment"># *找到以下内容</span></span><br><span class="line"><span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line"><span class="comment"># *在下面添加一行</span></span><br><span class="line">git ALL=(ALL) ALL</span><br><span class="line"><span class="comment"># *保存退出后改回权限</span></span><br><span class="line">$ chmod 400 /etc/sudoers</span><br><span class="line"><span class="comment"># *设置Git用户密码</span></span><br><span class="line"><span class="comment"># 需要root权限</span></span><br><span class="line">$ sudo passwd git</span><br></pre></td></tr></table></figure>

<h4 id="创建证书登录"><a href="#创建证书登录" class="headerlink" title="创建证书登录"></a>创建证书登录</h4><p>把自己电脑的<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvZ2VuZXJhdGluZy1hLW5ldy1zc2gta2V5LWFuZC1hZGRpbmctaXQtdG8tdGhlLXNzaC1hZ2VudC8=">公钥<i class="fa fa-external-link-alt"></i></span>，也就是 <code>~/.ssh/id_rsa.pub</code> 文件里的内容添加到服务器的 <code>/home/git/.ssh/authorized_keys</code> 文件中，添加公钥之后可以防止每次 push 都需要输入密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *切换至 git 用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限</span></span><br><span class="line">$ su git</span><br><span class="line">$ mkdir ~/.ssh</span><br><span class="line">$ vim ~/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 然后在电脑中执行 cat ~/.ssh/id_rsa.pub | pbcopy ,将公钥复制粘贴到 authorized_keys</span></span><br><span class="line">$ chmod 600 ~/.ssh/authorzied_keys</span><br><span class="line">$ chmod 700 ~/.ssh</span><br><span class="line"><span class="comment"># 然后就可以执行ssh 命令测试是否可以免密登录</span></span><br><span class="line">$ ssh -v git@SERVER</span><br></pre></td></tr></table></figure>

<h4 id="初始化-Git-仓库"><a href="#初始化-Git-仓库" class="headerlink" title="初始化 Git 仓库"></a>初始化 Git 仓库</h4><p>我是将其放在 <code>/var/repo/blog.git</code> 目录下的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir /var/repo</span><br><span class="line">$ <span class="built_in">cd</span> /var/repo</span><br><span class="line">$ sudo git init --bare blog.git</span><br><span class="line"><span class="comment"># 使用 --bare 参数，Git 就会创建一个裸仓库，裸仓库没有工作区，我们不会在裸仓库上进行操作，它只为共享而存在。</span></span><br></pre></td></tr></table></figure>

<h4 id="配置-git-hooks"><a href="#配置-git-hooks" class="headerlink" title="配置 git hooks"></a>配置 git hooks</h4><p>关于 hooks 的详细内容可以<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyLyVFOCU4NyVBQSVFNSVBRSU5QSVFNCVCOSU4OS1HaXQtR2l0LSVFOSU5MiVBOSVFNSVBRCU5MA==">参考这里<i class="fa fa-external-link-alt"></i></span>。</p>
<p>我们这里要使用的是 <code>post-receive</code> 的 hook，这个 hook 会在整个 git 操作过程完结以后被运行。</p>
<p>在 <code>blog.git/hooks</code> 目录下新建一个 <code>post-receive</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/repo/blog.git/hooks</span><br><span class="line">$ vim post-receive</span><br></pre></td></tr></table></figure>

<p>在 <code>post-receive</code> 文件中写入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">git --work-tree=/var/www/kingmui --git-dir=/var/repo/blog.git checkout -f</span><br></pre></td></tr></table></figure>

<p>注意，<code>/var/www/kingmui</code> 要换成你自己的部署目录。上面那句 git 命令可以在我们每次 push 完之后，把部署目录更新到博客的最新生成状态。这样便可以完成达到自动部署的目的了。</p>
<p>不要忘记设置这个文件的可执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>

<h4 id="变更拥有者"><a href="#变更拥有者" class="headerlink" title="变更拥有者"></a>变更拥有者</h4><p>改变 <code>blog.git</code> 目录的拥有者为 <code>git</code> 用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo chown -R git:git blog.git</span><br></pre></td></tr></table></figure>

<h4 id="禁用权限"><a href="#禁用权限" class="headerlink" title="禁用权限"></a>禁用权限</h4><p>出于安全考虑，我们要让 <code>git</code> 用户不能通过 shell 登录。可以编辑 <code>/etc/passwd</code> 来实现，在 <code>/etc/passwd</code> 中找到类似下面的一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git:x:1002:1002:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure>

<p>将其改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git:x:1002:1002:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure>

<p>这样 <code>git</code> 用户可以通过 ssh 正常使用 git，但是无法登录 sehll。</p>
<p>至此，服务器端的配置就完成了。</p>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>修改 hexo 目录下的 <code>_config.yml</code> 文件，找到 [deploy] 条目，并修改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@www.kingmui.cn:/var/repo/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>要注意切换成你自己的服务器地址，以及服务器端 git 仓库的目录。至此，我们的 hexo 自动部署已经全部配置好了。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>往后，要发布新博客只需按照如下步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;new-post&quot;</span></span><br><span class="line"><span class="comment"># bla..bla..bla..</span></span><br><span class="line">$ hexo clean &amp;&amp; hexo generate --deploy</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用CSS3动画属性实现太阳系行星运转模拟动画</title>
    <url>/2017/10/28/%E4%BD%BF%E7%94%A8CSS3%E5%8A%A8%E7%94%BB%E5%B1%9E%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%A4%AA%E9%98%B3%E7%B3%BB%E8%A1%8C%E6%98%9F%E8%BF%90%E8%BD%AC%E6%A8%A1%E6%8B%9F%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><img data-src="http://cdn.kingmui.cn/solarsystem.png" class="" width="400">

<div class="note info"><p>太阳系行星运转模拟</p>
</div>

<p><span class="exturl" data-url="aHR0cHM6Ly9raW5nbXVpLmdpdGh1Yi5pby9Db2RlRGVtby9zb2xhclN5c3RlbS9zb2xhcnN5c3RlbS5odG1s">在线演示<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<figure class="highlight html"><figcaption><span>源代码</span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpbmdtdWkvQ29kZURlbW8vYmxvYi9tYXN0ZXIvc29sYXJTeXN0ZW0vc29sYXJzeXN0ZW0uaHRtbA==">solarsystem.html<i class="fa fa-external-link-alt"></i></span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*太阳*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.sun</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">165</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">30px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">30px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">30px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*水星路径*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.mercuryPath</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">130px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">130px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#545866</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">65px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">65px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: planetrotate <span class="number">10s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -moz-<span class="attribute">animation</span>: planetrotate <span class="number">10s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -webkit-<span class="attribute">animation</span>: planetrotate <span class="number">10s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -o-<span class="attribute">animation</span>: planetrotate <span class="number">10s</span> linear infinite;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*水星*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.mercury</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">7px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">7px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#505080</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*金星路径*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.venusPath</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#545866</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: planetrotate <span class="number">13s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -moz-<span class="attribute">animation</span>: planetrotate <span class="number">13s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -webkit-<span class="attribute">animation</span>: planetrotate <span class="number">13s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -o-<span class="attribute">animation</span>: planetrotate <span class="number">13s</span> linear infinite;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*金星*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.venus</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">9px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">9px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#baa681</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">65px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*地球路径*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.earthPath</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">270px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">270px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#545866</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">135px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">135px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: planetrotate <span class="number">15s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -moz-<span class="attribute">animation</span>: planetrotate <span class="number">15s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -webkit-<span class="attribute">animation</span>: planetrotate <span class="number">15s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -o-<span class="attribute">animation</span>: planetrotate <span class="number">15s</span> linear infinite;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*地球*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.earth</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">9px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">9px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(<span class="number">#53ecf4</span>, <span class="number">#22abd0</span>, <span class="number">#1290b2</span>);</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">95px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: planetrotate <span class="number">5s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -moz-<span class="attribute">animation</span>: planetrotate <span class="number">5s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -webkit-<span class="attribute">animation</span>: planetrotate <span class="number">5s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -o-<span class="attribute">animation</span>: planetrotate <span class="number">5s</span> linear infinite;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*月球*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.moon</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*火星路径*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.marsPath</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">340px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">340px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#545866</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">170px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">170px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: planetrotate <span class="number">18s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -moz-<span class="attribute">animation</span>: planetrotate <span class="number">18s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -webkit-<span class="attribute">animation</span>: planetrotate <span class="number">18s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -o-<span class="attribute">animation</span>: planetrotate <span class="number">18s</span> linear infinite;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*火星*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.mars</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#fa8757</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">130px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*木星路径*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.jupiterPath</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">410px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">410px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#545866</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">205px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">205px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: planetrotate <span class="number">20s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -moz-<span class="attribute">animation</span>: planetrotate <span class="number">20s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -webkit-<span class="attribute">animation</span>: planetrotate <span class="number">20s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -o-<span class="attribute">animation</span>: planetrotate <span class="number">20s</span> linear infinite;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*木星*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.jupiter</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#937749</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">130px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*土星路径*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.saturnPath</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">480px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">480px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#545866</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">240px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">240px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: planetrotate <span class="number">22s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -moz-<span class="attribute">animation</span>: planetrotate <span class="number">22s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -webkit-<span class="attribute">animation</span>: planetrotate <span class="number">22s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -o-<span class="attribute">animation</span>: planetrotate <span class="number">22s</span> linear infinite;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*土星*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.saturn</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">22px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">22px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#f1e0b4</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">160px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*土星环*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.ring</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">35px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#f1e0b4</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span> <span class="number">#977b4b</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">155px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: -<span class="number">2px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*天王星路径*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.uranusPath</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">550px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">550px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#545866</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">275px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">275px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: planetrotate <span class="number">25s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -moz-<span class="attribute">animation</span>: planetrotate <span class="number">25s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -webkit-<span class="attribute">animation</span>: planetrotate <span class="number">25s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -o-<span class="attribute">animation</span>: planetrotate <span class="number">25s</span> linear infinite;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*天王星*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.uranus</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#05a1d8</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">205px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*海王星路径*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.neptunePath</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">620px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">620px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#545866</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-top</span>: -<span class="number">310px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin-left</span>: -<span class="number">310px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">animation</span>: planetrotate <span class="number">30s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -moz-<span class="attribute">animation</span>: planetrotate <span class="number">30s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -webkit-<span class="attribute">animation</span>: planetrotate <span class="number">30s</span> linear infinite;</span></span><br><span class="line"><span class="css">    -o-<span class="attribute">animation</span>: planetrotate <span class="number">30s</span> linear infinite;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*海王星*/</span></span></span><br><span class="line"><span class="css">  <span class="selector-class">.neptune</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">14px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#02ebf4</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> azure;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">235px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/*Internet Explorer 9，以及更早的版本，不支持 @keyframe 规则或 animation 属性。*/</span></span></span><br><span class="line"><span class="css">  <span class="comment">/*定义动画 planetrotate*/</span></span></span><br><span class="line"><span class="css">  <span class="keyword">@keyframes</span> planetrotate &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">from</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/* Firefox */</span></span></span><br><span class="line"><span class="css">  <span class="keyword">@-moz-keyframes</span> planetrotate &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">from</span> &#123;</span></span><br><span class="line"><span class="css">      -moz-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="css">      -moz-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/* Safari &amp; Chrome */</span></span></span><br><span class="line"><span class="css">  <span class="keyword">@-webkit-keyframes</span> planetrotate &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">from</span> &#123;</span></span><br><span class="line"><span class="css">      -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="css">      -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/* Opera */</span></span></span><br><span class="line"><span class="css">  <span class="keyword">@-o-keyframes</span> planetrotate &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">from</span> &#123;</span></span><br><span class="line"><span class="css">      -o-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="css">      -o-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;planet&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--太阳--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sun&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--水星--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mercuryPath&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mercury&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--金星--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;venusPath&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;venus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--地球--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;earthPath&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;earth&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;moon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--火星--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;marsPath&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mars&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--木星--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jupiterPath&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jupiter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--土星--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;saturnPath&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;saturn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--天王星--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;uranusPath&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;uranus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--海王星--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;neptunePath&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;neptune&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Js判断鼠标移入元素的方向</title>
    <url>/2018/07/01/%E4%BD%BF%E7%94%A8Js%E5%88%A4%E6%96%AD%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%85%A5%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>判断鼠标从元素矩形区域的哪个方向进入的标准为：<br>当鼠标从元素矩形区域外移入元素矩形区域，和鼠标行动轨迹发生交叉的那条边就认为是鼠标进入的方向，例如鼠标从上方往下和上边有交叉，就认为是从上方进入。</p>
</div>

<p>本文要介绍几种方法来判断当鼠标滑入元素时，是从哪个方向进入；滑出元素时，从哪个方向滑出，以此对元素做一些交互效果。</p>
<h3 id="求最小值"><a href="#求最小值" class="headerlink" title="求最小值"></a>求最小值</h3><p>该方法是当鼠标滑入元素的时，从事件对象 <code>e</code> 中获取其位于文档中的坐标 <code>(e.pageX, e.pageY)</code>，再计算出 x 轴方向坐标减去元素左侧距离文档左侧的距离和 x 轴方向坐标减去元素右侧距离文档左侧的距离，y 轴方向坐标减去元素顶部距离文档顶部的距离和 y 轴方向坐标减去元素底部距离文档顶部的距离，求出这四个数字的绝对值的最小值，即为鼠标进入元素的方向。</p>
<p><a href="//kingmui.github.io/CodeDemo/judgeTheDirectionOfTheMouseSlip/minimumValue/">在线演示</a></p>
<span id="more"></span>

<h3 id="求角度"><a href="#求角度" class="headerlink" title="求角度"></a>求角度</h3><p>Math.atan2(y,x) 返回 -PI 到 PI 之间的值(负180°到正180°)，是从 X 轴正向逆时针旋转到点 (x,y) 时经过的角度，这里的结果是一个<strong>弧度值</strong>。</p>
<p><a href="//kingmui.github.io/CodeDemo/judgeTheDirectionOfTheMouseSlip/angleValue/">在线演示</a></p>
<h3 id="求斜率"><a href="#求斜率" class="headerlink" title="求斜率"></a>求斜率</h3><p><img data-src="http://cdn.kingmui.cn/slopeVersion.jpg"></p>
<ol>
<li>上图以浏览器可视区域左上角为原点建立坐标系，坐标系与数学坐标系方向一致，往右表示 x 轴正方向，往下表示 y 轴负方向；</li>
<li>图中点 (x1, y1) 代表元素框左上角坐标，(x2, y2) 代表元素框右下角坐标，(x0, y0) 代表元素框的中心点坐标，鼠标刚移入时，鼠标的坐标设为 (x, y)；</li>
<li>根据斜率公式：<code>k = (y2 - y1) / (x2 - x1)</code> 可得 (x1, y1) 与（x2, y2) 这条对角线的斜率为 k。由于对称性，元素框另外一条对角线的斜率为 -k。</li>
<li>根据同样的公式，当鼠标移入移出元素时的瞬间，与元素边框的交点与元素框中心点的斜率 <code>slope = (y - y0) / (x - x0)</code>。</li>
<li>由图可知，当 <code>k &lt; slope &lt; –k</code> 时，则肯定是左右移入，当移入点 <code>x &gt; x0</code> ，则为右移入，小于则是左移入。</li>
<li>上下的判断跟左右的原理一样，不过要注意 y 坐标都是负的，不可将大小分辨错了。</li>
</ol>
<p><a href="//kingmui.github.io/CodeDemo/judgeTheDirectionOfTheMouseSlip/slopeVersion/">在线演示</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数防抖(debounce)与函数节流(throttle)</title>
    <url>/2018/06/20/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96(debounce)%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81(throttle)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>在前端开发中有一部分的用户行为会频繁的触发事件执行，而对于 DOM 操作、资源加载等耗费性能的处理，很可能导致界面卡顿，甚至浏览器的崩溃。函数节流(throttle)和函数防抖(debounce)就是为了解决类似需求应运而生的。</p>
</div>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。</p>
<p>在开发的过程中，你可能会遇到下面的情况：</p>
<ol>
<li>监听 <code>Window</code> 对象的 <code>resize</code>，<code>scroll</code> 事件</li>
<li>拖拽时监听 <code>mousemove</code></li>
<li>文字输入时，对输入字符串进行处理，比如要把 markdwon 转换成 html</li>
<li>监听文件变化，重启服务</li>
</ol>
<span id="more"></span>

<p>第一到第三种情况，事件短时间内被频繁触发，如果在事件中有大量的计算，频繁操作 <code>DOM</code>，资源加载等重行为，可能会导致界面卡顿，严重点甚至会让浏览器崩掉。对于第四种情况，有的开发者保存编辑好的文件喜欢按多次 Ctrl+S，若是快速的重启服务还能 Hold 住，但是要是重启一个应用，就可能多次不必要的重启。</p>
<p>针对上面这一系列的需求，于是就有了 <code>debounce</code> 和 <code>throttle</code> 两种解决方案。</p>
<h3 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h3><p>当事件触发之后，必须等待某一个时间(N)之后，回调函数才会执行，假若在等待的时间内，事件又触发了则重新设置等待时间(N)，直到在时间(N)内事件不被触发，则在最后一次触发事件后，执行函数。</p>
<p>作用是在短时间内多次触发同一个函数，<strong>只执行最后一次，或者只在开始时执行</strong>。</p>
<p>以用户拖拽改变窗口大小，触发 <code>resize</code> 事件为例，在这过程中窗口的大小一直在改变，所以如果我们在 <code>resize</code> 事件中绑定函数，这个函数将会一直触发，而这种情况大多数情况下是毫无意义的，还会造成资源的大量浪费。</p>
<p>这时候可以使用函数防抖来优化相关操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通方案</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;trigger&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>优化方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param     </span>fn     &#123;Function&#125;   实际要执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param     </span>delay  &#123;Number&#125;     延迟时间，单位是毫秒（ms）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return    <span class="type">&#123;Function&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 维护一个 timer</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 保存函数调用时的上下文和参数，传递给 fn</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数被调用，清除定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），再过 delay 毫秒就执行 fn</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;trigger&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 debounce 中包装我们的函数，2 秒后触发</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, debounce(foo, <span class="number">2000</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，我们为 <code>resize</code> 事件绑定处理函数，这时 <code>debounce</code> 函数会立即调用，因此给 <code>resize</code> 事件绑定的函数实际上是 <code>debounce</code> 内部返回的函数。</li>
<li>每一次事件被触发，都会清除当前的 <code>timer</code> 然后重新设置超时调用。这就会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发。</li>
<li>只有当高频事件停止，最后一次事件触发的超时调用才能在 <code>delay</code> 时间后执行。</li>
</ul>
<p>更进一步，我们不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。<br>这里增加一个 <code>immediate</code> 参数来设置是否要立即执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay, immediate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="comment">// 根据距离上次触发操作的时间是否到达 delay 来决定是否要现在执行函数</span></span><br><span class="line">            <span class="keyword">var</span> doNow = !timer;</span><br><span class="line">            <span class="comment">// 每一次都重新设置 timer，就是要保证每一次执行至少 delay 秒后才可以执行</span></span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                fn.apply(context, args);</span><br><span class="line">            &#125;, delay);</span><br><span class="line">            <span class="comment">// 立即执行</span></span><br><span class="line">            <span class="keyword">if</span> (doNow) &#123;</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">                fn.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                fn.apply(context, args);</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h3><p>节流是另一种处理类似问题的解决方法。<strong>节流函数允许一个函数在规定的时间内只执行一次</strong>。</p>
<p>它和防抖动最大的区别是，<mark class="label info">节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数</mark>。</p>
<p>比如在页面的无限加载场景下，我们需要在用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流阀技术来实现。</p>
<p>其他的应用场景如：输入框的联想，可以限定用户在输入时，只在每两秒钟响应一次联想。</p>
<p>主要有两种实现方法：</p>
<ul>
<li><a href="#%E6%97%B6%E9%97%B4%E6%88%B3%E5%AE%9E%E7%8E%B0%EF%BC%9A">时间戳</a></li>
<li><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0%EF%BC%9A">定时器</a></li>
</ul>
<p>区别：使用时间戳实现的节流函数会在第一次触发事件时立即执行，以后每过 delay 秒之后才执行一次，并且最后一次触发事件不会被执行；而定时器实现的节流函数在第一次触发时不会执行，而是在 delay 秒之后才执行，当最后一次停止触发后，还会再执行一次函数。</p>
<h4 id="时间戳实现："><a href="#时间戳实现：" class="headerlink" title="时间戳实现："></a>时间戳实现：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>func    &#123;Function&#125;   实际要执行的函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>delay   &#123;Number&#125;     执行间隔，单位是毫秒（ms），默认100ms</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return        <span class="type">&#123;Function&#125;</span>   </span>返回一个`节流`函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">func, delay = <span class="number">100</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (now - prev &gt;= delay)&#123;</span><br><span class="line">            prev = <span class="built_in">Date</span>.now();</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当高频事件触发时，第一次应该会立即执行（给事件绑定函数与真正触发事件的间隔如果大于 <code>delay</code> 的话），而后再怎么频繁触发事件，也都是会每 <code>delay</code> 秒才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了。</p>
<h4 id="定时器实现："><a href="#定时器实现：" class="headerlink" title="定时器实现："></a>定时器实现：</h4><p>当触发事件的时候，我们设置一个定时器，在触发事件的时候，如果定时器存在，就不执行；直到 <code>delay</code> 秒后，定时器执行回调函数，清空定时器，这样就可以设置下个定时器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一次触发事件时，肯定不会立即执行函数，而是在 <code>delay</code> 秒后才执行。之后连续不断触发事件，也会每 <code>delay</code> 秒执行一次。当最后一次停止触发后，由于定时器的 <code>delay</code> 延迟，可能还会执行一次函数。</p>
<p>可以综合使用时间戳与定时器，完成一个事件触发时立即执行，触发完毕还能执行一次的节流函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> startTime = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> curTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">var</span> remaining = delay - (curTime - startTime);</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(func, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在每个 <code>delay</code> 时间中一定会执行一次函数，因此在节流函数内部使用开始时间、当前时间与 <code>delay</code> 来计算 <code>remaining</code>，当 <code>remaining &lt;= 0</code> 时表示执行该函数了，如果还没到时间的话就设定在 <code>remaining</code> 时间后再触发。当然在 <code>remaining</code> 这段时间中如果又一次发生事件，那么会取消当前的计时器，并重新计算一个 <code>remaining</code> 来判断当前状态。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>函数节流(throttle)和函数防抖(debounce)都是通过延时逻辑操作来提升性能的方法，在前端优化中是常见且重要的解决方式。可以从概念和实际应用中理解两者的区别，在需要的时候选择合适的方法处理。</p>
<p>防止一个事件频繁触发回调函数的方式：</p>
<ul>
<li>防抖动：将几次操作合并为一次操作进行。原理是维护一个计时器，规定在 <code>delay</code> 时间后触发函数，但是在 <code>delay</code> 时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</li>
<li>节流：使得一定时间内只触发一次函数。它和防抖动最大的区别就是，节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而防抖动只是在最后一次事件后才触发一次函数。原理是通过判断是否到达一定时间来触发函数，若没到规定时间则使用计时器延后，而下一次事件则会重新设定计时器。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>申城四月花争艳，最美樱花绽顾村</title>
    <url>/2019/04/07/%E7%94%B3%E5%9F%8E%E5%9B%9B%E6%9C%88%E8%8A%B1%E4%BA%89%E8%89%B3-%E6%9C%80%E7%BE%8E%E6%A8%B1%E8%8A%B1%E7%BB%BD%E9%A1%BE%E6%9D%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"lang":"zh-cn","video":{"url":"http://cdn.kingmui.cn/gucunparkvlog.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>

<p>不是要和你玩捉迷藏</p>
<p>大朵的云可以作证</p>
<p>这黄金的花园里</p>
<p>一条光影斑驳的小路伸向了远方</p>
<span id="more"></span>

<p>如果你来过，你一定看见</p>
<p>荻泾，悦林湖，荷花淀，菖蒲湾</p>
<p>一到春天</p>
<p>流水就会把爱情还给人间</p>
<p>当采蜜的群蜂哼起江南歌谣</p>
<p>所有与春天有关的意象</p>
<p>都灼灼地站在了岁月的枝头上</p>
<p>你不来，我还不能把一枚核的青涩说出来</p>
]]></content>
      <tags>
        <tag>生活</tag>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title>算法的复杂度</title>
    <url>/2019/03/26/%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="算法（algorithm）的定义"><a href="#算法（algorithm）的定义" class="headerlink" title="算法（algorithm）的定义"></a>算法（algorithm）的定义</h3><p>算法是解题方案的准确而完善的描述，是一系列解决问题的清晰指令。其实就是<strong>解决一个问题的完整性描述</strong>。</p>
<h3 id="算法的效率"><a href="#算法的效率" class="headerlink" title="算法的效率"></a>算法的效率</h3><p>既然算法是解决问题的描述，而解决同一问题的方法也是多种多样的，只是在这过程中我们所使用的时间或时间以外的代价（计算机消耗的则为内存）不一样。为了更快、更好、更强的提高算法的效率，很多时候一个优秀的算法就在于它与其他实现同一问题的算法相比，在时间和空间（内存）上得到明显的降低。</p>
<p>算法的效率主要由以下两个复杂度来评估：</p>
<div class="note info"><p><strong>时间复杂度</strong>：评估执行程序所需的<strong>时间</strong>。可以估算出程序对<strong>处理器</strong>的使用程度。<br><strong>空间复杂度</strong>：评估执行程序所需的<strong>存储空间</strong>。可以估算出程序对<strong>计算机内存</strong>的使用程度。</p>
</div>

<span id="more"></span>

<p>设计算法时，时间复杂度要比空间复杂度更容易出问题，所以一般情况一下我们只对时间复杂度进行研究。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法的时间复杂度是指算法需要消耗的时间资源。</p>
<p>一个算法执行所消耗的时间理论上是不能算出来的，虽然我们可以在程序中测试获得。但是我们不可能也没必要对每个算法进行测试，只需知道大概哪个算法执行所花费的时间多，哪个花费的时间少就行了。如果一个算法所花费的时间与算法中代码语句执行次数成正比，那么哪个算法执行语句越多，它的花费时间也就越多。我们把一个算法中的语句执行次数称为<strong>时间频度</strong>。通常用 <code>T(n)</code> 表示。</p>
<p>在时间频度 <code>T(n)</code> 中，<code>n</code> 又代表着问题的规模，当 <code>n</code> 不断变化时，<code>T(n)</code> 也会不断地随之变化。为了了解这个变化的规律，时间复杂度这一概念就被引入了。一般情况下算法的重复执行次数为问题规模 <code>n</code> 的某个函数，也就是时间频度 <code>T(n)</code>。如果有某个辅助函数 <code>f(n)</code>，当趋于无穷大的时候，<code>T(n)/f(n)</code> 的极限值是不为零的某个常数，那么 <code>f(n)</code> 是 <code>T(n)</code> 的同数量级函数，记作 <code>T(n)=O(f(n))</code>。算法执行时间的增长率与 <code>f(n)</code> 的增长率正相关，被称为算法的渐进时间复杂度，简称时间复杂度。</p>
<p>一般来说，计算机算法是问题规模 <code>n</code> 的函数 <code>f(n)</code>，算法的时间复杂度也因此记做 <code>T(n)=O(f(n))</code>。</p>
<h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p>用 <code>O(n)</code> 来体现算法时间复杂度的记法被称作大O表示法。</p>
<p>一般我们我们评估一个算法都是直接评估它的<strong>最坏的复杂度</strong>。</p>
<p>大O表示法 <code>O(f(n))</code> 中的 <code>f(n)</code> 的值可以为 <code>1、n、logn、n^2</code> 等，所以我们将 <code>O(1)、O(n)、O(logn)、O( n^2 )</code> 分别称为常数阶、线性阶、对数阶和平方阶。下面我们来看看<strong>推导大O阶</strong>的方法，有以下三种规则：</p>
<ol>
<li>用常数 1 取代运行时间中的所有加法常数</li>
<li>只保留最高阶项</li>
<li>去除最高阶的常数</li>
</ol>
<ul>
<li>常数阶</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>, n = <span class="number">10</span>; <span class="comment">// 语句执行一次</span></span><br><span class="line"><span class="keyword">let</span> sum = (<span class="number">1</span> + n) * n/<span class="number">2</span>; <span class="comment">// 语句执行一次</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`The sum is : <span class="subst">$&#123;sum&#125;</span>`</span>); <span class="comment">// 语句执行一次</span></span><br><span class="line"><span class="comment">// 这样的一段代码它的执行次数为 3。我们套用规则 1，则这个算法的时间复杂度为 O(1)，也就是常数阶。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>线性阶</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 语句执行一次</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">// 语句执行 n 次</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Current i is <span class="subst">$&#123;i&#125;</span>`</span>); <span class="comment">// 语句执行 n 次</span></span><br><span class="line">  i++; <span class="comment">// 语句执行 n 次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个算法中代码总共执行了 3n + 1 次，根据规则2和3，因此该算法的时间复杂度是 O(n)。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对数阶</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">1</span>; <span class="comment">// 语句执行一次</span></span><br><span class="line"><span class="keyword">while</span> (number &lt; n) &#123; <span class="comment">// 语句执行 logn 次</span></span><br><span class="line">  number *= <span class="number">2</span>; <span class="comment">// 语句执行 logn 次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的算法中，number 每次都放大两倍，我们假设这个循环体执行了 m 次，那么 2^m = n，即 m = logn，所以整段代码执行次数为 1 + 2 * logn，则 f(n) = logn，时间复杂度为 O(logn)。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>平方阶</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 语句执行 n 次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 语句执行 n^2 次</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;I am here!&#x27;</span>); <span class="comment">// 语句执行 n^2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的嵌套循环中，代码共执行 2 * n^2 + n，则 f(n) = n^2。所以该算法的时间复杂度为 O(n^2)</span></span><br></pre></td></tr></table></figure>

<h3 id="常见时间复杂度的比较"><a href="#常见时间复杂度的比较" class="headerlink" title="常见时间复杂度的比较"></a>常见时间复杂度的比较</h3><p><code>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)</code></p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjEzNTE1Nw==">算法的时间复杂度和空间复杂度<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义浏览器横向滚动条</title>
    <url>/2018/06/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E6%9D%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="自定义浏览器滚动条样式"><a href="#自定义浏览器滚动条样式" class="headerlink" title="自定义浏览器滚动条样式"></a>自定义浏览器滚动条样式</h3><h4 id="IE浏览器"><a href="#IE浏览器" class="headerlink" title="IE浏览器"></a>IE浏览器</h4><p>追溯浏览器对滚动条的自定义，恐怕最早的就是IE浏览器了（好像最开始支持的版本是IE5.5）。下面列出了多个版本的支持性：</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="left">滚动条样式</th>
<th align="left">支持情况</th>
<th align="left">支持浏览器版本</th>
<th align="left">可否继承</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">scrollbar-3dlight-color</td>
<td align="left">IE特有属性</td>
<td align="left">IE5.5+</td>
<td align="left">y</td>
<td align="left">设置滚动框的和滚动条箭头左上边缘的颜色</td>
</tr>
<tr>
<td align="left">scrollbar-highlight-color</td>
<td align="left">IE特有属性</td>
<td align="left">IE5.5+</td>
<td align="left">y</td>
<td align="left">设置滚动框的和滚动条箭头左上边缘的颜色</td>
</tr>
<tr>
<td align="left">scrollbar-face-color</td>
<td align="left">IE特有属性</td>
<td align="left">IE5.5+</td>
<td align="left">y</td>
<td align="left">设置滚动框和滚动条箭头的颜色</td>
</tr>
<tr>
<td align="left">scrollbar-arrow-color</td>
<td align="left">IE特有属性</td>
<td align="left">IE5.5+</td>
<td align="left">y</td>
<td align="left">设置滚动条箭头的颜色</td>
</tr>
<tr>
<td align="left">scrollbar-shadow-color</td>
<td align="left">IE特有属性</td>
<td align="left">IE5.5+</td>
<td align="left">y</td>
<td align="left">设置滚动框的和滚动条箭头右下边缘的颜色</td>
</tr>
<tr>
<td align="left">scrollbar-dark-shadow-color</td>
<td align="left">IE特有属性</td>
<td align="left">IE5.5+</td>
<td align="left">y</td>
<td align="left">设置滚动条槽的颜色</td>
</tr>
<tr>
<td align="left">scrollbar-base-color</td>
<td align="left">IE特有属性</td>
<td align="left">IE5.5+</td>
<td align="left">y</td>
<td align="left">设置滚动条主要构成部分的颜色</td>
</tr>
<tr>
<td align="left">scrollbar-track-color</td>
<td align="left">IE特有属性</td>
<td align="left">IE5.5+</td>
<td align="left">y</td>
<td align="left">设置滚动条轨迹组成部分的颜色</td>
</tr>
</tbody></table>
<p>为了有助于理解IE中滚动条样式的控制，你可以查看如下的图片：</p>
<p><img data-src="http://cdn.kingmui.cn/ie-css-scroll_thumb.gif"></p>
<div class="note danger"><p>在Win8下面，有一部分样式起着相同的作用。估计是因为在Win8中扁平化的界面设计而重新定义了系统中的滚动条！</p>
</div>

<p>以下是Win8下的滚动条样式，并罗列出了CSS支持的情况：</p>
<p><img data-src="http://cdn.kingmui.cn/win-8-ie-scrollbar_thumb.jpg"></p>
<p>以上所写的四个CSS属性，足以控制Win8系统下，IE浏览器的滚动条样式了。但经过测试发现，其它四个属性仍然支持（主要是在以上几个属性空缺时，就会体现其作用）。具体如下：</p>
<ul>
<li>关于 <code>scrollbar-track-color</code>，<code>scrollbar-face-color</code> 与 <code>scrollbar-base-color</code>。直接看英语单词，你就能明白 <code>scrollbar-base-color</code> 是一个备用颜色，只要前两者未设置时，它就开始起作用了。但是你得注意，当 <code>scrollbar- base-color</code> 用来作 <code>scrollbar-track-color</code> 功能来用时，你会发现，实际颜色与设定的颜色要淡一点。不信你可以这样试试：只设置一下 <code>scrollbar-base-color</code> 看看滚动条的效果。</li>
<li>关于 <code>scrollbar-dark-shadow-color</code> 属性，经过测试发现 Win8下的IE10，IE11滚动条并没有改变。</li>
<li>Win8下的滚动条中，上箭头和下箭头后面的背景颜色都已经从 <code>scrollbar-face-color</code> 中脱离出来了，从属于 <code>scrollbar-track-color</code> 属性控制。</li>
</ul>
<p>IE浏览器滚动条自定义功能并不是很强，只能控制显示各个部分的颜色而已，像宽度，结构等都无法控制。</p>
<h4 id="FireFox浏览器"><a href="#FireFox浏览器" class="headerlink" title="FireFox浏览器"></a>FireFox浏览器</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@-moz-document</span> url-prefix(<span class="attribute">http</span>://),url-prefix(<span class="attribute">https</span>://) &#123;</span><br><span class="line">    <span class="comment">/* 滚动条颜色 */</span></span><br><span class="line">    scrollbar &#123;</span><br><span class="line">        -moz-appearance: none <span class="meta">!important</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>) <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 滚动条按钮颜色 */</span></span><br><span class="line">    thumb,scrollbarbutton &#123;</span><br><span class="line">        -moz-appearance: none <span class="meta">!important</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>) <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 鼠标悬停时按钮颜色 */</span></span><br><span class="line">    thumb<span class="selector-pseudo">:hover</span>,scrollbarbutton<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        -moz-appearance: none <span class="meta">!important</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>) <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 隐藏上下箭头 */</span></span><br><span class="line">    scrollbarbutton &#123;</span><br><span class="line">        <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 纵向滚动条宽度 */</span></span><br><span class="line">    scrollbar<span class="selector-attr">[orient=<span class="string">&quot;vertical&quot;</span>]</span> &#123;</span><br><span class="line">        <span class="attribute">min-width</span>: <span class="number">15px</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="webkit内核浏览器"><a href="#webkit内核浏览器" class="headerlink" title="webkit内核浏览器"></a>webkit内核浏览器</h4><p>在所有浏览器中，滚动条可定制性最强的当属webkit内核的浏览器了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">::-webkit-scrollbar &#123; /* <span class="number">1</span> */ &#125;</span><br><span class="line">::-webkit-scrollbar-button &#123; /* <span class="number">2</span> */ &#125;</span><br><span class="line">::-webkit-scrollbar-track &#123; /* <span class="number">3</span> */ &#125;</span><br><span class="line">::-webkit-scrollbar-track-piece &#123; /* <span class="number">4</span> */ &#125;</span><br><span class="line">::-webkit-scrollbar-thumb &#123; /* <span class="number">5</span> */ &#125;</span><br><span class="line">::-webkit-scrollbar-corner &#123; /* <span class="number">6</span> */ &#125;</span><br><span class="line">::-webkit-resizer &#123; /* <span class="number">7</span> */ &#125;</span><br></pre></td></tr></table></figure>

<p>以上CSS代码所管辖的区域对应关系（以上注释中的数字与下图中数字相对应）</p>
<p><img data-src="http://cdn.kingmui.cn/scrollbarparts_thumb.png"></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>::-webkit-scrollbar</code></td>
<td>滚动条整体部分，其中的属性有 <code>width</code>, <code>height</code>, <code>background</code>, <code>border</code></td>
</tr>
<tr>
<td><code>::-webkit-scrollbar-button</code></td>
<td>滚动条两端的按钮。可以用 <code>display:none</code> 让其不显示，也可添加背景图片，颜色改变显示效果</td>
</tr>
<tr>
<td><code>::-webkit-scrollbar-track</code></td>
<td>外层轨道。可用 <code>display:none</code> 让其不显示，也可添加背景图片，颜色改变显示效果</td>
</tr>
<tr>
<td><code>::-webkit-scrollbar-track-piece</code></td>
<td>内层轨道，除去滚动条中间部分</td>
</tr>
<tr>
<td><code>::-webkit-scrollbar-corner</code></td>
<td>边角</td>
</tr>
<tr>
<td><code>::-webkit-resizer</code></td>
<td>定义右下角拖动块的样式</td>
</tr>
</tbody></table>
<div class="note warning"><p>对以上各个部分定义 <code>width</code>, <code>height</code> 时。有如下规则：若是水平滚动条，则 <code>width</code> 属性不起作用，<code>height</code> 属性用来控制滚动条相应部分竖直方向高度；若是竖直滚动条，则 <code>height</code> 属性不起作用，<code>width</code> 属性用来控制相应部分的宽度。</p>
</div>

<p>更多伪类<span class="exturl" data-url="aHR0cHM6Ly93ZWJraXQub3JnL2Jsb2cvMzYzL3N0eWxpbmctc2Nyb2xsYmFycy8=">请参考<i class="fa fa-external-link-alt"></i></span></p>
<table>
<thead>
<tr>
<th>伪类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>:horizontal</code></td>
<td>选择水平方向滚动条</td>
</tr>
<tr>
<td><code>:vertical</code></td>
<td>选择竖直方向滚动条</td>
</tr>
<tr>
<td><code>:decrement</code></td>
<td>应用于按钮和内层轨道，用来指示按钮或者内层轨道是否会减小视窗的位置</td>
</tr>
<tr>
<td><code>:increment</code></td>
<td>用来指示按钮或内层轨道是否会增大视窗的位置</td>
</tr>
<tr>
<td><code>:start</code></td>
<td>应用于按钮和滑块。用来定义对象是否放到滑块的前面</td>
</tr>
<tr>
<td><code>:end</code></td>
<td>标识对象是否放到滑块的后面</td>
</tr>
<tr>
<td><code>:double-button</code></td>
<td>用于按钮和内层轨道，判断一个按钮是否是放在滚动条同一端的一对按钮中的一个。对于内层轨道来说，它表示内层轨道是否紧靠一对按钮</td>
</tr>
<tr>
<td><code>:single-button</code></td>
<td>对按钮来说，它用于判断一个按钮是否自己独立的在滚动条的一端。对内层轨道来说，它表示内层轨道是否紧靠一个single-button</td>
</tr>
<tr>
<td><code>:no-button</code></td>
<td>用于内层轨道，表示内层轨道是否要滚动到滚动条的终端，如：滚动条两端没有按钮的时候</td>
</tr>
<tr>
<td><code>:corner-present</code></td>
<td>用于所有滚动条轨道，指示滚动条圆角是否显示</td>
</tr>
<tr>
<td><code>:window-inactive</code></td>
<td>用于所有的滚动条轨道，指示应用滚动条的某个页面容器(元素)是否当前被激活。(在webkit最近的版本中，该伪类也可以用于::selection伪元素。webkit团队有计划扩展它并推动成为一个标准的伪类)</td>
</tr>
</tbody></table>
<p>另外，<code>:enabled</code>、 <code>:disabled</code>、 <code>:hover</code>、 和 <code>:active</code> 等伪类同样在滚动条中适用。</p>
<h4 id="jQuery-插件"><a href="#jQuery-插件" class="headerlink" title="jQuery 插件"></a>jQuery 插件</h4><p>为了一致的用户体验，有时我们就不得不放弃使用部分浏览器提供的CSS接口来定制滚动条，转而寻求更佳的替代方案。其中一种方案是使用jQuery插件 <span class="exturl" data-url="aHR0cDovL21hbm9zLm1hbGlodS5nci9qcXVlcnktY3VzdG9tLWNvbnRlbnQtc2Nyb2xsZXIv">jquery-custom-content-scroller<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="判别鼠标滚动方向"><a href="#判别鼠标滚动方向" class="headerlink" title="判别鼠标滚动方向"></a>判别鼠标滚动方向</h3><p>我们应该都见过这种情景，用鼠标滚轮实现某个表单内的数字向上滚动则增加，向下滚动则减少的操作，这种效果是通过对鼠标滚轮的事件监听来实现的。因为不同的浏览器有不同的滚轮事件，主要有两种，<code>onmousewheel</code>（Firefox不支持）和 <code>DOMMouseScroll</code>（只有Firefox支持）。</p>
<p>另外判断滚轮向上或向下滚动在浏览器中也要考虑兼容性，现在五大浏览器（IE、Opera、Safari、Firefox、Chrome）中Firefox 使用 <code>detail</code>，其余四类使用 <code>wheelDelta</code>；</p>
<div class="note danger"><p><code>detail</code> 只取 <code>±3</code>，其中<mark class="label info">正数表示向下滚动，负数表示向上滚动</mark>。<code>wheelDelta</code> 在 IE 中取 <code>±120</code>，在 webkit 内核浏览器中取 <code>±150</code>，其中<mark class="label info">正数表示向上滚动，负数表示向下滚动</mark>。</p>
</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollFunc = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="string">`如果你使用了 jQuery 插件，则需要通过 e.originalEvent.wheelDelta 或 e.originalEvent.detail来访问`</span></span><br><span class="line">    <span class="keyword">if</span> (e.wheelDelta) &#123; <span class="comment">// 非 Firefox 浏览器</span></span><br><span class="line">        <span class="keyword">if</span> (e.wheelDelta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            alert(<span class="string">&quot;滑轮向上滚动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.wheelDelta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            alert(<span class="string">&quot;滑轮向下滚动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.detail) &#123; <span class="comment">// Firefox 浏览器</span></span><br><span class="line">        <span class="keyword">if</span> (e.detail &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            alert(<span class="string">&quot;滑轮向上滚动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.detail &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            alert(<span class="string">&quot;滑轮向下滚动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给页面绑定滑轮滚动事件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;<span class="comment">// Firefox</span></span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMMouseScroll&#x27;</span>, scrollFunc, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动滑轮触发scrollFunc方法  // IE 谷歌</span></span><br><span class="line"><span class="built_in">window</span>.onmousewheel = <span class="built_in">document</span>.onmousewheel = scrollFunc;</span><br></pre></td></tr></table></figure>

<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va29sZXlhbmcvcC81NDg0OTIyLmh0bWw=">自定义浏览器滚动条的样式，打造属于你的滚动条风格——兼容IE和webkit(ff不支持)<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>CSS3</tag>
        <tag>JavaScript</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>认识和使用 Promise</title>
    <url>/2019/04/05/%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BD%BF%E7%94%A8%20Promise/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p><code>Promise</code> 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。</p>
</div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125; <span class="comment">/* executor */</span>  );</span><br></pre></td></tr></table></figure>

<p><code>Promise</code> 构造函数执行时立即调用“处理器函数”（executor function）， <code>resolve</code> 和 <code>reject</code> 两个函数作为参数传递给“处理器函数”。“处理器函数”内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用 <code>resolve</code> 函数来将 <code>promise</code> 状态改成 <code>fulfilled</code>，要么调用 <code>reject</code> 函数将 <code>promise</code> 的状态改为 <code>rejected</code>。如果在“处理器函数”中抛出一个错误，那么该 <code>promise</code> 状态为 <code>rejected</code>。</p>
<p><strong>一个 Promise 有以下几种状态</strong>:</p>
<ul>
<li><code>pending</code>: 初始状态，既不是成功，也不是失败状态。</li>
<li><code>fulfilled</code>: 意味着操作成功完成。</li>
<li><code>rejected</code>: 意味着操作失败。</li>
<li><code>settled</code>: 处在 <code>fulfilled</code> 或 <code>rejected</code> 状态而不是 <code>pending</code> 状态。</li>
</ul>
<p>因为 <code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code> 方法返回 <code>promise</code> 对象， 所以它们<strong>可以被链式调用</strong>。</p>
<span id="more"></span>

<h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>不同于老式的传入回调，在应用 <code>Promise</code> 时，我们将会有以下约定：</p>
<ul>
<li>在 JavaScript 事件队列的<strong>当前运行完成</strong>之前，回调函数永远不会被调用。</li>
<li>通过 <code>.then</code> 形式添加的回调函数，甚至在异步操作完成之后才被添加的函数，都会被调用。</li>
<li>通过多次调用 <code>.then</code>，可以添加多个回调函数，它们会<strong>按照插入顺序并且独立运行</strong>。</li>
</ul>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>一个常见的需求就是连续执行两个或者多个异步操作，这种情况下，每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。我们可以通过创造一个 <code>Promise chain</code> 来完成这种需求。</p>
<p>在过去，做多重的异步操作，会导致经典的<strong>回调地狱</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(</span><br><span class="line">    result,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">      doThirdThing(</span><br><span class="line">        newResult,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">        &#125;,</span><br><span class="line">        failureCallback</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    failureCallback</span><br><span class="line">  );</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure>

<p>通过新式函数，我们把回调绑定到被返回的 <code>Promise</code> 上代替以往的做法，形成一个 <code>Promise</code> 链：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> doSomethingElse(result))</span><br><span class="line">  .then(<span class="function"><span class="params">newResult</span> =&gt;</span> doThirdThing(newResult))</span><br><span class="line">  .then(<span class="function"><span class="params">finalResult</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Got the final result: <span class="subst">$&#123;finalResult&#125;</span>`</span>))</span><br><span class="line">  .catch(failureCallback);</span><br></pre></td></tr></table></figure>

<p><code>then</code> 里的参数是可选的，<code>catch(failureCallback)</code> 是 <code>then(null, failureCallback)</code> 的缩略形式。</p>
<p>基本上，一个 <code>Promise</code> 链式遇到异常就会停止，查看链式的底端，寻找 <code>catch</code> 处理程序来代替当前执行。通过捕获所有的错误，甚至抛出异常和程序错误，<code>Promise</code> 解决了回调地狱的基本缺陷。</p>
<p><strong>注意</strong>：如果想要在回调中获取上个 <code>Promise</code> 中的结果，上个 <code>Promise</code> 中必须要返回结果。</p>
<h3 id="Catch-的后续链式操作"><a href="#Catch-的后续链式操作" class="headerlink" title="Catch 的后续链式操作"></a>Catch 的后续链式操作</h3><p>在一个失败操作（即一个 <code>catch</code>）之后可以继续使用链式操作，即使链式中的一个动作失败之后还能有助于新的动作继续完成。请阅读下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Initial&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Something failed&#x27;</span>);</span><br><span class="line">    <span class="comment">// 由于“Something failed”错误导致了拒绝操作，所以“Do this”文本没有被输出。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Do this&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Do that&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Do this whatever happened before&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initial</span></span><br><span class="line"><span class="comment">// Do that</span></span><br><span class="line"><span class="comment">// Do this whatever happened before</span></span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9yZXNvbHZl">Promise.resolve()<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9yZWplY3Q=">Promise.reject()<i class="fa fa-external-link-alt"></i></span> 是手动创建一个已经 <code>resolve</code> 或者 <code>reject</code> 的 <code>promise</code> 快捷方法。它们有时很有用。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9hbGw=">Promise.all()<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9yYWNl">Promise.race()<i class="fa fa-external-link-alt"></i></span> 是并行运行异步操作的两个组合式工具。</p>
<p><strong>Promise.all()</strong></p>
<p><code>Promise.all(iterable)</code> 方法返回一个 <code>Promise</code> 实例，此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都完成（<code>resolved</code>）或参数中不包含 <code>promise</code> 时回调完成（<code>resolve</code>）；如果参数中 <code>promise</code> 有一个失败（<code>rejected</code>），此实例回调失败（<code>reject</code>），失败原因的是第一个失败 <code>promise</code> 的结果。</p>
<ul>
<li><code>iterable</code>：一个可迭代对象，如 <code>Array</code> 或 <code>String。</code></li>
<li>返回值：<ul>
<li>如果传入的参数是一个空的可迭代对象，则返回一个<strong>已完成</strong>（already resolved）状态的 <code>Promise</code>。<mark class="label info">当且仅当传入的可迭代对象为空时为同步</mark>。</li>
<li>如果传入的参数不包含任何 promise，则返回一个<strong>异步完成</strong>（asynchronously resolved） <code>Promise。</code></li>
<li>其它情况下返回一个处理中（pending）的 <code>Promise</code>。这个返回的 <code>promise</code> 之后会在所有的 <code>promise</code> 都完成或有一个 <code>promise</code> 失败时<strong>异步</strong>地变为完成或失败。在任何情况下，<code>Promise.all</code> 返回的 <code>promise</code> 的完成状态的结果都是一个数组，<strong>返回值将会按照参数内的 <code>promise</code> 顺序排列，而不是由调用 <code>promise</code> 的完成顺序决定</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: Array [3, 42, &quot;foo&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>Promise.race()</strong></p>
<p><code>Promise.race(iterable)</code> 方法返回一个 <code>promise</code>，一旦迭代器中的某个 <code>promise</code> 解决或拒绝，返回的 <code>promise</code> 就会解决或拒绝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="comment">// Both resolve, but promise2 is faster</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: &quot;two&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：<ul>
<li>一个待定的 <code>Promise</code> 只要给定的迭代中的一个 <code>promise</code> 解决或拒绝，就采用第一个 <code>promise</code> 的值作为它的值，从而异步地解析或拒绝（一旦堆栈为空）。<mark class="label info">如果传的迭代是空的，则返回的 promise 将永远等待</mark>。</li>
</ul>
</li>
</ul>
<h3 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h3><p>为了避免意外，即使是一个已经变成 <code>resolve</code> 状态的 <code>Promise</code>，传递给 <code>then</code> 的函数也总是会被<strong>异步</strong>调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure>

<p>传递到 <code>then</code> 中的函数被置入了一个<strong>微任务</strong>队列，而不是立即执行，这意味着它是在 JavaScript 事件队列的所有运行时结束了，事件队列被清空之后才开始执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line"></span><br><span class="line">wait().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">  .then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">// 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>简便的 <code>Promise</code> 链式编程最好保持扁平化，不要嵌套 <code>Promise</code>。嵌套 <code>Promise</code> 是一种可以限制 <code>catch</code> 语句的作用域的控制结构写法。明确来说，嵌套的 <code>catch</code> 仅捕捉在其之前同时还必须是其作用域的 <code>failureres</code>，而捕捉不到在其链式以外或者其嵌套域以外的 <code>error</code>。如果使用正确，那么可以实现高精度的错误修复。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">doSomethingCritical()</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span></span><br><span class="line">    doSomethingOptional()</span><br><span class="line">      .then(<span class="function"><span class="params">optionalResult</span> =&gt;</span> doSomethingExtraNice(optionalResult))</span><br><span class="line">      .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.message);</span><br><span class="line">      &#125;)</span><br><span class="line">  ) <span class="comment">// 即使有异常也会忽略，继续运行;(最后会输出)</span></span><br><span class="line">  .then(<span class="function">() =&gt;</span> moreCriticalStuff())</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Critical failure: &#x27;</span> + e.message)); <span class="comment">// 没有输出</span></span><br></pre></td></tr></table></figure>

<p>这个内部的 <code>catch</code> 语句仅能捕获到 <code>doSomethingOptional()</code> 和 <code>doSomethingExtraNice()</code> 的失败，而且还是在 <code>moreCriticalStuff()</code> 并发运行以后。重要提醒，如果 <code>doSomethingCritical()</code> 失败，这个错误才仅会被最后的（外部）<code>catch</code> 语句捕获到。</p>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code> 方法返回一个 <code>Promise</code>，在 <code>promise</code> 执行结束时，无论结果是 <code>fulfilled</code> 或者是 <code>rejected</code>，在执行 <code>then()</code> 和 <code>catch()</code> 后，都会执行 <code>finally</code> 指定的回调函数。这为指定执行完 <code>promise</code> 后，无论结果是 <code>fulfilled</code> 还是 <code>rejected</code> 都需要执行的代码提供了一种方式，避免同样的语句需要在 <code>then()</code> 和 <code>catch()</code> 中各写一次的情况。</p>
<p>由于无法知道 <code>promise</code> 的最终状态，所以 <code>finally</code> 的回调函数中<strong>不接收任何参数</strong>，它仅用于无论最终结果如何都要执行的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.finally(onFinally);</span><br><span class="line"></span><br><span class="line">p.finally(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回状态为(resolved 或 rejected)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 在 <code>finally</code> 回调中 <code>throw</code>（或返回被拒绝的 <code>promise</code>）将以 <code>throw()</code> 指定的原因拒绝新的 <code>promise</code>。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>起风了</title>
    <url>/2018/03/31/%E8%B5%B7%E9%A3%8E%E4%BA%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note info"><p>我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。</p>
</div>

<div id="aplayer-DeAnBXan" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
				<pre class="aplayer-lrc-content">[00:20.03]
[00:25.53]君が前に付き合っていた人のこと 当你向我坦白
[00:31.44]僕に打ち明けてくれたとき 你与前任的往事时
[00:37.83]素直に聴いてあげられずに 我不肯好好听下去
[00:43.21]寂しい思いをさせてしまったね 让你觉得难过了吧
[00:48.12]
[00:48.78]すぐにヤキモチ焼くのが僕の悪い癖だって 我明明知道动不动就会吃醋
[00:56.59]分かっていた筈なのに 是自己的坏习惯
[01:01.20]自分勝手な想いが残酷な言葉になって 但还是会胡思乱想
[01:09.06]君を傷付けてた 说出过分的话来，令你伤心
[01:13.97]
[01:14.54]一緒に居られるだけで 只要让我和你在一起就好啊
[01:18.79]手と手を重ね合えるだけで良かったね 只要可以牵着你的手就好啊
[01:26.87]大切な事ほど見慣れた場所で輝くのかもしれない 最珍贵的东西，也许正闪耀在那些习以为常的地方
[01:39.08]君を強く抱きしめたい 我好想紧紧拥抱你
[01:46.00]
[01:55.80]自分のためだけに生きている人が 在这个城市里
[02:01.84]集められたようなこの街で 每个人都好像只为自己而活
[02:08.39]誰かを心から想える幸せをいつまでも忘れたくない 能有人牵挂着我 这种幸福永难忘怀
[02:18.73]
[02:19.25]すぐにヤキモチ焼くとこも好きだよって 你嘲笑说“我也中意你爱吃醋这点呀”
[02:25.28]からかって笑う君に甘えていた 我对你撒娇抗议
[02:31.64]愛していることを言葉以外の方法で 好想现在就用语言之外的方式
[02:39.02]今すぐに伝えたい 表达我对你的爱恋
[02:44.29]
[02:44.95]微笑んでくれた顔も 怒った顔も 无论微笑也好，生气也好
[02:51.47]愛しくて仕方なかったよ 你可爱的脸庞都令我着迷
[02:57.40]打ち明けてくれた過去も 你告诉我的往事也好
[03:01.56]二人が見た青空も忘れない 一起看过的天空也好，我怎么会忘掉
[03:09.98]
[03:34.99]一緒に居られるだけで 只要让我和你在一起就好啊
[03:39.00]手と手を重ね合えるだけで良かったね 只要可以牵着你的手就好啊
[03:47.15]大切な事ほど見慣れた場所で輝くのかもしれない 最珍贵的东西，也许正闪耀在那些习以为常的地方
[03:59.35]
[03:59.88]微笑んでくれた顔も 怒った顔も 无论微笑也好，生气也好
[04:06.31]愛しくて仕方なかったよ 你可爱的脸庞都令我着迷
[04:12.06]君の事が好きだよ 我喜欢你
[04:15.99]これからもずっと君を抱きしめたい 从今往后也想一直拥抱着你
[04:24.51]君を強く抱きしめたい 我好想紧紧拥抱你</pre>
			</div>
			<script>
				var ap = new APlayer({
					element: document.getElementById("aplayer-DeAnBXan"),
					narrow: false,
					autoplay: false,
					showlrc: 2,
					music: {
						title: "ヤキモチ",
						author: "たかはし ゆう",
						url: "http://cdn.kingmui.cn/%E3%83%A4%E3%82%AD%E3%83%A2%E3%83%81.mp3",
						pic: "http://cdn.kingmui.cn/takahashiyuu.jpg",
					}
				});
				window.aplayers || (window.aplayers = []);
				window.aplayers.push(ap);
			</script>

<p>君が前に付き合っていた人のこと<br>当你向我坦白</p>
<p>僕に打ち明けてくれたとき<br>你与前任的往事时</p>
<p>素直に聴いてあげられずに<br>我不肯好好听下去</p>
<p>寂しい思いをさせてしまったね<br>让你觉得难过了吧<span id="more"></span></p>
<p>すぐにヤキモチ焼くのが僕の悪い癖だって<br>我明明知道动不动就会吃醋</p>
<p>分かっていた筈なのに<br>是自己的坏习惯</p>
<p>自分勝手な想いが残酷な言葉になって<br>但还是会胡思乱想</p>
<p>君を傷付けてた<br>说出过分的话来，令你伤心</p>
<p>一緒に居られるだけで<br>只要让我和你在一起就好啊</p>
<p>手と手を重ね合えるだけで良かったね<br>只要可以牵着你的手就好啊</p>
<p>大切な事ほど見慣れた場所で輝くのかもしれない<br>最珍贵的东西，也许正闪耀在那些习以为常的地方</p>
<p>君を強く抱きしめたい<br>我好想紧紧拥抱你</p>
<p>自分のためだけに生きている人が<br>在这个城市里</p>
<p>集められたようなこの街で<br>每个人都好像只为自己而活</p>
<p>誰かを心から想える幸せをいつまでも忘れたくない<br>能有人牵挂着我 这种幸福永难忘怀</p>
<p>すぐにヤキモチ焼くとこも好きだよって<br>你嘲笑说“我也中意你爱吃醋这点呀”</p>
<p>からかって笑う君に甘えていた<br>我对你撒娇抗议</p>
<p>愛していることを言葉以外の方法で<br>好想现在就用语言之外的方式</p>
<p>今すぐに伝えたい<br>表达我对你的爱恋</p>
<p>微笑んでくれた顔も 怒った顔も<br>无论微笑也好，生气也好</p>
<p>愛しくて仕方なかったよ<br>你可爱的脸庞都令我着迷</p>
<p>打ち明けてくれた過去も<br>你告诉我的往事也好</p>
<p>二人が見た青空も忘れない<br>一起看过的天空也好，我怎么会忘掉</p>
<p>一緒に居られるだけで<br>只要让我和你在一起就好啊</p>
<p>手と手を重ね合えるだけで良かったね<br>只要可以牵着你的手就好啊</p>
<p>大切な事ほど見慣れた場所で輝くのかもしれない<br>最珍贵的东西，也许正闪耀在那些习以为常的地方</p>
<p>微笑んでくれた顔も 怒った顔も<br>无论微笑也好，生气也好</p>
<p>愛しくて仕方なかったよ<br>你可爱的脸庞都令我着迷</p>
<p>君の事が好きだよ<br>我喜欢你</p>
<p>これからもずっと君を抱きしめたい<br>从今往后也想一直拥抱着你</p>
<p>君を強く抱きしめたい<br>我好想紧紧拥抱你</p>
]]></content>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
</search>
