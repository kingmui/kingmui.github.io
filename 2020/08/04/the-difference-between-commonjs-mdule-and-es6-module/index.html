<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content=#222><meta name=generator content="Hexo 5.4.0"><link rel=apple-touch-icon sizes=180x180 href=https://cdn.kingmui.cn/avatar.jpg><link rel=icon type=image/png sizes=32x32 href=https://cdn.kingmui.cn/avatar.jpg><link rel=icon type=image/png sizes=16x16 href=https://cdn.kingmui.cn/avatar.jpg><link rel=mask-icon href=https://cdn.kingmui.cn/avatar.jpg color=#222><meta name=google-site-verification content=sNI58_0qBlj048P3M9VIK0edTYQ9zf2quRwRS7aNr2w><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin=anonymous><script class=next-config data-name=main type=application/json>{"hostname":"www.kingmui.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta name=description content="历史上，JS 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有 @import，但是 JS 任何这方面的支持都没有，这对开发大型复杂的项目形成了巨大障碍。 在 ES6 出来之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和"><meta property=og:type content=article><meta property=og:title content="CommonJS 模块和 ES6 模块的区别"><meta property=og:url content=http://www.kingmui.cn/2020/08/04/the-difference-between-commonjs-mdule-and-es6-module/index.html><meta property=og:site_name content="King Mui"><meta property=og:description content="历史上，JS 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有 @import，但是 JS 任何这方面的支持都没有，这对开发大型复杂的项目形成了巨大障碍。 在 ES6 出来之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和"><meta property=og:locale content=zh_CN><meta property=article:published_time content=2020-08-04T15:00:03.000Z><meta property=article:modified_time content=2022-04-21T14:16:28.722Z><meta property=article:author content="King Mui"><meta property=article:tag content=JavaScript><meta property=article:tag content=ES6><meta property=article:tag content=CommonJS><meta name=twitter:card content=summary><link rel=canonical href=http://www.kingmui.cn/2020/08/04/the-difference-between-commonjs-mdule-and-es6-module/ ><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.kingmui.cn/2020/08/04/the-difference-between-commonjs-mdule-and-es6-module/","path":"2020/08/04/the-difference-between-commonjs-mdule-and-es6-module/","title":"CommonJS 模块和 ES6 模块的区别"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>CommonJS 模块和 ES6 模块的区别 | King Mui</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-116303188-1"></script><script class=next-config data-name=google_analytics type=application/json>{"tracking_id":"UA-116303188-1","only_pageview":false}</script><script src=/js/third-party/analytics/google-analytics.js></script><script src=/js/third-party/analytics/baidu-analytics.js></script><script async src=https://hm.baidu.com/hm.js?65b6c252e87243b9ea8427abb6b8cf3e></script><noscript><link rel=stylesheet href=/css/noscript.css></noscript><link rel=alternate href=/atom.xml title="King Mui" type=application/atom+xml></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><p class=site-title>King Mui</p><i class=logo-line></i></a><p class=site-subtitle itemprop=description>用艺术的眼光发现技术的美</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-rss"><a href=/atom.xml rel=section><i class="fa fa-rss fa-fw"></i>RSS</a></li><li class="menu-item menu-item-search"><a role=button class=popup-trigger><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD><span class=nav-number>1.</span> <span class=nav-text>浏览器加载</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99><span class=nav-number>2.</span> <span class=nav-text>加载规则</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#NodeJS-%E5%8A%A0%E8%BD%BD><span class=nav-number>3.</span> <span class=nav-text>NodeJS 加载</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#main-%E5%AD%97%E6%AE%B5><span class=nav-number>4.</span> <span class=nav-text>main 字段</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#ES6-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD-CommonJS-%E6%A8%A1%E5%9D%97><span class=nav-number>5.</span> <span class=nav-text>ES6 模块加载 CommonJS 模块</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#CommonJS-%E6%A8%A1%E5%9D%97-%E5%8A%A0%E8%BD%BD-ES6-%E6%A8%A1%E5%9D%97><span class=nav-number>6.</span> <span class=nav-text>CommonJS 模块 加载 ES6 模块</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8A%A0%E8%BD%BD%E8%B7%AF%E5%BE%84><span class=nav-number>7.</span> <span class=nav-text>加载路径</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F><span class=nav-number>8.</span> <span class=nav-text>内部变量</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD%EF%BC%88Circular-Dependency%EF%BC%89><span class=nav-number>9.</span> <span class=nav-text>循环加载（Circular Dependency）</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD><span class=nav-number>10.</span> <span class=nav-text>CommonJS 模块的循环加载</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#ES6-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD><span class=nav-number>11.</span> <span class=nav-text>ES6 模块的循环加载</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%80%BB%E7%BB%93><span class=nav-number>12.</span> <span class=nav-text>总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt="King Mui" src=https://cdn.kingmui.cn/avatar.jpg><p class=site-author-name itemprop=name>King Mui</p><div class=site-description itemprop=description>生命不息，学习不止</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/ ><span class=site-state-item-count>26</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/ ><span class=site-state-item-count>18</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class=links-of-author-item><span class=exturl data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpbmdtdWk=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kingmui"><i class="fab fa-github-alt fa-fw"></i></span></span><span class=links-of-author-item><span class=exturl data-url=bWFpbHRvOmtpbmdtdWkuZGV2QG91dGxvb2suY29t title="E-Mail → mailto:kingmui.dev@outlook.com"><i class="fa fa-envelope fa-fw"></i></span></span></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cHM6Ly9vdmVycmVhY3RlZC5pby8=" title=https:&#x2F;&#x2F;overreacted.io&#x2F;>Dan Abramov</span></li><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cHM6Ly9qYWtlYXJjaGliYWxkLmNvbS8=" title=https:&#x2F;&#x2F;jakearchibald.com&#x2F;>Jake Archibald</span></li><li class=links-of-blogroll-item><span class=exturl data-url=aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20v title=https:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;>阮一峰</span></li><li class=links-of-blogroll-item><span class=exturl data-url="aHR0cHM6Ly9naXRodWIuY29tL21xeXFpbmdmZW5nL0Jsb2c=" title=https:&#x2F;&#x2F;github.com&#x2F;mqyqingfeng&#x2F;Blog>冴羽</span></li></ul></div></div></div><div class="back-to-top animated" role=button aria-label=返回顶部><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class=sidebar-dimmer></div></header><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang=zh-CN><link itemprop=mainEntityOfPage href=http://www.kingmui.cn/2020/08/04/the-difference-between-commonjs-mdule-and-es6-module/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=https://cdn.kingmui.cn/avatar.jpg><meta itemprop=name content="King Mui"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="King Mui"><meta itemprop=description content=生命不息，学习不止></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CommonJS 模块和 ES6 模块的区别 | King Mui"><meta itemprop=description content></span><header class=post-header><h1 class=post-title itemprop="name headline">CommonJS 模块和 ES6 模块的区别</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span> <span class=post-meta-item-text>发表于</span> <time title="创建时间：2020-08-04 23:00:03" itemprop="dateCreated datePublished" datetime=2020-08-04T23:00:03+08:00>2020-08-04</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i></span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2022-04-21 22:16:28" itemprop=dateModified datetime=2022-04-21T22:16:28+08:00>2022-04-21</time></span><span class=post-meta-item title=阅读次数 id=busuanzi_container_page_pv><span class=post-meta-item-icon><i class="far fa-eye"></i></span> <span class=post-meta-item-text>阅读次数：</span><span id=busuanzi_value_page_pv></span></span><span class=post-meta-break></span><span class=post-meta-item title=本文字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span> <span class=post-meta-item-text>本文字数：</span> <span>11k</span></span><span class=post-meta-item title=阅读时长><span class=post-meta-item-icon><i class="far fa-clock"></i></span> <span class=post-meta-item-text>阅读时长 &asymp;</span> <span>10 分钟</span></span></div></div></header><div class=post-body itemprop=articleBody><p>历史上，JS 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的 <code>require</code>、Python 的 <code>import</code>，甚至就连 CSS 都有 <code>@import</code>，但是 JS 任何这方面的支持都没有，这对开发大型复杂的项目形成了巨大障碍。</p><p>在 ES6 出来之前，社区制定了一些模块加载方案，最主要的有 <strong>CommonJS</strong> 和 <strong>AMD</strong> 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得<mark class="label info">编译时就能确定模块的依赖关系</mark>，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在<strong>运行时</strong>确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><span id=more></span><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// CommonJS 模块</span></span><br><span class=line><span class=keyword>const</span> &#123; stat, exists, readfile &#125; = <span class=built_in>require</span>(<span class=string>&#x27;fs&#x27;</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// 等同于</span></span><br><span class=line><span class=keyword>const</span> _fs = <span class=built_in>require</span>(<span class=string>&#x27;fs&#x27;</span>);</span><br><span class=line><span class=keyword>const</span> stat = _fs.stat;</span><br><span class=line><span class=keyword>const</span> exists = _fs.exists;</span><br><span class=line><span class=keyword>const</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上述代码的实质是整体加载 fs 模块（即加载 fs 的所有方法），生成一个对象（_fs），然后再从这个对象上读取3个方法。这种加载称为<strong>运行时加载</strong>，因为只有运行时才能得到这个对象，导致完全<strong>没办法在编译时做静态优化</strong>。</p><p>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> &#123; stat, exists, readfile &#125; <span class=keyword>from</span> <span class=string>&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述代码的实质是从 fs 模块加载3个方法，其他方法不加载。这种加载称为<strong>编译时加载</strong>或者静态加载，即 <mark class="label info">ES6 可以在编译时就完成模块加载</mark>，效率比 CommonJS 模块的加载方式高。当然，这也导致了无法引用 ES6 模块本身，因为它不是对象。</p><p>由于 ES6 模块是编译时加载，<strong>使得静态分析成为可能</strong>。有了它，就能进一步拓宽 JS 的语法，比如引入宏（macro）和类型检查（type system）这些只能靠静态分析实现的功能。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 不会报错，因为 import 的执行早于 foo 的调用</span></span><br><span class=line><span class=comment>// 这种行为的本质是，import 命令是编译阶段执行的，在代码运行之前</span></span><br><span class=line>foo();</span><br><span class=line></span><br><span class=line><span class=comment>// import 命令具有提升效果，会提升到整个模块的头部，首先执行</span></span><br><span class=line><span class=keyword>import</span> &#123; foo &#125; <span class=keyword>from</span> <span class=string>&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// import 语句会执行所加载的模块，以下代码仅仅执行 lodash 模块，但是不输入任何值</span></span><br><span class=line><span class=keyword>import</span> <span class=string>&#x27;lodash&#x27;</span>;</span><br><span class=line><span class=comment>// 如果多次重复执行同一句 import 语句，那么只会执行一次</span></span><br><span class=line><span class=keyword>import</span> <span class=string>&#x27;lodash&#x27;</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// import 语句是 Singleton 模式</span></span><br><span class=line><span class=keyword>import</span> &#123; func1 &#125; <span class=keyword>from</span> <span class=string>&#x27;module&#x27;</span>;</span><br><span class=line><span class=keyword>import</span> &#123; func2 &#125; <span class=keyword>from</span> <span class=string>&#x27;module&#x27;</span>;</span><br><span class=line><span class=comment>// 等价于</span></span><br><span class=line><span class=keyword>import</span> &#123; func1, func2 &#125; <span class=keyword>from</span> <span class=string>&#x27;module&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>import</code> 和 <code>export</code> 命令<strong>只能在模块的顶层</strong>，不能在代码块之中（如在 if 代码块之间或在函数之中）。这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果 <code>import</code> 命令要取代 Node 的 <code>require</code> 方法，这就现成了一道障碍。因为 <code>require</code> 是运行时加载模块，<code>import</code> 命令无法取代 <code>require</code> 的动态加载功能。</p><p>ES2020 提案引入 <code>import()</code> 函数，支持动态加载模块。<code>import</code> 命令能接受什么参数，<code>import()</code> 函数就能接受什么参数。两者区别主要是<strong>后者为动态加载</strong>。<code>import()</code> 返回一个 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>const</span> main = <span class=built_in>document</span>.querySelector(<span class=string>&#x27;main&#x27;</span>);</span><br><span class=line><span class=comment>// import() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用</span></span><br><span class=line><span class=comment>// 它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块</span></span><br><span class=line><span class=comment>// import() 函数与所加载的模块没有静态连接关系，这点也与 import 语句不相同</span></span><br><span class=line><span class=comment>// import() 函数类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载</span></span><br><span class=line><span class=keyword>import</span>(<span class=string>`./section-modules/<span class=subst>$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class=line>    .then(<span class=function><span class=params>module</span> =&gt;</span> &#123;</span><br><span class=line>        <span class=built_in>module</span>.loadPageInfo(main);</span><br><span class=line>    &#125;)</span><br><span class=line>    .catch(<span class=function><span class=params>err</span> =&gt;</span> &#123;</span><br><span class=line>        main.textContent = err.message;</span><br><span class=line>    &#125;);</span><br><span class=line></span><br><span class=line><span class=comment>// 适用场景</span></span><br><span class=line><span class=comment>// 1. 按需加载</span></span><br><span class=line>button.addEventListener(<span class=string>&#x27;click&#x27;</span>, <span class=function><span class=params>e</span> =&gt;</span> &#123;</span><br><span class=line>    <span class=keyword>import</span>(<span class=string>&#x27;./dialogBox.js&#x27;</span>)</span><br><span class=line>    .then(<span class=function><span class=params>dialogBox</span> =&gt;</span> &#123;</span><br><span class=line>        dialogBox.open();</span><br><span class=line>    &#125;)</span><br><span class=line>    .catch(<span class=function><span class=params>e</span> =&gt;</span> <span class=built_in>console</span>.log)</span><br><span class=line>&#125;);</span><br><span class=line></span><br><span class=line><span class=comment>// 2. 条件加载</span></span><br><span class=line><span class=keyword>if</span> (condition) &#123;</span><br><span class=line>    <span class=keyword>import</span>(<span class=string>&#x27;moduleA&#x27;</span>).then(...);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>// 3. 动态的模块路径</span></span><br><span class=line><span class=comment>// import() 允许模块路径动态生成</span></span><br><span class=line><span class=keyword>import</span>(getPath())</span><br><span class=line>.then(...);</span><br></pre></td></tr></table></figure><p>除了静态加载带来的各种好处，ES6 模块还有以下好处：</p><ol><li>不再需要 UMD 模块格式，将来服务器和浏览器都会支持 ES6 模块格式</li><li>将来浏览器的新 API 就能用模块格式提供，不再需要做成全局变量或者 <code>navigator</code> 对象的属性</li><li>不再需要对象作为命名空间（比如 <code>Math</code> 对象），未来这些功能都可以通过模块提供</li></ol><h4 id=浏览器加载><a href=#浏览器加载 class=headerlink title=浏览器加载></a>浏览器加载</h4><p>HTML 网页中，浏览器通过 <code>&lt;script&gt;</code> 标签加载 JS 脚本。</p><figure class="highlight html"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre></td><td class=code><pre><span class=line><span class=comment>&lt;!-- 网页内嵌的脚本 --&gt;</span></span><br><span class=line><span class=tag>&lt;<span class=name>script</span> <span class=attr>type</span>=<span class=string>&quot;application/javascript&quot;</span>&gt;</span><span class=javascript></span></span><br><span class=line><span class=javascript><span class=comment>// module code</span></span></span><br><span class=line><span class=javascript></span><span class=tag>&lt;/<span class=name>script</span>&gt;</span></span><br><span class=line></span><br><span class=line><span class=comment>&lt;!-- 外部脚本 --&gt;</span></span><br><span class=line><span class=tag>&lt;<span class=name>script</span> <span class=attr>type</span>=<span class=string>&quot;application/javascript&quot;</span> <span class=attr>src</span>=<span class=string>&quot;path/to/myModule.js&quot;</span>&gt;</span><span class=tag>&lt;/<span class=name>script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码中，由于浏览器脚本的默认语言是 JS，因此 <code>type=&quot;application/javascript&quot;</code> 可以省略。</p><p>默认情况下，浏览器是<strong>同步加载</strong> JS 脚本，即渲染引擎遇到 <code>&lt;script&gt;</code> 标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入<strong>脚本下载的时间</strong>。如果脚本体积很大，下载和执行的时间就会很长，因而造成浏览器阻塞，用户会感觉到浏览器“卡死”，没有任何响应。这显然是很不好的用户体验，所以浏览器允许脚本异步加载，下面就是两种<strong>异步加载</strong>的语法。</p><figure class="highlight html"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=comment>&lt;!-- script 标签打开 defer、async 属性，脚本就会异步加载 --&gt;</span></span><br><span class=line><span class=comment>&lt;!-- 渲染引擎遇到这一行命令，就会开始下载异步脚本，但不会等它下载和执行，而是直接执行后面的命令 --&gt;</span></span><br><span class=line><span class=tag>&lt;<span class=name>script</span> <span class=attr>src</span>=<span class=string>&quot;path/to/myModule.js&quot;</span> <span class=attr>defer</span>&gt;</span><span class=tag>&lt;/<span class=name>script</span>&gt;</span></span><br><span class=line><span class=tag>&lt;<span class=name>script</span> <span class=attr>src</span>=<span class=string>&quot;path/to/myModule.js&quot;</span> <span class=attr>async</span>&gt;</span><span class=tag>&lt;/<span class=name>script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>defer 与 async 的区别：</p><ol><li>defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行。多个 defer 会按它们在页面出现的顺序加载。是<mark class="label info">渲染完再执行</mark>。</li><li>async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个 async 脚本不能保证加载顺序。是<mark class="label info">下载完就执行</mark>。</li></ol><h4 id=加载规则><a href=#加载规则 class=headerlink title=加载规则></a>加载规则</h4><p>浏览器加载 ES6 模块，也可以使用 <code>&lt;script&gt;</code> 标签，但是要加入 <code>type=&quot;module&quot;</code> 属性。浏览器对于带有 <code>type=&quot;module&quot;</code> 的 <code>&lt;script&gt;</code>，都是<strong>异步加载</strong>，不会阻塞浏览器，等同于打开了 <code>&lt;script&gt;</code> 标签的 defer 属性。有多个 <code>type=&quot;module&quot;</code> 的标签，它们会按照在页面出现的顺序依次执行，如果显式指定了 async 则不会按顺序执行。</p><p>ES6 模块 也<strong>允许内嵌在网页中</strong>，语法行为与加载外部脚本完全一致。</p><figure class="highlight html"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line><span class=tag>&lt;<span class=name>script</span> <span class=attr>type</span>=<span class=string>&quot;module&quot;</span>&gt;</span><span class=javascript></span></span><br><span class=line><span class=javascript>    <span class=keyword>import</span> $ <span class=keyword>from</span> <span class=string>&#x27;jquery&#x27;</span>;</span></span><br><span class=line><span class=javascript>    $(<span class=string>&#x27;#message&#x27;</span>).text(<span class=string>&#x27;Hello World&#x27;</span>);</span></span><br><span class=line><span class=javascript></span><span class=tag>&lt;/<span class=name>script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于外部的模块脚本，有几点注意事项：</p><ol><li>代码是在<strong>模块作用域</strong>之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见</li><li>模块脚本<strong>自动采用严格模块</strong>，不管有没有声明 <code>use strict</code></li><li>模块之中，可以使用 <code>import</code> 命令加载其他模块（.js 后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用 <code>export</code> 命令输出对外接口</li><li>模块之中，顶层的 <code>this</code> 关键字返回 <code>undefined</code>，而不是指向 <code>window</code>。利用这个语法点，可以侦测当前代码是否运行在 ES6 模块之中</li><li>同一个模块如果加载多次，将只执行一次</li></ol><h4 id=NodeJS-加载><a href=#NodeJS-加载 class=headerlink title="NodeJS 加载"></a>NodeJS 加载</h4><p>NodeJS 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，从 V13.2 版本开始，NodeJS 已经默认打开了 ES6 模块支持。</p><p>NodeJS 要求 ES6 模块采用 <code>.mjs</code> 后缀文件名。也就是说，只要脚本文件里面使用 <code>import</code> 或 <code>export</code> 命令，那么就必须采用 <code>.mjs</code> 后缀名。NodeJS 遇到 <code>.mjs</code> 文件，就认为它是 ES6 模块，默认启用严格模式。如果不希望将后缀名改成 <code>.mjs</code>，可以在项目的 <code>package.json</code> 文件中，指定 <code>type</code> 字段为 <code>module</code>。一旦设置了以后，该目录里面的 JS 脚本，就被解释成 ES6 模块。如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成 <code>.cjs</code>。如果没有 <code>type</code> 字段，或者 <code>type</code> 字段为 <code>commonjs</code>，则 <code>.js</code> 脚本会被解释成 CommonJS 模块。</p><p>总结：<code>.mjs</code> 文件总是以 ES6 模块加载，<code>.cjs</code> 文件总是以 CommonJS 模块加载，<code>.js</code> 文件的加载取决于 <code>package.json</code> 里面 <code>type</code> 字段的设置。</p><h4 id=main-字段><a href=#main-字段 class=headerlink title="main 字段"></a>main 字段</h4><p><code>package.json</code> 文件有两个字段可以<strong>指定指定模块的入口文件</strong>：<code>main</code> 和 <code>exports</code>。</p><figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>&#123;</span><br><span class=line>    <span class=attr>&quot;type&quot;</span>: <span class=string>&quot;module&quot;</span>,</span><br><span class=line>    <span class=attr>&quot;main&quot;</span>: <span class=string>&quot;./src/index.js&quot;</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p><code>exports</code> 字段的优先级高于 <code>main</code> 字段，它有多种用法。</p><p>1）子目录别名</p><p><code>package.json</code> 文件的 <code>exports</code> 字段可以指定脚本或子目录的别名。</p><figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line>&#123;</span><br><span class=line>    <span class=attr>&quot;exports&quot;</span>: &#123;</span><br><span class=line>        <span class=attr>&quot;./submodeule&quot;</span>: <span class=string>&quot;./src/submodule.js&quot;</span></span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>上面的代码指定 <code>./src/submodule.js</code> 别名为 <code>submodeule</code>，然后就可以从别名加载这个文件。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br><span class=line><span class=keyword>import</span> submodule <span class=keyword>from</span> <span class=string>&#x27;es-module-package/submodule&#x27;</span>;</span><br></pre></td></tr></table></figure><p>2）main 的别名</p><p><code>exports</code> 字段的别名如果是 <code>.</code>，就代表模块的主入口，优先级高于 <code>main</code> 字段，并且可以直接简写成 <code>exports</code> 字段的值。</p><figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line>&#123;</span><br><span class=line>    <span class=attr>&quot;exports&quot;</span>: &#123;</span><br><span class=line>        <span class=attr>&quot;.&quot;</span>: <span class=string>&quot;./main.js&quot;</span></span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>// 等同于</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=attr>&quot;exports&quot;</span>: <span class=string>&quot;./main.js&quot;</span></span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>exports</code> 字段只有支持 ES6 的 NodeJS 才认识，所以可以用来兼容旧版本的 NodeJS。</p><figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>&#123;</span><br><span class=line>    <span class=attr>&quot;main&quot;</span>: <span class=string>&quot;./main-legacy.cjs&quot;</span>,</span><br><span class=line>    <span class=attr>&quot;exports&quot;</span>: &#123;</span><br><span class=line>        <span class=attr>&quot;.&quot;</span>: <span class=string>&quot;./main-modern.cjs&quot;</span></span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>3）条件加载</p><p>利用 <code>.</code> 这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 NodeJS 运行的时候，打开 <code>--experimental-conditional-exports</code> 标志。</p><figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><span class=line>&#123;</span><br><span class=line>    <span class=attr>&quot;type&quot;</span>: <span class=string>&quot;module&quot;</span>,</span><br><span class=line>    <span class=attr>&quot;exports&quot;</span>: &#123;</span><br><span class=line>        <span class=attr>&quot;.&quot;</span>: &#123;</span><br><span class=line>            <span class=attr>&quot;require&quot;</span>: <span class=string>&quot;./main.cjs&quot;</span>,</span><br><span class=line>            <span class=attr>&quot;default&quot;</span>: <span class=string>&quot;./main.js&quot;</span></span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>// 可以简写为</span></span><br><span class=line><span class=comment>// 注意：如果还有其他别名，则不能简写</span></span><br><span class=line>&#123;</span><br><span class=line>    <span class=attr>&quot;exports&quot;</span>: &#123;</span><br><span class=line>        <span class=attr>&quot;require&quot;</span>: <span class=string>&quot;./main.cjs&quot;</span>,</span><br><span class=line>        <span class=attr>&quot;default&quot;</span>: <span class=string>&quot;./main.js&quot;</span></span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h4 id=ES6-模块加载-CommonJS-模块><a href=#ES6-模块加载-CommonJS-模块 class=headerlink title="ES6 模块加载 CommonJS 模块"></a>ES6 模块加载 CommonJS 模块</h4><figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line>&#123;</span><br><span class=line>    <span class=attr>&quot;type&quot;</span>: <span class=string>&quot;module&quot;</span>,</span><br><span class=line>    <span class=attr>&quot;main&quot;</span>: <span class=string>&quot;./index.cjs&quot;</span>,</span><br><span class=line>    <span class=attr>&quot;exports&quot;</span>: &#123;</span><br><span class=line>        <span class=attr>&quot;require&quot;</span>: <span class=string>&quot;./index.cjs&quot;</span>,</span><br><span class=line>        <span class=attr>&quot;default&quot;</span>: <span class=string>&quot;./wrapper.mjs&quot;</span></span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定了 CommonJS 入口文件 <code>index.cjs</code>。下面是这个文件的代码：</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// ./node_modules/pkg/index.cjs</span></span><br><span class=line><span class=built_in>exports</span>.name = <span class=string>&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后，ES6 模块可以加载这个文件。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// ./node_modules/pkg/wrapper.mjs</span></span><br><span class=line><span class=keyword>import</span> cjsModule <span class=keyword>from</span> <span class=string>&#x27;./index.cjs&#x27;</span>;</span><br><span class=line><span class=keyword>export</span> <span class=keyword>const</span> name = cjsModule.name;</span><br><span class=line></span><br><span class=line><span class=comment>// 注意：import 命令加载 CommonJS 模块，只能整体加载，不能只加载单一的输出项</span></span><br><span class=line><span class=comment>// 特例：NodeJS 内置模块可以整体加载，也可以加载指定的输出项</span></span><br><span class=line><span class=comment>// ✅</span></span><br><span class=line><span class=keyword>import</span> packageMain <span class=keyword>from</span> <span class=string>&#x27;commonjs-package&#x27;</span>;</span><br><span class=line><span class=comment>// ❎</span></span><br><span class=line><span class=keyword>import</span> &#123; method &#125; <span class=keyword>from</span> <span class=string>&#x27;commonjs-package&#x27;</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 还有一种变通的加载方法，就是使用 NodeJS 内置的 `module.createRequire()` 方法</span></span><br><span class=line><span class=comment>// ES6 模块通过 `module.createRequire()` 方法可以加载 CommonJS 模块</span></span><br><span class=line><span class=comment>// cjs.cjs</span></span><br><span class=line><span class=built_in>module</span>.exports = <span class=string>&#x27;cjs&#x27;</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// esm.mjs</span></span><br><span class=line><span class=keyword>import</span> &#123; createRequire &#125; <span class=keyword>from</span> <span class=string>&#x27;module&#x27;</span>;</span><br><span class=line><span class=keyword>const</span> <span class=built_in>require</span> = createRequire(<span class=keyword>import</span>.meta.url);</span><br><span class=line></span><br><span class=line><span class=keyword>const</span> cjs = <span class=built_in>require</span>(<span class=string>&#x27;./cjs.cjs&#x27;</span>);</span><br><span class=line>cjs === <span class=string>&#x27;cjs&#x27;</span>; <span class=comment>// true</span></span><br></pre></td></tr></table></figure><h4 id=CommonJS-模块-加载-ES6-模块><a href=#CommonJS-模块-加载-ES6-模块 class=headerlink title="CommonJS 模块 加载 ES6 模块"></a>CommonJS 模块 加载 ES6 模块</h4><p>CommonJS 模块的 <code>require</code> 命令不能加载 ES6 模块。只能使用 <code>import()</code> 这个方法加载。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><span class=line>(<span class=keyword>async</span> () =&gt; &#123;</span><br><span class=line>    <span class=keyword>await</span> <span class=keyword>import</span>(<span class=string>&#x27;./my-app.mjs&#x27;</span>);</span><br><span class=line>&#125;)();</span><br></pre></td></tr></table></figure><h4 id=加载路径><a href=#加载路径 class=headerlink title=加载路径></a>加载路径</h4><p>ES6 模块的加载路径必须给出脚本的<strong>完整路径</strong>，不能省略脚本的后缀名。<code>import</code> 命令和 <code>package.json</code> 文件的 <code>main</code> 字段如果省略脚本的后缀名，会报错。</p><p>为了与浏览器的 <code>import</code> 加载规则相同，NodeJS 的 <code>.mjs</code> 文件支持 URL 路径。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// 同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存</span></span><br><span class=line><span class=keyword>import</span> <span class=string>&#x27;./foo.mjs?query=1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>目前，NodeJS 的 <code>import</code> 命令只支持加载本地模块（file: 协议）和 data: 协议，不支持加载远程模块。此外，脚本路径只支持相对路径，不支持绝对路径（<code>/</code> 或 <code>//</code> 开头的路径）。与浏览器不同的是，NodeJS 的 <code>import</code> 命令是<strong>异步加载</strong>。</p><h4 id=内部变量><a href=#内部变量 class=headerlink title=内部变量></a>内部变量</h4><p>ES6 模块应该是通用的，同一个模块不用修改，就可以运行于浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块特有的一些内部变量。</p><p>首先，就是 <code>this</code> 关键字。ES6 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code>；CommonJS 模块的顶层 <code>this</code> 指向当前模块，这是两者的一个重大差异。</p><p>其次，以下这些顶层变量在 ES6 模块之中也是不存在的。</p><ul><li>arguments</li><li>require</li><li>module</li><li>exports</li><li>__filename</li><li>__dirname</li></ul><h4 id=循环加载（Circular-Dependency）><a href=#循环加载（Circular-Dependency） class=headerlink title="循环加载（Circular Dependency）"></a>循环加载（Circular Dependency）</h4><p>循环加载指的是，A 脚本的执行依赖 B 脚本，B 脚本的执行又依赖 A 脚本。通常，循环加载表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。但是实际上，这是很难避免的，尤其是依赖关系复杂的大型项目。对于 JS 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，<strong>处理循环加载的方法是不一样的，返回的结果也不一样</strong>。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// a.js</span></span><br><span class=line><span class=keyword>const</span> b = <span class=built_in>require</span>(<span class=string>&#x27;b&#x27;</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// b.js</span></span><br><span class=line><span class=keyword>const</span> a = <span class=built_in>require</span>(<span class=string>&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id=CommonJS-模块的循环加载><a href=#CommonJS-模块的循环加载 class=headerlink title="CommonJS 模块的循环加载"></a>CommonJS 模块的循环加载</h4><p>CommonJS 的一个模块，就是一个脚本文件。<code>require</code> 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。以后需要用到这个模块的时候，就会到 <code>exports</code> 属性上面取值。即使再次执行 <code>require</code> 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，<mark class="label info">CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果</mark>，除非手动清除系统缓存。</p><figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line>&#123;</span><br><span class=line>    <span class=comment>// 模块名</span></span><br><span class=line>    <span class=attr>&quot;id&quot;</span>: <span class=string>&quot;...&quot;</span>,</span><br><span class=line>    <span class=comment>// 模块输出的各种接口</span></span><br><span class=line>    <span class=attr>&quot;exports&quot;</span>: &#123;...&#125;,</span><br><span class=line>    <span class=comment>// 该模块的脚本是否执行完毕</span></span><br><span class=line>    <span class=attr>&quot;loaded&quot;</span>: <span class=literal>true</span>,</span><br><span class=line>    ...</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在 <code>require</code> 的时候，就会全部执行。<strong>一旦出现某个模块被循环加载</strong>，就<mark class="label info">只会输出已经执行的部分</mark>，还未执行的部分不会输出。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// a.js</span></span><br><span class=line><span class=built_in>exports</span>.done = <span class=literal>false</span>;</span><br><span class=line><span class=comment>// 加载 b.js，此时 a.js 代码就停在这里，等待 b.js 执行完毕，再往下执行</span></span><br><span class=line><span class=keyword>var</span> b = <span class=built_in>require</span>(<span class=string>&#x27;./b.js&#x27;</span>);</span><br><span class=line><span class=built_in>console</span>.log(<span class=string>&#x27;在 a.js 中，b.done = %j&#x27;</span>, b.done);</span><br><span class=line><span class=built_in>exports</span>.done = <span class=literal>true</span>;</span><br><span class=line><span class=built_in>console</span>.log(<span class=string>&#x27;a.js 执行完毕&#x27;</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// b.js</span></span><br><span class=line><span class=built_in>exports</span>.done = <span class=literal>false</span>;</span><br><span class=line><span class=comment>// 发生了循环加载</span></span><br><span class=line><span class=comment>// 系统会去 a.js 模块对应的 exports 属性取值，可是因为 a.js 还没有执行完</span></span><br><span class=line><span class=comment>// 从 exports 属性只能取回已经执行的部分（exports.done = false;），而不是最后的值</span></span><br><span class=line><span class=keyword>var</span> a = <span class=built_in>require</span>(<span class=string>&#x27;./a.js&#x27;</span>);</span><br><span class=line><span class=comment>// b.js 接着往下执行，等到全部执行完毕，再把执行权交还给 a.js</span></span><br><span class=line><span class=built_in>console</span>.log(<span class=string>&#x27;在 b.js 中，a.done = %j&#x27;</span>, a.done);</span><br><span class=line><span class=built_in>exports</span>.done = <span class=literal>true</span>;</span><br><span class=line><span class=built_in>console</span>.log(<span class=string>&#x27;b.js 执行完毕&#x27;</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// main.js</span></span><br><span class=line><span class=keyword>var</span> a = <span class=built_in>require</span>(<span class=string>&#x27;a.js&#x27;</span>);</span><br><span class=line><span class=comment>// 这里不会再次执行 b.js，而是输出缓存的 b.js 的执行结果</span></span><br><span class=line><span class=keyword>var</span> b = <span class=built_in>require</span>(<span class=string>&#x27;b.js&#x27;</span>);</span><br><span class=line><span class=built_in>console</span>.log(<span class=string>&#x27;在 main.js 中，a.done=%j，b.done=%j&#x27;</span>, a.done, b.done);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><span class=line><span class=meta>#</span><span class=bash> 执行 main.js</span></span><br><span class=line>node main.js</span><br><span class=line></span><br><span class=line>在 b.js 中，a.done = false</span><br><span class=line>b.js 执行完毕</span><br><span class=line>在 a.js 中，b.done = true</span><br><span class=line>a.js 执行完毕</span><br><span class=line>在 main.js 中，a.done=true，b.done=true</span><br></pre></td></tr></table></figure><h4 id=ES6-模块的循环加载><a href=#ES6-模块的循环加载 class=headerlink title="ES6 模块的循环加载"></a>ES6 模块的循环加载</h4><p>ES6 模块处理循环加载与 CommonJS 模块有本质不同。ES6 模块是动态引用，如果使用 <code>import</code> 从一个模块加载变量 <code>import foo from &#39;foo&#39;</code>，那些变量不会被缓存，而是成为一个指向被加载模块的引用，<strong>需要开发者自己保证，真正取到的时候能够取到值</strong>。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// a.mjs</span></span><br><span class=line><span class=keyword>import</span> &#123; bar &#125; <span class=keyword>from</span> <span class=string>&#x27;./b&#x27;</span>;</span><br><span class=line><span class=built_in>console</span>.log(<span class=string>&#x27;a.mjs&#x27;</span>);</span><br><span class=line><span class=built_in>console</span>.log(bar);</span><br><span class=line><span class=keyword>export</span> <span class=keyword>let</span> foo = <span class=string>&#x27;foo&#x27;</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// b.mjs</span></span><br><span class=line><span class=keyword>import</span> &#123; foo &#125; <span class=keyword>from</span> <span class=string>&#x27;./a&#x27;</span>;</span><br><span class=line><span class=built_in>console</span>.log(<span class=string>&#x27;b.mjs&#x27;</span>);</span><br><span class=line><span class=built_in>console</span>.log(foo);</span><br><span class=line><span class=keyword>export</span> <span class=keyword>let</span> bar = <span class=string>&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><span class=line>node --experimental-modules a.mjs</span><br><span class=line></span><br><span class=line>b.mjs</span><br><span class=line>ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure><p>首先，执行 <code>a.mjs</code> 后，引擎发现它加载了 <code>b.mjs</code>，因此会优先执行 <code>b.mjs</code>，然后再执行 <code>a.mjs</code>。接着，执行 <code>b.mjs</code> 时，已知它从 <code>a.mjs</code> 输入了 <code>foo</code> 接口，这时不会去执行 <code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行 <code>console.log(foo);</code> 时，才发现这个接口没有定义，因此报错。</p><p>解决这个问题的方法，就是让 <code>b.mjs</code> 运行时，<code>foo</code> 已经定义。可以通过将 <code>foo</code> 写成函数来解决。</p><figure class="highlight javascript"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><span class=line><span class=comment>// a.mjs</span></span><br><span class=line><span class=keyword>import</span> &#123; bar &#125; <span class=keyword>from</span> <span class=string>&#x27;./b&#x27;</span>;</span><br><span class=line><span class=built_in>console</span>.log(<span class=string>&#x27;a.mjs&#x27;</span>);</span><br><span class=line><span class=built_in>console</span>.log(bar());</span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>foo</span>(<span class=params></span>) </span>&#123;</span><br><span class=line>    <span class=keyword>return</span> <span class=string>&#x27;foo&#x27;</span>;</span><br><span class=line>&#125;</span><br><span class=line><span class=keyword>export</span> &#123; foo &#125;;</span><br><span class=line></span><br><span class=line><span class=comment>// b.mjs</span></span><br><span class=line><span class=keyword>import</span> &#123; foo &#125; <span class=keyword>from</span> <span class=string>&#x27;./a&#x27;</span>;</span><br><span class=line><span class=built_in>console</span>.log(<span class=string>&#x27;b.mjs&#x27;</span>);</span><br><span class=line><span class=built_in>console</span>.log(foo());</span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>bar</span>(<span class=params></span>) </span>&#123;</span><br><span class=line>    <span class=keyword>return</span> <span class=string>&#x27;bar&#x27;</span>;</span><br><span class=line>&#125;</span><br><span class=line><span class=keyword>export</span> &#123; bar &#125;;</span><br></pre></td></tr></table></figure><h4 id=总结><a href=#总结 class=headerlink title=总结></a>总结</h4><p>ES6 模块与 CommonJS 模块的差异：</p><ol><li>当导出的是一个原始类型数据时，CommonJS 模块输出的是值的缓存，不存在动态更新，即输出的是<strong>值的拷贝</strong>，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值；ES6 模块输出的接口，与其对应的值是<mark class="label info">动态绑定关系</mark>，通过该接口，可以取到模块内部实时的值，即输出的是<strong>值的引用</strong>，这个值指向的地址是<strong>只读</strong>的，不能重新赋值</li><li>CommonJS 模块是<strong>运行时加载</strong>；ES6 模块是<strong>编译时</strong>输出接口</li><li>CommonJS 是单个值导出；ES6 模块可以导出多个</li><li>CommonJS 是动态语法，<strong>可以写在条件判断语句中</strong>；ES6 模块是静态语法<strong>只能写在顶层</strong></li><li>CommonJS 的 <code>this</code> 指向当前模块；<mark class="label info">ES6 模块自动采用严格模式</mark>，<code>this</code> 指向 <code>undefined</code></li></ol></div><footer class=post-footer><div class=post-tags><a href=/tags/JavaScript/ rel=tag><i class="fa fa-tag"></i> JavaScript</a><a href=/tags/ES6/ rel=tag><i class="fa fa-tag"></i> ES6</a><a href=/tags/CommonJS/ rel=tag><i class="fa fa-tag"></i> CommonJS</a></div><div class=post-nav><div class=post-nav-item><a href=/2020/05/24/deno-1-0-what-you-need-to-know/ rel=prev title="Deno 1.0：你需要了解的"><i class="fa fa-chevron-left"></i> Deno 1.0：你需要了解的</a></div><div class=post-nav-item><a href=/2020/09/13/deeply-understand-the-principle-of-V8-garbage-collection/ rel=next title="深入理解 V8 的垃圾回收原理">深入理解 V8 的垃圾回收原理<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class=comments id=disqus_thread><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></main><footer class=footer><div class=footer-inner><div class=beian><span class=exturl data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbg==">浙ICP备18010341号-1</span></div><div class=copyright>&copy; <span itemprop=copyrightYear>2022</span><span class=with-love><i class="fa fa-heart"></i></span> <span class=author itemprop=copyrightHolder>KINGMUI</span></div><div class=wordcount><span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-chart-line"></i></span> <span title=站点总字数>137k</span></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fa fa-coffee"></i></span> <span title=站点阅读时长>2:04</span></span></div><div class=busuanzi-count><span class=post-meta-item id=busuanzi_container_site_uv><span class=post-meta-item-icon><i class="fa fa-user"></i></span><span class=site-uv title=总访客量><span id=busuanzi_value_site_uv></span></span></span><span class=post-meta-item id=busuanzi_container_site_pv><span class=post-meta-item-icon><i class="fa fa-eye"></i></span><span class=site-pv title=总访问量><span id=busuanzi_value_site_pv></span></span></span></div></div></footer><script size=300 alpha=0.6 zindex=-1 src=https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js></script><script src=https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin=anonymous></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/next-boot.js></script><script src=https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin=anonymous></script><script src=/js/third-party/search/local-search.js></script><script src=//code.tidio.co/2mlfx8hyeje2cy9cft6rpturddkkzkon.js></script><script src=/js/third-party/chat/tidio.js></script><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script class=next-config data-name=disqus type=application/json>{"enable":true,"shortname":"kingmui","count":false,"i18n":{"disqus":"disqus"}}</script><script src=/js/third-party/comments/disqus.js></script></body></html>